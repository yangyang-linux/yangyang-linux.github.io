---
layout:     post
title:      Docker
subtitle:   Docker学习
date:       2021-7-12
author:     YY——阳阳
header-img: img/post/1.jpg
catalog: true
tags:
    - Docker
---



## Docker

>  docker学习
>
>  - DOCKER概述;
>
>  - DOCKER安装
>
>  - DOCKER命令
>
>    - 镜像命令
>
>    - 容器命令
>
>    - 操作命令
>
>    - 。。。
>
>
>
>  - Docker镜像
>  - 容器的数据卷
>   - DockerFile
>   - Docker⽹络原理
>   - IDEA整合DOCKER
>   - Docker Compose
>   - Docker Swarm
>   - CI\CD jenkins

## Docker概述

#### Docker为什么会出现？

⼀款产品，开发-----上线，两套环境！应⽤环境！应⽤配置！

开发-------运维。 问题：我在我的电脑上可以使⽤！版本更新，导致服务不可⽤！对于运维来说考验⼗分⼤！

开发即运维！！！

环境配置⼗分麻烦，每⼀个机器都要配置环境（集群Redis、ES、Hadoop。。。）！！费时费⼒！！

发布⼀个项⽬jar+(REdis Mysql jdk ES)，项⽬带上环境安装打包！！

之前在服务器配置⼀个应⽤的环境（REdis Mysql jdk ES Hadoop）,配置超麻烦，不能够跨平台！！

windows，连最后发布到linux

传统：开发jar打包， 运维来做

现在：开发打包部署上线，⼀套流程做完

*java------apk-----发布(应⽤商店)----张三使⽤apk--------安装即可⽤*

*java------jar(环境)-------打包项⽬带环境(镜像！)--------Docker仓库：商店-----------下载我么发布的镜像直接运⾏即可*



**Docker对于以上问题产⽣了⼀个解决⽅案**

[![WKGGd0.png](https://z3.ax1x.com/2021/07/16/WKGGd0.png)](https://imgtu.com/i/WKGGd0)

docker思想来⾃⼀个集装箱

JRE ----多个应⽤（端⼝冲突）--------因为原来都是交叉的

隔离：Docker核⼼思想！打包装箱！每个箱⼦都是互相隔离的

**⽔果 -----⽣化武器**

Docker通过隔离机制，可以将服务器利⽤到极致

本质：所有的技术都是因为出现⼀些问题才会出现的；

#### Docker历史

2010 ，⼏个搞IT的年轻⼈，在美国成⽴了⼀家公司`dotcloud`,做⼀些pass的云计算服务,LXC(linux虚拟机)有关的容器技术

他们将⾃⼰的**容器化技术**命名就是Docker！

刚诞⽣的时候，没有引起⾏业的注意！！dotcloub，就活不下去！！

开源

2013年，Docker开源；

Docker越来越多的⼈发现了Docker的优点，每个⽉都会更新

2014年4⽉9⽇，Docker1.0发布

Docker这么⽕的原因？它相对虚拟机⼗分轻巧

在容器技术出现之前，我们都是使⽤虚拟机

虚拟机运⾏：在windows或者mac中安装⼀个虚拟机软件vmware，可以虚拟⼀台或多台电脑！占⽤内

存太⼤！笨重！

虚拟机也是属于虚拟化技术，Docker容器技术，也是⼀种虚拟化技术！

```shell
vm:linux centos(原⽣镜像)，隔离，就需要开启多个虚拟机 ！⼏个G 启动需要⼏分钟
Docker:隔离，镜像(最核⼼的环境 4m+jdk+mysql)⼗分的⼩巧，运⾏镜像就可以了！⼩巧！⼏M 、KB 秒级启动
```

到现在所有开发⼈员必须会

> 聊聊Docker

Docker是基于GO语⾔开发的 ！开源项⽬

官⽹：[https://www.docker.com](https://www.docker.com)

[![WKG0y9.png](https://z3.ax1x.com/2021/07/16/WKG0y9.png)](https://imgtu.com/i/WKG0y9)

⽂档地址：https://docs.docker.com Docker的⽂档超级详细的！

仓库地址：https://registry.hub.docker.com

#### Docker能干嘛？

>  之前的虚拟机技术

[![WKGBLR.png](https://z3.ax1x.com/2021/07/16/WKGBLR.png)](https://imgtu.com/i/WKGBLR)

**虚拟机技术的缺点：**

1.  占⽤资源⼗分多

2. 冗余步骤⼗分多

3. 启动很慢

---

> 容器化技术

**容器化技术不是模拟的完整的操作系统**

[![WKGsdx.png](https://z3.ax1x.com/2021/07/16/WKGsdx.png)](https://imgtu.com/i/WKGsdx)

**⽐较Docker和虚拟机技术的不同：**

- 传统虚拟机，虚拟出⼀个硬件 ，运⾏⼀个完整的操作系统，然后在这个系统上安装和运⾏软件
- 容器的应⽤直接运⾏在宿主机的内容，容器是没有⾃⼰的内核，也没有虚拟我们的硬件，所以就轻便了
- 每个容器件恶事互相隔离的，每个容器内都有⼀个属于⾃⼰的⽂件系统

---

> DebOps(开发，运维)

**更快速的交付和部署**

传统：⼀堆的帮助⽂档，安装程序

Docker：打包镜像，发布测试，⼀键运⾏

**更便捷的升级和扩缩容**

使⽤Docker之后，我们部署应⽤就和搭积⽊⼀样

项⽬打包为⼀个镜像，扩展 服务器A! 服务器B

**更简单的系统运维**

在容器化之后，我们的开发或测试环境,都是⾼度⼀致的

**更⾼效的计算机资源利⽤**

Docker 是内核级别的虚拟化 ，可以在物理机上运⾏很多的容器实例！服务器的性能可以被压榨到极致

## Docker安装

#### Docker基本组成

[![WKG2WD.png](https://z3.ax1x.com/2021/07/16/WKG2WD.png)](https://imgtu.com/i/WKG2WD)

**镜像(image)：**

docker镜像就好⽐是⼀个模版，可以通过这个模版来创建⼀个容器服务，tomcat===>run(运⾏起

来)===>tomcat01容器(提供服务)，通过这个镜像可以创建多个容器(最终服务器运⾏，或者项⽬运⾏

就是在容器中的)

**容器（container）：**

Docker利⽤容器技术，独⽴运⾏⼀个或者⼀组应⽤，通过镜像创建的

启动，停⽌，删除，基本命令！

⽬前就可以把容器理解为简易的linux系统

**仓库（repository）：**

存放镜像的地⽅！

仓库分为公有仓库和私有仓库：

Docker Hub（默认是国外的）

阿⾥云。。。。都有容器服务（配置镜像加速）

#### 安装Docker

> 环境准备

1. 需要会⼀点点linux基础

2. Centos

3. 使⽤xshell连接远程服务器操作

> 环境查看

```bash
# 系统内核是3.10以上的
[root@localhost ~]# uname -r
4.18.0-240.el8.x86_64
[root@localhost ~]# uname -r
4.18.0-240.el8.x86_64
# 系统版本
[root@localhost ~]# cat /etc/os-release
NAME="CentOS Linux"
VERSION="8"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="8"
PLATFORM_ID="platform:el8"
PRETTY_NAME="CentOS Linux 8"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:8"
HOME_URL="https://centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"
CENTOS_MANTISBT_PROJECT="CentOS-8"
CENTOS_MANTISBT_PROJECT_VERSION="8"
```

> 安装

帮助⽂档：

```shell
# 1.卸载旧的版本
sudo yum remove docker \
 docker-client \
 docker-client-latest \
 docker-common \
 docker-latest \
 docker-latest-logrotate \
 docker-logrotate \
 docker-engine
# 2.需要的安装包
yum install -y yum-utils
# 3.设置镜像的仓库
yum-config-manager \
 --add-repo \
 https://download.docker.com/linux/centos/docker-ce.repo #默认是从国外的！
 
yum-config-manager \
 --add-repo \
 http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #推荐使⽤阿⾥
云
 
# 更新yum软件包索引：
[root@localhost ~]# yum makecache 
# 4.安装Docker相关的内容 docker-ce 社区 ee 企业版
yum install docker-ce docker-ce-cli containerd.io
# 5.启动Docker
systemctl start docker
# 6.使⽤docker version查看是否安装成功
```

[![WKGWSe.png](https://z3.ax1x.com/2021/07/16/WKGWSe.png)](https://imgtu.com/i/WKGWSe)

```shell
# 7.使⽤hello world
docker run hello-world
```

[![WKGhyd.png](https://z3.ax1x.com/2021/07/16/WKGhyd.png)](https://imgtu.com/i/WKGhyd)

```shell
# 8.查看下载的hello-world镜像
[root@localhost ~]# docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
hello-world latest d1165f221234 4 weeks ago 13.3kB
```

了解：卸载docker

```shell
# 1.卸载依赖
yum remove docker-ce docker-ce-cli containerd.io
# 2.删除资源
rm -rf /var/lib/docker
rm -rf /var/lib/containerd
# /var/lib/docker docker的默认⼯作路径
```

#### 阿里云镜像加速

1. 登陆阿⾥云找到容器服务
2. 找到镜像加速地址

[![WKGTTP.png](https://z3.ax1x.com/2021/07/16/WKGTTP.png)](https://imgtu.com/i/WKGTTP)

3. 配置使⽤

```shell
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://s82h6lek.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

#### 华为云镜像加速

[Docker安装配置及华为云镜像加速_刘念的计算机空间-CSDN博客](https://blog.csdn.net/qq_43308275/article/details/112862370)

#### 回顾helloworld

[![WKGhyd.png](https://z3.ax1x.com/2021/07/16/WKGhyd.png)

[![WKJifU.png](https://z3.ax1x.com/2021/07/16/WKJifU.png)](https://imgtu.com/i/WKJifU)

#### 底层原理

**Docker是怎么工作的？**

Docker是⼀个Client-Server结构的系统，Docker的守护进程运⾏在主机上，通过Socket从客户端访问！

Docker-server接收到Docker-Client的指令，就会执⾏！

[![WKJE6J.png](https://z3.ax1x.com/2021/07/16/WKJE6J.png)](https://imgtu.com/i/WKJE6J)

---

**Docker为什么⽐vm快？**

1. Docker有着⽐虚拟机更少的⽹络进程

2. Docker利⽤的是宿主机的内核，vm需要的是GuestOS；

[![WKJVX9.png](https://z3.ax1x.com/2021/07/16/WKJVX9.png)](https://imgtu.com/i/WKJVX9)

所以说，新建⼀个容器的时候，docker不需要像虚拟机⼀样重新加载⼀个操作系统内核，避免引导

型操作，虚拟机加载GuestOS，分钟级别的 ，Docker是利⽤宿主机的操作系统，省略了复杂的过

程，秒级！

[![WKJm01.png](https://z3.ax1x.com/2021/07/16/WKJm01.png)](https://imgtu.com/i/WKJm01)

[![WKJnTx.png](https://z3.ax1x.com/2021/07/16/WKJnTx.png)](https://imgtu.com/i/WKJnTx)

## Docker常用命令

#### 帮助命令

```shell
docker version # 显示docker的版本信息
docker info # 显示docker的系统信息，包括镜像和容器的数量
docker 命令 --help # 万能命令帮助
```

帮助⽂档地址：https://docs.docker.com/reference/

#### 镜像命令

**docker images 查看本地所有镜像**

```shell
[root@localhost ~]# docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
hello-world latest d1165f221234 4 weeks ago 13.3kB

#解释
REPOSITORY 	镜像的仓库源
TAG 		镜像的标签
IMAGE ID 	镜像的ID
CREATED 	镜像的创建时间
SIZE 		镜像的⼤⼩

#可选项
Options:
 -a, --all 		#列出所有镜像
 -q, --quiet 	#只显示镜像的ID
```

---

**docker search 搜索镜像**

```shell
[root@192 roo]# docker search mysql

NAME     DESCRIPTION      								STARS     OFFICIAL   AUTOMATED
mysql    MySQL is a widely used, open-source relation…   11120     [OK]       
mariadb  MariaDB Server is a high performing open sou…   4216      [OK]       

#可选项，通过收藏过滤
--filter=STARS=3000 #搜索出来的镜像就是STARS⼤于3000的
[root@192 roo]# docker search mysql --filter=STARS=3000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   11120     [OK]       
mariadb   MariaDB Server is a high performing open sou…   4216      [OK]       
[root@192 roo]# docker search mysql --filter=STARS=5000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   11120     [OK]      
```

---

**docker pull 下载镜像**

```shell
#下载镜像 docker pull 镜像名[:tag版本]
[root@localhost ~]# docker pull mysql
Using default tag: latest #如果不写tag 默认就是latest
latest: Pulling from library/mysql
a076a628af6f: Pull complete #分层下载，docker image的核⼼ 联合⽂件系统
f6c208f3f991: Pull complete 
88a9455a9165: Pull complete
406c9b8427c6: Pull complete
7c88599c0b25: Pull complete
25b5c6debdaf: Pull complete
43a5816f1617: Pull complete
1a8c919e89bf: Pull complete
9f3cf4bd1a07: Pull complete
80539cea118d: Pull complete
201b3cad54ce: Pull complete
944ba37e1c06: Pull complete
Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c
#签名(防伪)
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest #真实地址

#等价
docker pull mysql
docker rmi 删除镜像！
容器命令：
说明：有了镜像才可以创建容器，linux，下载⼀个centos镜像来测试学习
新建容器并启动
docker pull docker.io/library/mysql:latest

#指定版本下载
[root@localhost ~]# docker pull mysql:5.7
5.7: Pulling from library/mysql
a076a628af6f: Already exists
f6c208f3f991: Already exists
88a9455a9165: Already exists
406c9b8427c6: Already exists
7c88599c0b25: Already exists
25b5c6debdaf: Already exists
43a5816f1617: Already exists
1831ac1245f4: Pull complete
37677b8c1f79: Pull complete
27e4ac3b0f6e: Pull complete
7227baa8c445: Pull complete
Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7
```

[![image-20210714092609060.png](https://www.z4a.net/images/2021/07/16/image-20210714092609060.png)](https://www.z4a.net/image/g11IgJ)

**docker rmi 删除镜像！**

```shell
[root@localhost ~]# docker rmi -f 镜像id #删除指定的镜像
[root@localhost ~]# docker rmi -f 镜像id 镜像id 镜像id #删除多个镜像
[root@localhost ~]# docker rmi -f $(docker images -aq) #删除全部的镜像
```



#### Docker容器命令

**说明：有了镜像才可以创建容器，linux，下载⼀个centos镜像来测试学习**

```shell
docker pull centos
```

**新建容器并启动**

```shell
docker run [可选参数] images

#参数说明
--name=="Name" 	容器名字 tomcat01 tomacat02，⽤来区分容器
-d 				后台⽅式运⾏
-it 			使⽤交互⽅式运⾏，进⼊容器查看内容
-p 				指定容器的端⼝ -p 8080:8080
				# -p ip:主机端⼝:容器端⼝ (常⽤) 
				# -p 主机端⼝:容器端⼝ (常⽤) 
				# -p 容器端⼝
-P 				随机指定端⼝ 


#测试，启动并进⼊容器
[root@localhost ~]# docker run -it centos /bin/bash
[root@80138667de4f /]#
[root@80138667de4f /]# ls #查看容器内的centos，基础版本，很多命令都是不完善的
bin dev etc home lib lib64 lost+found media mnt opt proc root run 
sbin srv sys tmp usr var

#从容器中退回到主机
[root@80138667de4f /]# exit
exit
[root@localhost ~]# ls
anaconda-ks.cfg Desktop Documents Downloads initial-setup-ks.cfg Music 
Pictures Public Templates Videos
```

---

**列出当前正在运⾏的容器**

```shell
#docker ps 命令
		#显示正在运⾏的容器
-a 		# 列出当前正在运⾏的容器+带出历史运⾏过的容器
-n=? 	#显示最近创作的容器
-q 		# 只显示容器的编号

#docker ps -a
		#显示曾经所有运行过的容器

[root@192 roo]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@192 roo]# docker ps -a
CONTAINER ID   IMAGE         COMMAND       CREATED              STATUS                        PORTS     NAMES
fce1a8d0bfaa   centos        "/bin/bash"   About a minute ago   Exited (127) 28 seconds ago             jolly_ritchie
b81764395c1b   hello-world   "/hello"      6 minutes ago        Exited (0) 6 minutes ago                crazy_sanderson
a2e6649d6749   hello-world   "/hello"      16 minutes ago       Exited (0) 16 minutes ago               wonderful_noether
6db1aa868ed6   hello-world   "/hello"      15 hours ago         Exited (0) 15 hours ago                 loving_torvalds
2a30c9d2e991   hello-world   "/hello"      38 hours ago         Exited (0) 38 hours ago                 hardcore_mahavira
328fd8adb1e7   hello-world   "/hello"      38 hours ago         Exited (0) 38 hours ago                 practical_banzai

```

---

**退出容器**

```shell
exit 			#直接容器停⽌并退出
ctrl + P + Q 	#容器不停⽌退出
```

**删除容器**

```shell
docker rm 容器id 							#删除指定的容器,不能删除正在运⾏的容器,如果要强制删除，rm -f
docker rm -f $(docker ps -aq) 			#删除所有的容器
docker ps -a -q| xargs docker rm 		#删除所有的容器
```

**启动和停⽌容器的操作**

```shell
docker start 容器id 		#启动容器
docker restart 容器id 	#重启容器
docker stop 容器id 		#停⽌当前正在运⾏的容器
docker kill 容器id 		#强制停⽌当前容器
```

#### 常⽤的其他命令:

**后台启动容器**

```shell
# 命令 docker run -d 镜像名
[root@localhost ~]# docker run -d centos

# docker ps 发现 centos停⽌了

# 常⻅的坑，docker容器使⽤后台运⾏就必须要有⼀个前台进程,docker发现没有应用，就会自动停止
# nginx，容器启动后，发现⾃⼰没有提供服务，就会⽴刻停⽌，就是没有程序了
```

---

**查看日志**

```shell
docker logs --help
docker logs -f -t -tail 容器id 	#没有⽇志

# ⾃⼰编写⼀段shell脚本
“while true; do echo LGQ ;sleep 2;done”
[root@localhost ~]# docker run -d centos /bin/sh -c "while true; do echo yangyang;sleep 1;done"
d303f1869bfb684c0d083ea61a56e00680b0787be5bcd2cb38af24c34f6c2ba2
[root@localhost ~]# docker ps
CONTAINER ID IMAGE COMMAND 					CREATED STATUS  PORTS 					NAMES
d303f1869bfb centos "/bin/sh -c 'while t…" 10 seconds ago 	Up 4 seconds	goofy_shannon
2338d4c660bb centos "/bin/bash" 			12 minutes ago 	Up 12 minutes gifted_merkle

# 显示⽇志
-tf				#显示日志
--tail number 	#要显示的⽇志条数
-n number 		#要显示的⽇志条数
[root@localhost ~]# docker logs -tf --tail 10 d303f1869bfb
```

---

**查看容器中的进程信息**

```shell
# 命令 docker top 容器id
[root@192 roo]# docker top 0bb23343e3dc
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                7816                7797                1                   22:10               ?                   00:00:00            /bin/sh -c while true;do echo yangyang;sleep 1;done
root                7905                7816                0                   22:10               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1

```

---

**查看镜像元数据**

```shell
# 命令
docker inspect 容器id

# 测试
[root@192 roo]# docker inspect 0bb23343e3dc
[
    {
        "Id": "0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c",
        "Created": "2021-07-14T02:10:07.055890513Z",
        "Path": "/bin/sh",
        "Args": [
            "-c",
            "while true;do echo yangyang;sleep 1;done"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 7816,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2021-07-14T02:10:07.611405101Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55",
        "ResolvConfPath": "/var/lib/docker/containers/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c/hostname",
        "HostsPath": "/var/lib/docker/containers/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c/hosts",
        "LogPath": "/var/lib/docker/containers/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c-json.log",
        "Name": "/brave_boyd",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/31e3bc17c2d9a4927a25969af8159f2a978eac85b59da702f1b8b73dbd74c69b-init/diff:/var/lib/docker/overlay2/20b8e8381019a76417396ddc731cc09f767b78a17305e90e1ca2fab3eed8d937/diff",
                "MergedDir": "/var/lib/docker/overlay2/31e3bc17c2d9a4927a25969af8159f2a978eac85b59da702f1b8b73dbd74c69b/merged",
                "UpperDir": "/var/lib/docker/overlay2/31e3bc17c2d9a4927a25969af8159f2a978eac85b59da702f1b8b73dbd74c69b/diff",
                "WorkDir": "/var/lib/docker/overlay2/31e3bc17c2d9a4927a25969af8159f2a978eac85b59da702f1b8b73dbd74c69b/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "0bb23343e3dc",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "while true;do echo yangyang;sleep 1;done"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20201204",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "b14dbe27edc30bec32319d490380ec48c6a71763a2976535195fbfeb68b6b72b",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/b14dbe27edc3",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "b87ed48c0e8b119644d517e69061245e7d539bacba258c09106a4c8f9748b030",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "099aaaefd6fd69860eb620959fb3786d3eed7271793a2400a742b02e14ff5e52",
                    "EndpointID": "b87ed48c0e8b119644d517e69061245e7d539bacba258c09106a4c8f9748b030",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
```

---

**进入当前正在运行的容器**

```shell
# 我们通常容器id都是使⽤后台⽅式运⾏的，需要进⼊其中的容器，修改⼀些配置

#命令
docker exec -it 容器id /bin/bash

#测试
[root@192 roo]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
0bb23343e3dc   centos    "/bin/sh -c 'while t…"   5 minutes ago   Up 5 minutes             brave_boyd
[root@192 roo]# docker exec -it 0bb23343e3dc /bin/bash
[root@0bb23343e3dc /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@0bb23343e3dc /]# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 02:10 ?        00:00:00 /bin/sh -c while true;do echo yangyang;sleep 1;done
root         341       0  0 02:15 pts/0    00:00:00 /bin/bash
root         493       1  0 02:17 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
root         494     341  0 02:17 pts/0    00:00:00 ps -ef

# 方式二
docker attach 容器id
正在执⾏当前的代码==>

#docker exec 		#进⼊容器后开启⼀个新的终端，可以在里面操作（常用）
#dockeer attach 	# 进⼊容器正在执⾏的终端，不会执⾏新的进程！
```

---

**将容器内⽂件拷⻉到主机上**

```shell
docker cp 容器id:容器内路径 ⽬的主机路径
#查看当前主机⽬录下
[root@192 roo]# docker run -it centos /bin/bash
[root@8636fcaea2e7 /]# [root@192 roo]# 
[root@192 roo]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES
8636fcaea2e7   centos    "/bin/bash"   9 seconds ago   Up 7 seconds             laughing_leavitt
[root@192 roo]# cd  /home
[root@192 home]# ls
roo
[root@192 home]# touch yangyang.java
[root@192 home]# ls
roo  yangyang.java
[root@192 home]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS          PORTS     NAMES
8636fcaea2e7   centos    "/bin/bash"   About a minute ago   Up 59 seconds             laughing_leavitt

#进入容器内部
[root@192 home]# docker attach 8636fcaea2e7 
[root@8636fcaea2e7 /]# cd /home
[root@8636fcaea2e7 home]# ls
[root@8636fcaea2e7 home]# touch yangyang .java
[root@8636fcaea2e7 home]# ls
yangyang
[root@8636fcaea2e7 home]# touch yangyang.java
[root@8636fcaea2e7 home]# ls
yangyang  yangyang.java

#将文件拷贝出来到主机上
[root@8636fcaea2e7 home]# read escape sequence
[root@192 home]# docker cp 8636fcaea2e7/home/yangyang /home
must specify at least one container source
[root@192 home]# docker cp 8636fcaea2e7:/home/yangyang /home
[root@192 home]# ls
roo  yangyang  yangyang.java

# 拷⻉是⼀个⼿动的过程 未来我们可以使⽤⼀个 -v 卷的技术，可以实现，⾃动同步
```

==学习⽅式:将所有命令全部敲⼀遍，⾃⼰记录笔记！==

#### 小结

<img src="https://www.z4a.net/images/2021/07/16/image-20210714103003092.png" alt="image-20210714103003092.png" border="0" />

---

![image-20210714103213163](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714103213163.png)

![image-20210714103247654](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714103247654.png)

>  docker的命令是⼗分多的，上⾯学习的搜是最常⽤的容器和镜像命令，之后还有很多命令
>
> 接下来就是练习

#### 作业练习

> Docker安装Nginx

```shell 
# 1.搜索镜像
 docker search nginx
# 2.下载镜像
 docker pull nginx
# 3.运行测试
[root@192 ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
nginx         latest    4cdc5dd7eaad   7 days ago     133MB
hello-world   latest    d1165f221234   4 months ago   13.3kB
centos        latest    300e315adb2f   7 months ago   209MB

-d			# 后台运行
--name		# 给容器命名
-p			# 宿主机端口：容器内部端口
[root@192 ~]# docker run -d --name nginx01 -p 3344:80 nginx
7c882abe2415bd35124e5026782c72df61806c41a039e844a19ec92a17bd3066
[root@192 ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES
7c882abe2415   nginx     "/docker-entrypoint.…"   3 seconds ago   Up 2 seconds   0.0.0.0:3344->80/tcp, :::3344->80/tcp   nginx01
[root@192 ~]# curl 127.0.0.1:3344
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>

#进入容器
[root@192 ~]# docker exec -it nginx01 /bin/bash
root@7c882abe2415:/# whereis nginx
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@7c882abe2415:/# cd /etc/nginx
root@7c882abe2415:/etc/nginx# ls
conf.d	fastcgi_params	mime.types  modules  nginx.conf  scgi_params  uwsgi_params
root@7c882abe2415:/etc/nginx# 

```

![image-20210714110359456](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714110359456.png)

思考问题：我们每次改动nginx配置文件，都需要进入容器内部?十分的麻烦，我要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改?    -v    数据卷?



> Docker来安装⼀个tomcat

```shell
# 官⽅的使⽤
docker run -it --rm tomcat:9.0

# 我们之前的启动都是后台，停⽌了容器之后，容器还可以查到 docker run -it --rm 	⼀般⽤来测试，⽤完即删

# 先下载再启动
docker pull tomcat:9.0

# 启动并运⾏
[root@192 ~]# docker run -d -p 3355:8080 --name tomcat01 tomcat

#  测试访问没有问题

# 进入容器
[root@192 ~]# docker exec -it tomcat01 /bin/bash
# 发现问题：1、linux命令少了2、没有webapps。阿里云镜像的原因，默认是最小的镜像，所以不必要的都剔除了

#部署tomcat
[root@192 ~]# docker exec -it tomcat01 /bin/bash
root@c73003bfe775:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@c73003bfe775:/usr/local/tomcat# ll
bash: ll: command not found
root@c73003bfe775:/usr/local/tomcat# cd webapps.dist
root@c73003bfe775:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@c73003bfe775:/usr/local/tomcat/webapps.dist# cd ../
root@c73003bfe775:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@c73003bfe775:/usr/local/tomcat# cd webapps
root@c73003bfe775:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager
#访问外网，没有问题
```

思考问题：我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以在容器外部提供一个映射路径 , webapps，我们在外部放置项目，就自动同步到内部就好了!



> 部署es+kibana

```shell
# es 暴露的端⼝很多
# es ⼗分消耗内存
# es 的数据⼀般需要放置到安全⽬录！挂载

#启动 elasticsearch
思考：使⽤kibana连接es？思考如何才能连接过去
可视化
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2

# 启动了，linux就卡住了 docker stats查看cpu的状态

# 测试es是否成功
[root@192 ~]# curl 127.0.0.1:9200
{
  "name" : "2464c92a9984",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "8srwqr_wR2acAIY6WvIwFg",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}

# es 是⼗分耗内存的
# 查看 docker stats
#赶紧关闭，增加内存限制
```

![image-20210714193831166](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714193831166.png)

```shell
#赶紧关闭，增加内存限制,修改配置⽂件 -e 环境配置修改
[root@192 ~]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2
```

![image-20210714201149142](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714201149142.png)

思考：使⽤kibana连接es？思考如何才能连接过去!

![image-20210714204228521](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714204228521.png)

#### 可视化

- portainer(先⽤这个)

```shell
docker run -d -p 8088:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

- Rancher(CI/CD再⽤)

**什么是portainer?**

Docker 图形化界⾯管理⼯具！提供⼀个后台⾯板供我们操作

```shell
docker run -d -p 8088:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

访问测试：外⽹：8088 http://192.168.80.1:8088/#/init/admin

通过它来访问

![image-20210714204944138](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714204944138.png)

选择本地的

![image-20210714205027240](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205027240.png)

进入之后的面板

![image-20210714205100201](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205100201.png)

![image-20210714205251288](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205251288.png)

可视化⾯板平时不会⽤，测试完即可

## Docker镜像讲解

#### 镜像是什么

镜像是⼀种轻量级可执⾏的软件包，⽤来打包软件的运⾏环境和基于环境开发的软件，包含运⾏某个软件所需要的所有内容，包括代码，运⾏时库，环境变量和配置⽂件

所有的应⽤直接打包docker镜像，就可以直接运⾏

如何得到镜像：

- 从远程仓库下载
- 朋友拷⻉
- 自己制作⼀个镜像 DockerFile

#### Docker镜像加速

> UnionFS(联合⽂件系统)

我们下载的时候看到的⼀层⼀层就是这个![image-20210714205512988](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205512988.png)

UnionFS(联合⽂件系统)：Union⽂件系统(UnionFS)是⼀种分层轻量级并且⾼性能的⽂件系统，他⽀持对⽂件系统的更改，作为⼀次提交来⼀层层的叠加，同时可以将不同的⽬录挂载到同⼀个虚拟⽂件系统下（unite several directories into a single virtual filesystem）。Union⽂件系统是Docker镜像的基础，镜像可以通过分层来继承，基于基础镜像（没有⽗镜像），可以制作各种具体的镜像。

特性：⼀次同时加载多个⽂件系统，但从外⾯来看，只能看到⼀个⽂件系统联合加载会把各层⽂件系统叠加起来，这样最终⽂件系统会包括所有底层的⽂件和⽬录

知乎解读：https://zhuanlan.zhihu.com/p/47025759?from_voters_page=true

---

> Docker镜像加载的原理

Docker镜像实际由⼀层层的⽂件系统组成，这种层级的⽂件系统UnionFS。



bootfs(coot dile system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs的⽂件系统，在docker镜像的最底层时是botfs。这⼀层与我们典型的Linux/Unix是⼀样的，包含boot加载器和内核，当boot加载完之后整个内核就在内存中了，此时的内存使⽤权已由bootfs转交给内核，此时系统也会卸载bootfs。

⿊屏---开机进⼊系统

rootfs(root file system)，在bootfs上，包含的就是典型的Linux系统中的/dev，/proc，/bin，/etc等标准⽬录⽂件，rootfs就是各种不同的操作系统的发⾏版，⽐如ubuntu，Centos等等；

![image-20210714205906257](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205906257.png)

平时我们安装的虚拟机的CentOS都是好⼏个G，为什么Docker这⾥才200M？

![image-20210714205923424](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205923424.png)

对于⼀个精简的OS，rootfs可以⼩，只需要包含最基本的命令，⼯具和程序库就可以了，因为底层直接⽤host的kernel，⾃⼰只需要提供⼀个rootfs酷可以了，由此可⻅对于不同的linux发⾏版bootfs‘基本上是⼀致的，rootfs‘会有差别，因此不同的发⾏版可以公⽤bootfs。

**虚拟机是分钟级别的，容器是秒级的**

#### 分层理解

> 分层的镜像

我们可以下载⼀个镜像，注意观察下载的⽇志输出，可以看到是⼀层⼀层在下载！

![image-20210714210352763](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714210352763.png)

思考：为什么docker镜像要采⽤这种分层结构呢？

最⼤的好处就是资源共享，⽐如有多个镜像都从想通的base镜像构建⽽来，那么宿主机只需在磁盘上保留⼀份base镜像，同时内存中也只需要加载⼀份镜像，这样就可以为所有的容器服务了，⽽且镜像的每⼀层都可以共享。

查看镜像分层的⽅式可以通过`docker image inspect` 命令！

```shell
[root@192 ~]# docker pull redis
Using default tag: latest
latest: Pulling from library/redis
b4d181a07f80: Already exists 
86e428f79bcb: Pull complete 
ba0d0a025810: Pull complete 
ba9292c6f77e: Pull complete 
b96c0d1da602: Pull complete 
5e4b46455da3: Pull complete 
Digest: sha256:b6a9fc3535388a6fc04f3bdb83fb4d9d0b4ffd85e7609a6ff2f0f731427823e3
Status: Downloaded newer image for redis:latest
docker.io/library/redis:latest
[root@192 ~]# docker image inspect redis:latest
[
    {
        "Id": "sha256:08502081bff61084d64fc76f0f90ea39b89935cd071d9e12c5374ae191ff53c0",
        "RepoTags": [
            "redis:latest"
        ],
        "RepoDigests": [
            "redis@sha256:b6a9fc3535388a6fc04f3bdb83fb4d9d0b4ffd85e7609a6ff2f0f731427823e3"
        ],
        "Parent": "",
        "Comment": "",
        "Created": "2021-06-23T16:36:30.182210591Z",
        "Container": "ff24eb24b3cff07ced352081b984ecafb749404469993462cbd773258d1a56fe",
        "ContainerConfig": {
            "Hostname": "ff24eb24b3cf",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "6379/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.12",
                "REDIS_VERSION=6.2.4",
                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.2.4.tar.gz",
                "REDIS_DOWNLOAD_SHA=ba32c406a10fc2c09426e2be2787d74ff204eb3a2e496d87cff76a476b6ae16e"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "#(nop) ",
                "CMD [\"redis-server\"]"
            ],
            "Image": "sha256:e39f8a5eb6f06bc15438105f98a52afaa51dc6fb498e2e49ddc5e38916478394",
            "Volumes": {
                "/data": {}
            },
            "WorkingDir": "/data",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {}
        },
        "DockerVersion": "19.03.12",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "6379/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.12",
                "REDIS_VERSION=6.2.4",
                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.2.4.tar.gz",
                "REDIS_DOWNLOAD_SHA=ba32c406a10fc2c09426e2be2787d74ff204eb3a2e496d87cff76a476b6ae16e"
            ],
            "Cmd": [
                "redis-server"
            ],
            "Image": "sha256:e39f8a5eb6f06bc15438105f98a52afaa51dc6fb498e2e49ddc5e38916478394",
            "Volumes": {
                "/data": {}
            },
            "WorkingDir": "/data",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": null
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 105394545,
        "VirtualSize": 105394545,
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/2d481fb67b4236c0de192288f3dc2b1052fc5326e24f15f208390b2f6424b948/diff:/var/lib/docker/overlay2/901e9c9ea320b633f37bc0a7268e8a46bc7083d7dd7a6453d1614455d5d1fbe5/diff:/var/lib/docker/overlay2/028089062f384a27789ab22779d1a9ae90e1f603efedd2abb27509a5b5811267/diff:/var/lib/docker/overlay2/f418e7b2f54a421ffd1583543fc8cc2fcdf94ad3805f096adcb7bf6e2e93e19b/diff:/var/lib/docker/overlay2/7544f583bcb8cb845806da98a5f92187843e0effb03497750b684052f410f46f/diff",
                "MergedDir": "/var/lib/docker/overlay2/186f7933146e3cac0b58373d7e10b6b667f99e4f3c17fb150feeccd741151733/merged",
                "UpperDir": "/var/lib/docker/overlay2/186f7933146e3cac0b58373d7e10b6b667f99e4f3c17fb150feeccd741151733/diff",
                "WorkDir": "/var/lib/docker/overlay2/186f7933146e3cac0b58373d7e10b6b667f99e4f3c17fb150feeccd741151733/work"
            },
            "Name": "overlay2"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:764055ebc9a7a290b64d17cf9ea550f1099c202d83795aa967428ebdf335c9f7",
                "sha256:245c9d23f65373415922e53424032cabe7b282c5cf8f9f8070a7d1830fca6871",
                "sha256:ebef6caacb966ed54c0c3facf2288fa5124452f2c0a17faa1941625eab0ceb54",
                "sha256:0b7b774038f08ec329e4dd2c0be440c487cfb003a05fce87cd5d1497b602f2c1",
                "sha256:a71d36a87572d637aa446110faf8abb4ea74f028d0e0737f2ff2b983ef23abf3",
                "sha256:9e1fddfb3a22146392a2d6491e1af2f087da5e6551849a6174fa23051ef8a38f"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]
```

理解：

所有的docker镜像都起源于⼀个基础镜像层，当进⾏修改或增加新的内容时，就会在当前的镜像层上，创建新的镜像层。

举⼀个简单的例⼦，假如基于Ubuntu linux 16.04创建⼀个新的镜像，这就是镜像的第⼀层；如果在该镜像中添加python包，就会在基础镜像上创建第⼆个镜像层；如果继续添加⼀个安全补丁，就会创建第三个镜像层。

改镜像当前已经包含3个镜像层如下图所示![image-20210714213543892](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714213543892.png)

在添加额外镜像层的同时，镜像始终保持着当前所有镜像的组合，理解着⼀点⾮常重要，下图举了⼀个⾮常简单的例⼦，每个镜像层包含3个⽂件，⽽镜像包含了来⾃两个镜像层的6个⽂件![image-20210714213606764](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714213606764.png)

上⾯的镜像层和之前的略有区别，主要⽬的是便于展示⽂件。

下图站是了⼀个稍微复杂的三层镜像，在外部看来整个镜像只有6个⽂件，这是因为最上层的⽂件7是⽂件5的更新版![image-20210714213722276](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714213722276.png)

这种情况下，上层镜像的⽂件覆盖了底层镜像的⽂件，这样就使得⽂件的更新版本作为⼀个镜像层添加

到镜像中。

Docker通过存储引擎（新版本采⽤快照机制）的⽅式来实现镜像层的堆栈，并保证多镜像层对外展示为统⼀的⽂件系统。

Linux上可⽤的存储引擎有AUFS，Overlay2，Decvice Mapper，Btrfs以及ZFS。顾名思义，每种存储引擎都基于LInux中对应的⽂件系统或者快设备技术，并且每种存储引擎都有独有的性能特点。

Docker在winows仅⽀持windowsfilter⼀种存储引擎，改引擎基于NTFS⽂件系统之上实现了分层和cow[1]。

下⾯展示了与系统显示相同的三层镜像，所有镜像层堆叠并合并，对外提供统⼀的视图。

![image-20210714214019181](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714214019181.png)

---

> 特点

Docker镜像都是只读的，当容器启动时，⼀个新的可写层被加载到镜像的顶部！

这⼀层就是我们通常说的容器层，容器层之下就是镜像层！

![image-20210714214155274](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714214155274.png)

如何提交⼀个⾃⼰的镜像？

#### commit镜像

```shell
docker commit 提交容器成为⼀个新的副本
#命令和git类似
docker commit -m="提交的描述信息" -a="作者" 容器id ⽬标镜像名:[TAG]
```

实战测试：

```shell
# 1.启动⼀个默认的tomacat

# 2.发现这个默认的tomcat是没有webapps的，镜像的原因，官⽅的镜像默认的webapps下⾯是没有⽂件的

# 3.我⾃⼰拷⻉进去了⼀个基本⽂件

# 4.将我们操作过的容器通过commit提交为1个镜像！我们以后就使⽤我们修改过的镜像即可，这就是我们⾃⼰的⼀个镜像
```

![image-20210714215356632](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714215356632.png)

学习⽅式说明：理解概念，但是⼀定要实践，最后实践和理论相结合，⼀次搞定

```
如果你想要保存当前的容器状态，就可以通过commit提交 ，获得⼀个镜像
就好⽐vm的快照
```

**到这⾥才算是⼊⻔！**

## 容器数据卷

#### 什么是容器数据卷

**docker的理念回顾**

将应⽤和环境打包成⼀个镜像！

数据？如果数据在容器中，容器⼀旦删除，数据就会丢失！==需求：数据可以持久化==

MySQL，容器删了，删库跑路！ ==需求：Mysql的数据可以存储在本地或者其他地⽅==

容器之间可以有数据共享的技术 ！Docker容器中产⽣的数据，同步到本地 ！

这就是卷技术！⽬录的挂载，将我们容器内的⽬录，挂载到linux！

![image-20210714220047548](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714220047548.png)

**总结：容器的持久化和同步操作！容器间也是可以数据共享的！**

#### 使用数据卷

> 方式一：直接使⽤命令来挂载 -v

```shell
docker run -it -v 主机⽬录:容器⽬录 -P 主机端⼝:容器端⼝
[root@192 home]# docker run -it -v /home/ceshi:/home centos /bin/bash

# 启动后可以通过docker inspect 容器id
```

![image-20210714221454858](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714221454858.png)

测试文件的同步

![image-20210714221746512](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714221746512.png)

再来测试！

1. 停⽌容器

2. 在宿主机上修改⽂件

3. 再次启动容器

4. 发现容器内的⽂件修改同步

![image-20210714222337859](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714222337859.png)

好处：我们以后修改只需在本地修改即可，容器内会⾃动同步

#### 实战：安装Mysql

思考:mysql数据持久化问题 data

```shell
# 获取镜像
[root@localhost ~]# docker pull mysql:5.7

# 运⾏容器，需要做数据挂载！启动mysql，需要配置密码的，要注意
# 官⽅测试： docker run --name some-mysql-e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

# 启动我们的
-d 后台运⾏
-p 端⼝映射
-v 数据卷挂载
-e 环境配置
--name 容器名字

[root@192 home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=80231hdd --name mysql01 mysql:5.7

# 启动成功之后在本地使⽤navicat链接测试
# 本地的mysql -h -u -p 连接到服务器的3310，3310和容器内的3306 映射
mysql -h 192.168.80.1 -P 3310 -uroot -p80231hdd
```

假设我们将容器删除

发现，我们挂载到本地的数据卷 依旧没有丢失，这就实现了容器数据持久化功能

#### 具名挂载和匿名挂载

```shell
# 匿名挂载
-v 容器内路径
docker run -d -p --name ngnix01 -v /etc/ngnix

#查看所有的volume的情况
[root@192 home]# docker volume ls
DRIVER    VOLUME NAME
local     af873ca78a40cf6e44f4ef6fecd54b1ff94e4d977fff958b460af233cf17aca9
local     c639c329a03829240cdbb640770fcef4942bafb5130936042edea1ba5681d68d
# 这⾥发现，这种就是匿名挂载，我们在-v 的时只写了容器内的路径，没有写容器外的路径

# 具名挂载
[root@192 home]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx
d1f2cd8cf72210f6336fff4c817ca871de1efde6551db98c99757d042c61c6da
[root@192 home]# docker volume ls
DRIVER    VOLUME NAME
local     af873ca78a40cf6e44f4ef6fecd54b1ff94e4d977fff958b460af233cf17aca9
local     c639c329a03829240cdbb640770fcef4942bafb5130936042edea1ba5681d68d
local     juming-nginx

# 通过 -v 卷名:容器内路径
# 查看⼀下这个卷
[root@192 home]# docker volume inspect juming-nginx
[
    {
        "CreatedAt": "2021-07-14T10:45:40-04:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data",
        "Name": "juming-nginx",
        "Options": null,
        "Scope": "local"
    }
]
```

![image-20210714224731474](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714224731474.png)

所有docker容器内的卷，没有指定⽬录的情况下都是在 **/var/lib/docker/volumes/juming-nginx/_data**

我们通过具名挂载可以更⽅便的找到我们的卷，⼤多数情况使⽤**具名挂载**

```shell
# 如何确定是具名挂载还是匿名挂载
-v 容器内路径 				#匿名挂载
-v 卷名:容器内路径 			#具名挂载
-v /宿主机的路径:容器内路径 	#指定路径挂载
```

扩展：

```shell
# 通过-v 容器内路径:加上ro/rw改变读写权限
ro readonly		#只读
re readwrite	#可读可写

# ⼀旦设置了容器权限，容器对我们挂载出来的内容就有限定了
docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx:ro nginx
docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx:rw nginx

#ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是⽆法操作的
```

#### 初识DockerFile

DockerFile就是⽤来构建docker镜像的构建⽂件！命令脚本！

通过这个脚本可以⽣成⼀个镜像，镜像是⼀层⼀层的，脚本⼀个个的命令，每个命令都是⼀层

```shell
# 创建⼀个dockerfile的⽂件，名字可以随机 建议Dockerfile
[root@hecs-398933 etc]# cd /home
[root@hecs-398933 home]# mkdir docker-test-volume
[root@hecs-398933 home]# ls
ceshi  docker-test-volume
[root@hecs-398933 home]# cd docker-test-volume/
[root@hecs-398933 docker-test-volume]# vim dockerfile1
[root@hecs-398933 docker-test-volume]# cat dockerfile1
FROM centos
VOLUME ["volume01","volume02"]
CMD echo"---end----"
CMD /bin/bash


[root@192 docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t yangyang/centos .

# ⽂件中的内容 指令 参数
FROM centos
VOLUME ["volume01","volume02"]
CMD echo"---end----"
CMD /bin/bash

# 每个命令都是镜像的⼀层
```

![image-20210714230259893](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714230259893.png)

```shell
启动一个自己写的容器
```

![image-20210714230855726](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714230855726.png)

这个卷和外部有⼀个同步的⽬录

![image-20210714230945536](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714230945536.png)

查看卷挂载的路径

![image-20210714231110390](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714231110390.png)

假设构建镜像时没有挂载卷，要⼿动挂载镜像		 -v 卷名:容器内路径！

#### 数据卷容器

多个mysql同步数据

![image-20210715111736920](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715111736920.png)

```shell
docker run -it --name docker02 --volumes-from docker01 kuangshen/centos:1.0
```

![image-20210715113944119](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715113944119.png)

![image-20210715114111665](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715114111665.png)

```shell
# 测试，可以删除docker01，查看⼀下docker02和docker03是否可以访问这个⽂件
# 测试依旧可以访问
```

![image-20210715114355827](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715114355827.png)

多个mysql实现数据共享

```shell
[root@192 home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=80231hdd --name mysql01 mysql:5.7

[root@192 home]# docker run -d -p 3310:3306  -e MYSQL_ROOT_PASSWORD=80231hdd --name mysql02 --volumes-from mysql:5.7

# 这个时候可以实现两个容器同步
```

结论:

容器之间信息传递，数据卷容器的⽣命周期可以持续到没有容器使⽤为⽌

但是⼀旦持久化到了本地，知这时候本地的数据是不会删除的



## DockerFile

#### DockerFile的介绍

dockerfile是⽤来构建docker镜像的⽂件

构建步骤:

1. 编写⼀个 dockerfile ⽂件

2. `docker build` 构建⼀个镜像

3. `docker run` 运⾏镜像

4. `docker push` 发布镜像（dockerhub、 阿⾥云镜像仓库！）



> 查看⼀下官⽅
>
> ![image-20210715115244823](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715115244823.png)
>
> ![image-20210715115526064](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715115526064.png)
>
> 很多官⽅的镜像都是基础包，很多功能都没有，我么通常⾃⼰搭建⾃⼰的镜像
>
> 官方既然可以制作镜像我们也可以！

#### DockerFile构建过程

基础知识：

1. 每个保留关键字（指令）都是⼤写字⺟![image-20210715175956461](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715175956461.png)

2. 执⾏从上到下的顺序

3. #表示注释
4. 每个指令都会创建提交⼀个新的镜像层，并提交！

![image-20210715175846264](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715175846264.png)

DockerFIle是⾯向开发的，我们以后要发布项⽬，做镜像，就要编写dockefile，这个⽂件⼗分简单！

Docker镜像 逐渐成为了企业交付的标准，必须要掌握！

步骤：开发，部署，运维。。。缺⼀不可

Docker File：构建⽂件，定义了⼀切的步骤，源代码

Dockerimage：通过Docjerfile构建⽣成的镜像，最终运⾏的产品，原来是⼀个jar包，war包

Docker容器：镜像运⾏起来提供服务器

#### DockerFile指令

以前的话⽤别⼈的 ，现在我们知道这些指令后就创建⾃⼰的镜像

```shell
FROM 				# 基础镜像 centos ubuntu，⼀切从这⾥构建
MAINTAINER 			# 镜像是谁写的，姓名+邮箱
RUN 				# Docker镜像构建时需要运⾏的命令
ADD 				# 步骤， tomacat镜像，这个tomcat压缩包（添加内容）
WORKDIR				 # 镜像的⼯作目录 /bin/bash
VOLUME 			# 挂载的⽬录
EXPOSE 			# 暴露端⼝，保留端⼝配置
CMD 			# 指定这个容器的时候要运⾏的命令 cmd echo，只有最后⼀个会⽣效，可被替代
ENTRYPOINT 		# 指定这个容器的时候要运⾏的命令 ，可以追加命令
ONBUILD 		# 当构建⼀个被继承的DockerFile 这个时候就会运⾏ONBUILD的指令..触发指令
COPY 			# 类似ADD命令 ，将我们的⽂件拷⻉到镜像中
ENV 			# 构建的时候设置环境变量
```

![image-20210715175956461](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715175956461.png)



#### 实战测试

DockerHub中99%的镜像都是从这个基础镜像过来的`FROM scratch`，然后配置需要的软件和配置来进⾏的构建的

![image-20210715182140694](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715182140694.png)



> 创建⼀个⾃⼰的centos

```shell
# 1、编写DockerFile的文件
[root@hecs-398933 dockerfile]# vim mydockerfile-centos
[root@hecs-398933 dockerfile]# cat mydockerfile-centos 
FROM centos
MAINTAINER yangyang<2985409357@qq.com>
ENV MYPATH /usr/local
WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-tools
EXPOSE 80

CMD echo $MYPATH
CMD echo"--end----"
CMD /bin/bash
# 2、通过这个文件构建镜像
[root@hecs-398933 dockerfile]# docker build -f mydockerfile-centos -t mycentos:1.0 .
Successfully built 05720b3305d4
Successfully tagged mycentos:1.0

# 3、测试运行
[root@hecs-398933 dockerfile]# docker run -it mycentos:1.0
[root@ad9b8b00f1e4 local]# pwd
/usr/local
[root@ad9b8b00f1e4 local]# ifconfig
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
        RX packets 8  bytes 656 (656.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

[root@ad9b8b00f1e4 local]# vim test
```

原来的：原生centos![image-20210715183659407](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715183659407.png)

现在的：我们增加之后的镜像![image-20210715183722409](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715183722409.png)

我们可以列出本地镜像的变更历史,

```shell
[root@hecs-398933 dockerfile]# docker history  05720b3305d4
IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT
05720b3305d4   5 minutes ago   /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "/bin…   0B        
6ac7ca029143   5 minutes ago   /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B        
b57b3fb3cce0   5 minutes ago   /bin/sh -c #(nop)  CMD ["/bin/sh" "-c" "echo…   0B        
f719aadee667   5 minutes ago   /bin/sh -c #(nop)  EXPOSE 80                    0B        
dd5f52fd2573   5 minutes ago   /bin/sh -c yum -y install net-tools             121MB     
0a0bdb0cb1cb   5 minutes ago   /bin/sh -c yum -y install vim                   176MB     
9b8cfa6b86f6   7 minutes ago   /bin/sh -c #(nop) WORKDIR /usr/local            0B        
d66e9ed3f2c4   7 minutes ago   /bin/sh -c #(nop)  ENV MYPATH=/usr/local        0B        
bd951f8f8aab   7 minutes ago   /bin/sh -c #(nop)  MAINTAINER yangyang<29854…   0B        
75835a67d134   2 years ago     /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B        
<missing>      2 years ago     /bin/sh -c #(nop)  LABEL org.label-schema.sc…   0B        
<missing>      2 years ago     /bin/sh -c #(nop) ADD file:fbe9badfd2790f074…   200MB    
```

![image-20210715184007536](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715184007536.png)

从这我拿到⼀个docker就知道他是怎么做的了

---

> CMD 和 ENTRYPOINT的区别

```shell
CMD 		# 指定这个容器的时候要运⾏的命令 cmd echo，只有最后⼀个会⽣效，可被替代
ENTRYPOINT 	# 指定这个容器的时候要运⾏的命令 ，可以追加命令
```

测试cmd

```shell
# 编写dockerfile⽂件
[root@localhost dockerfile]# vim dockerfile-cmd-test 
FROM centos
CMD ["ls","-a"]


# 构建镜像
[root@localhost dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .

# run运⾏，发现我们的ls -a命令⽣效了
[root@localhost dockerfile]# docker run cmdtest
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

# 想追加命令-l
[root@hecs-398933 dockerfile]# docker run a1c658d03140 -l
docker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: "-l": executable file not found in $PATH: unknown.

# cmd情况下 -l替换了CMD["ls","-a"]命令，-l不是命令所以报错
```

测试ENTRYPOINT

```shell
# 编写dockerfile⽂件
[root@localhost dockerfile]# vim dockerfile-entrypoint-test
FROM centos
ENTRYPOINT ["ls","-a"]
# 构建
[root@localhost dockerfile]# docker build -f dockerfile-entrypoint-test -t entrypoint-test .
Sending build context to Docker daemon 16.9kB
Step 1/2 : FROM centos
---> 300e315adb2f
Step 2/2 : ENTRYPOINT ["ls","-a"]
---> Using cache
---> 2dbbec8e487f
Successfully built 2dbbec8e487f
Successfully tagged entrypoint-test:latest
# 运行测试
[root@localhost dockerfile]# docker run 2dbbec8e487f
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

# 我们的命令是直接拼接到后⾯的
[root@localhost dockerfile]# docker run 2dbbec8e487f -l
total 56
drwxr-xr-x. 1 root root 6 Apr 7 13:19 .
drwxr-xr-x. 1 root root 6 Apr 7 13:19 ..
-rwxr-xr-x. 1 root root 0 Apr 7 13:19 .dockerenv
lrwxrwxrwx. 1 root root 7 Nov 3 15:22 bin -> usr/bin
drwxr-xr-x. 5 root root 340 Apr 7 13:19 dev
drwxr-xr-x. 1 root root 66 Apr 7 13:19 etc
drwxr-xr-x. 2 root root 6 Nov 3 15:22 home
lrwxrwxrwx. 1 root root 7 Nov 3 15:22 lib -> usr/lib
lrwxrwxrwx. 1 root root 9 Nov 3 15:22 lib64 -> usr/lib64
drwx------. 2 root root 6 Dec 4 17:37 lost+found
drwxr-xr-x. 2 root root 6 Nov 3 15:22 media
drwxr-xr-x. 2 root root 6 Nov 3 15:22 mnt
drwxr-xr-x. 2 root root 6 Nov 3 15:22 opt
dr-xr-xr-x. 284 root root 0 Apr 7 13:19 proc
dr-xr-x---. 2 root root 162 Dec 4 17:37 root
drwxr-xr-x. 11 root root 163 Dec 4 17:37 run
lrwxrwxrwx. 1 root root 8 Nov 3 15:22 sbin -> usr/sbin
drwxr-xr-x. 2 root root 6 Nov 3 15:22 srv
dr-xr-xr-x. 13 root root 0 Apr 7 08:01 sys
```

DockerFile中很多命令都⼗分相似，我们都需要了解他们的区别，最好是进⾏测试



#### 实战：Tomcat镜像

1. 准备tomacat镜像压缩包，jdk压缩包！

   ![image-20210715190821915](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715190821915.png)

2. 编写dockerfile⽂件，官⽅命名`Dockerfile`，build时会⾃动寻找这个⽂件，不需要-f指定了

   ![image-20210715191554402](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715191554402.png)

3. 构建镜像

   `# docker build -t diy:1.0 .` 

4. 启动镜像
5. ![image-20210715192631092](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715192631092.png)

5. 访问测试

6. 发布项⽬（由于做了卷挂载，我们直接在本地编写项⽬，就可以发布了）

   ![image-20210715192215757](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715192215757.png)

我们以后开发的步骤:需要掌握Dokcerfile的编写! 我们之后的一切都是使用docker镜像来发布运行!

#### 发布自己的镜像

> Dckerhub

1. 地址https://registry.hub.docker.com 注册⾃⼰的账号

2. 确定账号可以登陆

3. 在我们的服务器上提交⾃⼰的镜像

   ```shell
   [root@localhost dockerfile]# docker login --help
   
   Usage: docker login [OPTIONS] [SERVER]
   
   Log in to a Docker registry.
   If no server is specified, the default is defined by the daemon.
   
   Options:
    -p, --password string 		Password
    	 --password-stdin 		Take the password from stdin
    -u, --username string 		Username
    
    [root@hecs-398933 tomcat]# docker login -u yangyanglinux
   Password: 
   WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
   Configure a credential helper to remove this warning. See
   https://docs.docker.com/engine/reference/commandline/login/#credentials-store
   
   Login Succeeded
   ```

   4. 登陆完毕后就可以提交⾃⼰的镜像了，就是⼀步push

      [https://blog.csdn.net/yanpenglei/article/details/78948537](https://blog.csdn.net/yanpenglei/article/details/78948537)

      ![image-20210715195224848](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715195224848.png)

提交的时候也是按照层级来进⾏提交

---

> 发布阿⾥云镜像服务(可以参考官方网址)

1. 登陆阿⾥云

2. 找到容器镜像服务

3. 创建命名空间

4. 创建容器镜像

5. 浏览阿⾥云信息

#### 小结

![image-20210715195714493](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715195714493.png)



## Docker网络

#### 理解Docker0网络

![image-20210715200340725](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715200340725.png)

三个网络

```shell
# docker是如何处理容器⽹络访问的
```

![image-20210715200607974](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715200607974.png)

```shell
[root@hecs-398933 /]# docker run -d -P --name tomcat01 tomcat

# 查看容器内部网路地址	ip addr   发现容器启动的时候会得到eth0@if35这样的IP地址，docker分配的
[root@hecs-398933 /]# docker exec -it tomcat01 ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
36: eth0@if37: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever

#思考 linux服务器能不能ping通
[root@localhost dockerfile]# ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.106 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.062 ms
64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.081 ms
64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.067 ms
```



> 原理：

 1. 我们每启动⼀个docker容器，docker就会给docker容器分配个ip，我们只要安装了docker，就会有⼀个⽹卡docker0，桥接模式，使⽤的技术是evth-pair技术

    ==再次测试==

    ![image-20210715201150996](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715201150996.png)

2. 再启动⼀个容器,发现⼜多了⼀对⽹卡

   ![image-20210715201414446](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715201414446.png)

```shell
# 我们发现这些容器带来的技术都是⼀对⼀对的
# evth-pair 就是⼀对的虚拟设备接⼝，他们都是成对的，⼀段连着协议，⼀段彼此相连
# 正因为有这个特性，通常⽤evth-pair技术充当⼀个桥梁，连接各种虚拟设备
# openstack，DOcker容器之间的连接，OVS的连接，都是使⽤evth-pair的技术
```

3. 我们来测试tomcat01和tomcat02之间是否能ping通

   ```shell
   [root@hecs-398933 ~]# docker exec -it tomcat01 ping 172.17.0.3
   PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.
   64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.076 ms
   64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.053 ms
   64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.052 ms
   64 bytes from 172.17.0.3: icmp_seq=4 ttl=64 time=0.052 ms
   64 bytes from 172.17.0.3: icmp_seq=5 ttl=64 time=0.050 ms
   64 bytes from 172.17.0.3: icmp_seq=6 ttl=64 time=0.034 ms
   
   # 结论容器之间是可以互相ping通的
   ```

   网络图：

   ![image-20210715202422055](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715202422055.png)

结论：tomcat01和tomcat02是公⽤的1个交换机，docker0

所有容器不指定⽹络的情况下，都是docker0路由的，docker会给我们的容器分配⼀个默认的可⽤ip

---

> ⼩结

Docker使⽤的是linux的桥接，宿主机中是⼀个Docker容器的⽹桥 docker0

![image-20210715202742074](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715202742074.png)

Docker中的所有的⽹络接⼝都是虚拟的，虚拟的转发效率⾼！（内⽹传递⽂件！）

只要容器删除，对应的⽹桥就没了

![image-20210715203814080](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715203814080.png)



#### --link

> 思考：我们编写了⼀个微服务 database url=ip，项⽬不重启，数据库ip换了，我们希望可以通过名字访问服务

```shell
[root@localhost dockerfile]# docker exec -it tomcat02 ping tomcat01
ping: tomcat01: Name or service not known

#如何解决呢
[root@localhost dockerfile]# docker exec -it tomcat02 ping tomcat01
ping: tomcat01: Name or service not known
# 通过--link就可以解决了
docker run -it --name tomcat03 --link tomcat02 tomcat
[root@localhost dockerfile]# docker exec -it tomcat03 ping tomcat02
PING tomcat02 (172.17.0.3) 56(84) bytes of data.
64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.131 ms
64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.135 ms
64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.120 ms
ç64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.091 ms
^C
--- tomcat02 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 68ms
rtt min/avg/max/mdev = 0.091/0.119/0.135/0.018 m

# 反向可以ping通嘛？不可以
```

探究inspect

![image-20210715204038053](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715204038053.png)

其实tomacat03就是在本地配置了tomcat02？

![image-20210715204115550](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715204115550.png)

```shell
# 查看hosts配置
[root@localhost dockerfile]# docker exec -it tomcat03 cat /etc/hosts
127.0.0.1 localhost
::1 localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.17.0.3 tomcat02 2110f95268bc
172.17.0.4 896c41fa1fd8
```

--link在hosts中增加了

⾃定义⽹络！不适用docker0

docker0的问题：不⽀持容器名访问

#### 自定义网络



>查看所有的docker⽹络

![image-20210715204341438](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715204341438.png)

**⽹络模式**

bridge：桥接模式 docker（默认）⾃⼰创建

none：不配置⽹络

host：主机模式，和宿主机共享⽹络

**测试**

```shell
# 我们直接启动的命令 --net bridge，⽽这个就是我们的docker0
docker run -d -p --name tomcat01 tomcat
docker run -d -p --name tomcat01 --net bridge tomcat

#docker0特点：默认的，域名不能访问， --link可以打通连接

#⾃定义⼀个⽹络
# --driver bridge
# --subnet 192.168.0.0/16
# --gatway 192.168.0.1/16

[root@localhost dockerfile]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
e727a0331cbda99de11c1e2cf6b2937f57cbe0a3f66c9ce8633119c832d33844
[root@localhost dockerfile]# docker network ls
NETWORK ID NAME DRIVER SCOPE
3200030a164b bridge bridge local
8983ea6cf3a0 host host local
e727a0331cbd mynet bridge local
```

![image-20210715204650974](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715204650974.png)

```shell
"ConfigOnly": false,
 "Containers": {
 "84823d554f25e0c981c235cdba256de5a83b636671fb65561516258e1f1e3280": {
 "Name": "tomcat-net-01",
 "EndpointID":
"c8c2d2839c94aee4ffeef6ce3e79e04ced247f08f8591227e1a9578285887cea",
 "MacAddress": "02:42:c0:a8:00:02",
 "IPv4Address": "192.168.0.2/16",
 "IPv6Address": ""
 },
 "95ae06c0919d7b3114cde99d5e24282920e40a995574dd578071d9684d889cd2": {
 "Name": "tomcat-net-02",
 "EndpointID":
"e327e7d8f65e433e03756c54a136c1b5f3f6a97a1d862d9abd8dcb006aa18ded",
 "MacAddress": "02:42:c0:a8:00:03",
 "IPv4Address": "192.168.0.3/16",
 "IPv6Address": ""
 }
 },
 "Options": {},
 "Labels": {}
 }
 ]
 
 #再次测试ping连接，现在不使⽤---link也可以ping名字
[root@localhost dockerfile]# docker exec -it tomcat-net-01 ping tomcat-net-02
PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.304ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.130ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.130ms
^C
--- tomcat-net-02 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 8ms
rtt min/avg/max/mdev = 0.130/0.188/0.304/0.082 ms
```

我们⾃定义的⽹络docker都已经维护好了对应关系，推荐平时这么使用网络

好处：

redis：不同的集群使⽤不同的⽹络，保证集群最安全

![image-20210715205007782](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715205007782.png)

#### 网络连通

![image-20210715205101677](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715205101677.png)

![image-20210716111319697](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210716111319697.png)

```shell
# 测试打通tomcat01到mynet
[root@localhost ~]# docker network connect mynet 65b63f9e8fc5

# 连通之后，就是讲tomcat01放到mynet⽹络下（⼀个容器两个ip） 
# 阿⾥云服务器 ⼀个公⽹ip ⼀个私⽹ip
```

![image-20210715205317681](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210715205317681.png)

```shell
# tomcat01能够连通
[root@localhost ~]# docker exec tpmcat01 ping tomcat-net-01
PING tomcat-net-01 (192.168.0.4) 56(84) bytes of data.
64 bytes from tomcat-net-01.mynet (192.168.0.4): icmp_seq=1 ttl=64 time=0.145ms
64 bytes from tomcat-net-01.mynet (192.168.0.4): icmp_seq=2 ttl=64 time=0.079ms
64 bytes from tomcat-net-01.mynet (192.168.0.4): icmp_seq=3 ttl=64 time=0.132ms
```

假设要跨⽹络操作别⼈，就需要docker network connect 连通！！

#### redis集群部署

![image-20210716111551915](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210716111551915.png)

```shell
# 创建⽹卡
docker network create redis --subnet 172.38.0.0/16

# 部署6个redis集群的脚本
for port in $(seq 1 6); \
> do \
> mkdir -p /mydata/redis/node-${port}/conf
> touch /mydata/redis/node-${port}/conf/redis.conf
> cat << EOF >/mydata/redis/node-${port}/conf/redis.conf
> port 6379
> bind 0.0.0.0
> cluster-enabled yes
> cluster-config-file nodes.conf
> cluster-node-timeout 5000
> cluster-announce-ip 172.38.0.1${port}
> cluster-announce-port 6379
> cluster-announce-bus-port 16379
> appendonly yes
> EOF
> done

docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \
-v /mydata/redis/node-${port}/data:/data \
-v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis -ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-serve /etc/redis/redis.conf;\

docker run -p 6371:6379 -p 16371:16379 --name redis-1\
-v /mydata/redis/node-1/data:/data \
-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis -ip 172.38.0.11 redis:5.0.9 redis-serve /etc/redis/redis.conf
```

## SpringBoot微服务打包成Docker镜像

1. 构建springboot项目
2. 打包应用
3. 编写dockerfile
4. 构建镜像
5. 发布运行



以后我们使用了Dokcer之后,给别人交付的就是一个 镜像即可!



到了这里已经完全够用



预告:如果有很多镜像，??  100个镜像?
