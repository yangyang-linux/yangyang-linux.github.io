---
layout:     post
title:      Docker
subtitle:   Docker学习
date:       2021-7-12
author:     YY——阳阳
header-img: img/post/1.jpg
catalog: true
tags:
    - Docker
---



## Docker

>  docker学习
>
>  - DOCKER概述;
>
>  - DOCKER安装
>
>  - DOCKER命令
>
>    - 镜像命令
>
>    - 容器命令
>
>    - 操作命令
>
>    - 。。。
>
>
>
>  - Docker镜像
>  - 容器的数据卷
>   - DockerFile
>   - Docker⽹络原理
>   - IDEA整合DOCKER
>   - Docker Compose
>   - Docker Swarm
>   - CI\CD jenkins

## Docker概述

#### Docker为什么会出现？

⼀款产品，开发-----上线，两套环境！应⽤环境！应⽤配置！

开发-------运维。 问题：我在我的电脑上可以使⽤！版本更新，导致服务不可⽤！对于运维来说考验⼗分⼤！

开发即运维！！！

环境配置⼗分麻烦，每⼀个机器都要配置环境（集群Redis、ES、Hadoop。。。）！！费时费⼒！！

发布⼀个项⽬jar+(REdis Mysql jdk ES)，项⽬带上环境安装打包！！

之前在服务器配置⼀个应⽤的环境（REdis Mysql jdk ES Hadoop）,配置超麻烦，不能够跨平台！！

windows，连最后发布到linux

传统：开发jar打包， 运维来做

现在：开发打包部署上线，⼀套流程做完

*java------apk-----发布(应⽤商店)----张三使⽤apk--------安装即可⽤*

*java------jar(环境)-------打包项⽬带环境(镜像！)--------Docker仓库：商店-----------下载我么发布的镜像直接运⾏即可*



**Docker对于以上问题产⽣了⼀个解决⽅案**

![image-20210712171654650](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712171654650.png)

docker思想来⾃⼀个集装箱

JRE ----多个应⽤（端⼝冲突）--------因为原来都是交叉的

隔离：Docker核⼼思想！打包装箱！每个箱⼦都是互相隔离的

**⽔果 -----⽣化武器**

Docker通过隔离机制，可以将服务器利⽤到极致

本质：所有的技术都是因为出现⼀些问题才会出现的；

#### Docker历史

2010 ，⼏个搞IT的年轻⼈，在美国成⽴了⼀家公司`dotcloud`,做⼀些pass的云计算服务,LXC(linux虚拟机)有关的容器技术

他们将⾃⼰的**容器化技术**命名就是Docker！

刚诞⽣的时候，没有引起⾏业的注意！！dotcloub，就活不下去！！

开源

2013年，Docker开源；

Docker越来越多的⼈发现了Docker的优点，每个⽉都会更新

2014年4⽉9⽇，Docker1.0发布

Docker这么⽕的原因？它相对虚拟机⼗分轻巧

在容器技术出现之前，我们都是使⽤虚拟机

虚拟机运⾏：在windows或者mac中安装⼀个虚拟机软件vmware，可以虚拟⼀台或多台电脑！占⽤内

存太⼤！笨重！

虚拟机也是属于虚拟化技术，Docker容器技术，也是⼀种虚拟化技术！

```shell
vm:linux centos(原⽣镜像)，隔离，就需要开启多个虚拟机 ！⼏个G 启动需要⼏分钟
Docker:隔离，镜像(最核⼼的环境 4m+jdk+mysql)⼗分的⼩巧，运⾏镜像就可以了！⼩巧！⼏M 、KB 秒级启动
```

到现在所有开发⼈员必须会

> 聊聊Docker

Docker是基于GO语⾔开发的 ！开源项⽬

官⽹：[https://www.docker.com](https://www.docker.com)

![image-20210712172619964](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712172619964.png)

⽂档地址：https://docs.docker.com Docker的⽂档超级详细的！

仓库地址：https://registry.hub.docker.com

#### Docker能干嘛？

>  之前的虚拟机技术

![image-20210712172740157](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712172740157.png)

**虚拟机技术的缺点：**

1.  占⽤资源⼗分多

2. 冗余步骤⼗分多

3. 启动很慢

---

> 容器化技术

**容器化技术不是模拟的完整的操作系统**

![image-20210712172853472](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712172853472.png)

**⽐较Docker和虚拟机技术的不同：**

- 传统虚拟机，虚拟出⼀个硬件 ，运⾏⼀个完整的操作系统，然后在这个系统上安装和运⾏软件
- 容器的应⽤直接运⾏在宿主机的内容，容器是没有⾃⼰的内核，也没有虚拟我们的硬件，所以就轻便了
- 每个容器件恶事互相隔离的，每个容器内都有⼀个属于⾃⼰的⽂件系统

---

> DebOps(开发，运维)

**更快速的交付和部署**

传统：⼀堆的帮助⽂档，安装程序

Docker：打包镜像，发布测试，⼀键运⾏

**更便捷的升级和扩缩容**

使⽤Docker之后，我们部署应⽤就和搭积⽊⼀样

项⽬打包为⼀个镜像，扩展 服务器A! 服务器B

**更简单的系统运维**

在容器化之后，我们的开发或测试环境,都是⾼度⼀致的

**更⾼效的计算机资源利⽤**

Docker 是内核级别的虚拟化 ，可以在物理机上运⾏很多的容器实例！服务器的性能可以被压榨到极致

## Docker安装

#### Docker基本组成

![image-20210712173500883](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712173500883.png)

**镜像(image)：**

docker镜像就好⽐是⼀个模版，可以通过这个模版来创建⼀个容器服务，tomcat===>run(运⾏起

来)===>tomcat01容器(提供服务)，通过这个镜像可以创建多个容器(最终服务器运⾏，或者项⽬运⾏

就是在容器中的)

**容器（container）：**

Docker利⽤容器技术，独⽴运⾏⼀个或者⼀组应⽤，通过镜像创建的

启动，停⽌，删除，基本命令！

⽬前就可以把容器理解为简易的linux系统

**仓库（repository）：**

存放镜像的地⽅！

仓库分为公有仓库和私有仓库：

Docker Hub（默认是国外的）

阿⾥云。。。。都有容器服务（配置镜像加速）

#### 安装Docker

> 环境准备

1. 需要会⼀点点linux基础

2. Centos

3. 使⽤xshell连接远程服务器操作

> 环境查看

```bash
# 系统内核是3.10以上的
[root@localhost ~]# uname -r
4.18.0-240.el8.x86_64
[root@localhost ~]# uname -r
4.18.0-240.el8.x86_64
# 系统版本
[root@localhost ~]# cat /etc/os-release
NAME="CentOS Linux"
VERSION="8"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="8"
PLATFORM_ID="platform:el8"
PRETTY_NAME="CentOS Linux 8"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:8"
HOME_URL="https://centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"
CENTOS_MANTISBT_PROJECT="CentOS-8"
CENTOS_MANTISBT_PROJECT_VERSION="8"
```

> 安装

帮助⽂档：

```shell
# 1.卸载旧的版本
sudo yum remove docker \
 docker-client \
 docker-client-latest \
 docker-common \
 docker-latest \
 docker-latest-logrotate \
 docker-logrotate \
 docker-engine
# 2.需要的安装包
yum install -y yum-utils
# 3.设置镜像的仓库
yum-config-manager \
 --add-repo \
 https://download.docker.com/linux/centos/docker-ce.repo #默认是从国外的！
 
yum-config-manager \
 --add-repo \
 http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #推荐使⽤阿⾥
云
 
# 更新yum软件包索引：
[root@localhost ~]# yum makecache 
# 4.安装Docker相关的内容 docker-ce 社区 ee 企业版
yum install docker-ce docker-ce-cli containerd.io
# 5.启动Docker
systemctl start docker
# 6.使⽤docker version查看是否安装成功
```

![image-20210712191827122](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712191827122.png)

```shell
# 7.使⽤hello world
docker run hello-world
```

![image-20210712192155254](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712192155254.png)

```shell
# 8.查看下载的hello-world镜像
[root@localhost ~]# docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
hello-world latest d1165f221234 4 weeks ago 13.3kB
```

了解：卸载docker

```shell
# 1.卸载依赖
yum remove docker-ce docker-ce-cli containerd.io
# 2.删除资源
rm -rf /var/lib/docker
rm -rf /var/lib/containerd
# /var/lib/docker docker的默认⼯作路径
```

#### 阿里云镜像加速

1. 登陆阿⾥云找到容器服务
2. 找到镜像加速地址

![image-20210712192946448](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712192946448.png)

3. 配置使⽤

```shell
sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://s82h6lek.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
```

#### 回顾helloworld

![image-20210712192155254](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712192155254.png)

![image-20210712193406226](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712193406226.png)

#### 底层原理

**Docker是怎么工作的？**

Docker是⼀个Client-Server结构的系统，Docker的守护进程运⾏在主机上，通过Socket从客户端访问！

Docker-server接收到Docker-Client的指令，就会执⾏！

![image-20210712193654803](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712193654803.png)

---

**Docker为什么⽐vm快？**

1. Docker有着⽐虚拟机更少的⽹络进程

2. Docker利⽤的是宿主机的内核，vm需要的是GuestOS；

![image-20210712193741064](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712193741064.png)

所以说，新建⼀个容器的时候，docker不需要像虚拟机⼀样重新加载⼀个操作系统内核，避免引导

型操作，虚拟机加载GuestOS，分钟级别的 ，Docker是利⽤宿主机的操作系统，省略了复杂的过

程，秒级！

![image-20210712201902495](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712201902495.png)

![image-20210712201939952](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210712201939952.png)

## Docker常用命令

#### 帮助命令

```shell
docker version # 显示docker的版本信息
docker info # 显示docker的系统信息，包括镜像和容器的数量
docker 命令 --help # 万能命令帮助
```

帮助⽂档地址：https://docs.docker.com/reference/

#### 镜像命令

**docker images 查看本地所有镜像**

```shell
[root@localhost ~]# docker images
REPOSITORY TAG IMAGE ID CREATED SIZE
hello-world latest d1165f221234 4 weeks ago 13.3kB

#解释
REPOSITORY 	镜像的仓库源
TAG 		镜像的标签
IMAGE ID 	镜像的ID
CREATED 	镜像的创建时间
SIZE 		镜像的⼤⼩

#可选项
Options:
 -a, --all 		#列出所有镜像
 -q, --quiet 	#只显示镜像的ID
```

---

**docker search 搜索镜像**

```shell
[root@192 roo]# docker search mysql

NAME     DESCRIPTION      								STARS     OFFICIAL   AUTOMATED
mysql    MySQL is a widely used, open-source relation…   11120     [OK]       
mariadb  MariaDB Server is a high performing open sou…   4216      [OK]       

#可选项，通过收藏过滤
--filter=STARS=3000 #搜索出来的镜像就是STARS⼤于3000的
[root@192 roo]# docker search mysql --filter=STARS=3000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   11120     [OK]       
mariadb   MariaDB Server is a high performing open sou…   4216      [OK]       
[root@192 roo]# docker search mysql --filter=STARS=5000
NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql     MySQL is a widely used, open-source relation…   11120     [OK]      
```

---

**docker pull 下载镜像**

```shell
#下载镜像 docker pull 镜像名[:tag版本]
[root@localhost ~]# docker pull mysql
Using default tag: latest #如果不写tag 默认就是latest
latest: Pulling from library/mysql
a076a628af6f: Pull complete #分层下载，docker image的核⼼ 联合⽂件系统
f6c208f3f991: Pull complete 
88a9455a9165: Pull complete
406c9b8427c6: Pull complete
7c88599c0b25: Pull complete
25b5c6debdaf: Pull complete
43a5816f1617: Pull complete
1a8c919e89bf: Pull complete
9f3cf4bd1a07: Pull complete
80539cea118d: Pull complete
201b3cad54ce: Pull complete
944ba37e1c06: Pull complete
Digest: sha256:feada149cb8ff54eade1336da7c1d080c4a1c7ed82b5e320efb5beebed85ae8c
#签名(防伪)
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest #真实地址

#等价
docker pull mysql
docker rmi 删除镜像！
容器命令：
说明：有了镜像才可以创建容器，linux，下载⼀个centos镜像来测试学习
新建容器并启动
docker pull docker.io/library/mysql:latest

#指定版本下载
[root@localhost ~]# docker pull mysql:5.7
5.7: Pulling from library/mysql
a076a628af6f: Already exists
f6c208f3f991: Already exists
88a9455a9165: Already exists
406c9b8427c6: Already exists
7c88599c0b25: Already exists
25b5c6debdaf: Already exists
43a5816f1617: Already exists
1831ac1245f4: Pull complete
37677b8c1f79: Pull complete
27e4ac3b0f6e: Pull complete
7227baa8c445: Pull complete
Digest: sha256:b3d1eff023f698cd433695c9506171f0d08a8f92a0c8063c1a4d9db9a55808df
Status: Downloaded newer image for mysql:5.7
docker.io/library/mysql:5.7
```

![image-20210714092609060](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714092609060.png)

**docker rmi 删除镜像！**

```shell
[root@localhost ~]# docker rmi -f 镜像id #删除指定的镜像
[root@localhost ~]# docker rmi -f 镜像id 镜像id 镜像id #删除多个镜像
[root@localhost ~]# docker rmi -f $(docker images -aq) #删除全部的镜像
```



#### Docker容器命令

**说明：有了镜像才可以创建容器，linux，下载⼀个centos镜像来测试学习**

```shell
docker pull centos
```

**新建容器并启动**

```shell
docker run [可选参数] images

#参数说明
--name=="Name" 	容器名字 tomcat01 tomacat02，⽤来区分容器
-d 				后台⽅式运⾏
-it 			使⽤交互⽅式运⾏，进⼊容器查看内容
-p 				指定容器的端⼝ -p 8080:8080
				# -p ip:主机端⼝:容器端⼝ (常⽤) 
				# -p 主机端⼝:容器端⼝ (常⽤) 
				# -p 容器端⼝
-P 				随机指定端⼝ 


#测试，启动并进⼊容器
[root@localhost ~]# docker run -it centos /bin/bash
[root@80138667de4f /]#
[root@80138667de4f /]# ls #查看容器内的centos，基础版本，很多命令都是不完善的
bin dev etc home lib lib64 lost+found media mnt opt proc root run 
sbin srv sys tmp usr var

#从容器中退回到主机
[root@80138667de4f /]# exit
exit
[root@localhost ~]# ls
anaconda-ks.cfg Desktop Documents Downloads initial-setup-ks.cfg Music 
Pictures Public Templates Videos
```

---

**列出当前正在运⾏的容器**

```shell
#docker ps 命令
		#显示正在运⾏的容器
-a 		# 列出当前正在运⾏的容器+带出历史运⾏过的容器
-n=? 	#显示最近创作的容器
-q 		# 只显示容器的编号

#docker ps -a
		#显示曾经所有运行过的容器

[root@192 roo]# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
[root@192 roo]# docker ps -a
CONTAINER ID   IMAGE         COMMAND       CREATED              STATUS                        PORTS     NAMES
fce1a8d0bfaa   centos        "/bin/bash"   About a minute ago   Exited (127) 28 seconds ago             jolly_ritchie
b81764395c1b   hello-world   "/hello"      6 minutes ago        Exited (0) 6 minutes ago                crazy_sanderson
a2e6649d6749   hello-world   "/hello"      16 minutes ago       Exited (0) 16 minutes ago               wonderful_noether
6db1aa868ed6   hello-world   "/hello"      15 hours ago         Exited (0) 15 hours ago                 loving_torvalds
2a30c9d2e991   hello-world   "/hello"      38 hours ago         Exited (0) 38 hours ago                 hardcore_mahavira
328fd8adb1e7   hello-world   "/hello"      38 hours ago         Exited (0) 38 hours ago                 practical_banzai

```

---

**退出容器**

```shell
exit 			#直接容器停⽌并退出
ctrl + P + Q 	#容器不停⽌退出
```

**删除容器**

```shell
docker rm 容器id 							#删除指定的容器,不能删除正在运⾏的容器,如果要强制删除，rm -f
docker rm -f $(docker ps -aq) 			#删除所有的容器
docker ps -a -q| xargs docker rm 		#删除所有的容器
```

**启动和停⽌容器的操作**

```shell
docker start 容器id 		#启动容器
docker restart 容器id 	#重启容器
docker stop 容器id 		#停⽌当前正在运⾏的容器
docker kill 容器id 		#强制停⽌当前容器
```

#### 常⽤的其他命令:

**后台启动容器**

```shell
# 命令 docker run -d 镜像名
[root@localhost ~]# docker run -d centos

# docker ps 发现 centos停⽌了

# 常⻅的坑，docker容器使⽤后台运⾏就必须要有⼀个前台进程,docker发现没有应用，就会自动停止
# nginx，容器启动后，发现⾃⼰没有提供服务，就会⽴刻停⽌，就是没有程序了
```

---

**查看日志**

```shell
docker logs --help
docker logs -f -t -tail 容器id 	#没有⽇志

# ⾃⼰编写⼀段shell脚本
“while true; do echo LGQ ;sleep 2;done”
[root@localhost ~]# docker run -d centos /bin/sh -c "while true; do echo yangyang;sleep 1;done"
d303f1869bfb684c0d083ea61a56e00680b0787be5bcd2cb38af24c34f6c2ba2
[root@localhost ~]# docker ps
CONTAINER ID IMAGE COMMAND 					CREATED STATUS  PORTS 					NAMES
d303f1869bfb centos "/bin/sh -c 'while t…" 10 seconds ago 	Up 4 seconds	goofy_shannon
2338d4c660bb centos "/bin/bash" 			12 minutes ago 	Up 12 minutes gifted_merkle

# 显示⽇志
-tf				#显示日志
--tail number 	#要显示的⽇志条数
-n number 		#要显示的⽇志条数
[root@localhost ~]# docker logs -tf --tail 10 d303f1869bfb
```

---

**查看容器中的进程信息**

```shell
# 命令 docker top 容器id
[root@192 roo]# docker top 0bb23343e3dc
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                7816                7797                1                   22:10               ?                   00:00:00            /bin/sh -c while true;do echo yangyang;sleep 1;done
root                7905                7816                0                   22:10               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1

```

---

**查看镜像元数据**

```shell
# 命令
docker inspect 容器id

# 测试
[root@192 roo]# docker inspect 0bb23343e3dc
[
    {
        "Id": "0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c",
        "Created": "2021-07-14T02:10:07.055890513Z",
        "Path": "/bin/sh",
        "Args": [
            "-c",
            "while true;do echo yangyang;sleep 1;done"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 7816,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2021-07-14T02:10:07.611405101Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55",
        "ResolvConfPath": "/var/lib/docker/containers/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c/hostname",
        "HostsPath": "/var/lib/docker/containers/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c/hosts",
        "LogPath": "/var/lib/docker/containers/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c/0bb23343e3dc15c70171cd97dca0abd3acea7327c0c3f1f6879a82c1234d5b7c-json.log",
        "Name": "/brave_boyd",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/31e3bc17c2d9a4927a25969af8159f2a978eac85b59da702f1b8b73dbd74c69b-init/diff:/var/lib/docker/overlay2/20b8e8381019a76417396ddc731cc09f767b78a17305e90e1ca2fab3eed8d937/diff",
                "MergedDir": "/var/lib/docker/overlay2/31e3bc17c2d9a4927a25969af8159f2a978eac85b59da702f1b8b73dbd74c69b/merged",
                "UpperDir": "/var/lib/docker/overlay2/31e3bc17c2d9a4927a25969af8159f2a978eac85b59da702f1b8b73dbd74c69b/diff",
                "WorkDir": "/var/lib/docker/overlay2/31e3bc17c2d9a4927a25969af8159f2a978eac85b59da702f1b8b73dbd74c69b/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "0bb23343e3dc",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "while true;do echo yangyang;sleep 1;done"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20201204",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "b14dbe27edc30bec32319d490380ec48c6a71763a2976535195fbfeb68b6b72b",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/b14dbe27edc3",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "b87ed48c0e8b119644d517e69061245e7d539bacba258c09106a4c8f9748b030",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "099aaaefd6fd69860eb620959fb3786d3eed7271793a2400a742b02e14ff5e52",
                    "EndpointID": "b87ed48c0e8b119644d517e69061245e7d539bacba258c09106a4c8f9748b030",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
```

---

**进入当前正在运行的容器**

```shell
# 我们通常容器id都是使⽤后台⽅式运⾏的，需要进⼊其中的容器，修改⼀些配置

#命令
docker exec -it 容器id /bin/bash

#测试
[root@192 roo]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
0bb23343e3dc   centos    "/bin/sh -c 'while t…"   5 minutes ago   Up 5 minutes             brave_boyd
[root@192 roo]# docker exec -it 0bb23343e3dc /bin/bash
[root@0bb23343e3dc /]# ls
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@0bb23343e3dc /]# ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 02:10 ?        00:00:00 /bin/sh -c while true;do echo yangyang;sleep 1;done
root         341       0  0 02:15 pts/0    00:00:00 /bin/bash
root         493       1  0 02:17 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1
root         494     341  0 02:17 pts/0    00:00:00 ps -ef

# 方式二
docker attach 容器id
正在执⾏当前的代码==>

#docker exec 		#进⼊容器后开启⼀个新的终端，可以在里面操作（常用）
#dockeer attach 	# 进⼊容器正在执⾏的终端，不会执⾏新的进程！
```

---

**将容器内⽂件拷⻉到主机上**

```shell
docker cp 容器id:容器内路径 ⽬的主机路径
#查看当前主机⽬录下
[root@192 roo]# docker run -it centos /bin/bash
[root@8636fcaea2e7 /]# [root@192 roo]# 
[root@192 roo]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES
8636fcaea2e7   centos    "/bin/bash"   9 seconds ago   Up 7 seconds             laughing_leavitt
[root@192 roo]# cd  /home
[root@192 home]# ls
roo
[root@192 home]# touch yangyang.java
[root@192 home]# ls
roo  yangyang.java
[root@192 home]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS          PORTS     NAMES
8636fcaea2e7   centos    "/bin/bash"   About a minute ago   Up 59 seconds             laughing_leavitt

#进入容器内部
[root@192 home]# docker attach 8636fcaea2e7 
[root@8636fcaea2e7 /]# cd /home
[root@8636fcaea2e7 home]# ls
[root@8636fcaea2e7 home]# touch yangyang .java
[root@8636fcaea2e7 home]# ls
yangyang
[root@8636fcaea2e7 home]# touch yangyang.java
[root@8636fcaea2e7 home]# ls
yangyang  yangyang.java

#将文件拷贝出来到主机上
[root@8636fcaea2e7 home]# read escape sequence
[root@192 home]# docker cp 8636fcaea2e7/home/yangyang /home
must specify at least one container source
[root@192 home]# docker cp 8636fcaea2e7:/home/yangyang /home
[root@192 home]# ls
roo  yangyang  yangyang.java

# 拷⻉是⼀个⼿动的过程 未来我们可以使⽤⼀个 -v 卷的技术，可以实现，⾃动同步
```

==学习⽅式:将所有命令全部敲⼀遍，⾃⼰记录笔记！==

#### 小结

![image-20210714103003092](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714103003092.png)

---

![image-20210714103213163](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714103213163.png)

![image-20210714103247654](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714103247654.png)

>  docker的命令是⼗分多的，上⾯学习的搜是最常⽤的容器和镜像命令，之后还有很多命令
>
> 接下来就是练习

#### 作业练习

> Docker安装Nginx

```shell 
# 1.搜索镜像
 docker search nginx
# 2.下载镜像
 docker pull nginx
# 3.运行测试
[root@192 ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
nginx         latest    4cdc5dd7eaad   7 days ago     133MB
hello-world   latest    d1165f221234   4 months ago   13.3kB
centos        latest    300e315adb2f   7 months ago   209MB

-d			# 后台运行
--name		# 给容器命名
-p			# 宿主机端口：容器内部端口
[root@192 ~]# docker run -d --name nginx01 -p 3344:80 nginx
7c882abe2415bd35124e5026782c72df61806c41a039e844a19ec92a17bd3066
[root@192 ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES
7c882abe2415   nginx     "/docker-entrypoint.…"   3 seconds ago   Up 2 seconds   0.0.0.0:3344->80/tcp, :::3344->80/tcp   nginx01
[root@192 ~]# curl 127.0.0.1:3344
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>

#进入容器
[root@192 ~]# docker exec -it nginx01 /bin/bash
root@7c882abe2415:/# whereis nginx
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
root@7c882abe2415:/# cd /etc/nginx
root@7c882abe2415:/etc/nginx# ls
conf.d	fastcgi_params	mime.types  modules  nginx.conf  scgi_params  uwsgi_params
root@7c882abe2415:/etc/nginx# 

```

![image-20210714110359456](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714110359456.png)

思考问题：我们每次改动nginx配置文件，都需要进入容器内部?十分的麻烦，我要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改?    -v    数据卷?



> Docker来安装⼀个tomcat

```shell
# 官⽅的使⽤
docker run -it --rm tomcat:9.0

# 我们之前的启动都是后台，停⽌了容器之后，容器还可以查到 docker run -it --rm 	⼀般⽤来测试，⽤完即删

# 先下载再启动
docker pull tomcat:9.0

# 启动并运⾏
[root@192 ~]# docker run -d -p 3355:8080 --name tomcat01 tomcat

#  测试访问没有问题

# 进入容器
[root@192 ~]# docker exec -it tomcat01 /bin/bash
# 发现问题：1、linux命令少了2、没有webapps。阿里云镜像的原因，默认是最小的镜像，所以不必要的都剔除了

#部署tomcat
[root@192 ~]# docker exec -it tomcat01 /bin/bash
root@c73003bfe775:/usr/local/tomcat# ls
BUILDING.txt	 LICENSE  README.md	 RUNNING.txt  conf  logs	    temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin	      lib   native-jni-lib  webapps  work
root@c73003bfe775:/usr/local/tomcat# ll
bash: ll: command not found
root@c73003bfe775:/usr/local/tomcat# cd webapps.dist
root@c73003bfe775:/usr/local/tomcat/webapps.dist# ls
ROOT  docs  examples  host-manager  manager
root@c73003bfe775:/usr/local/tomcat/webapps.dist# cd ../
root@c73003bfe775:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@c73003bfe775:/usr/local/tomcat# cd webapps
root@c73003bfe775:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager
#访问外网，没有问题
```

思考问题：我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？我要是可以在容器外部提供一个映射路径 , webapps，我们在外部放置项目，就自动同步到内部就好了!



> 部署es+kibana

```shell
# es 暴露的端⼝很多
# es ⼗分消耗内存
# es 的数据⼀般需要放置到安全⽬录！挂载

#启动 elasticsearch
思考：使⽤kibana连接es？思考如何才能连接过去
可视化
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2

# 启动了，linux就卡住了 docker stats查看cpu的状态

# 测试es是否成功
[root@192 ~]# curl 127.0.0.1:9200
{
  "name" : "2464c92a9984",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "8srwqr_wR2acAIY6WvIwFg",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}

# es 是⼗分耗内存的
# 查看 docker stats
#赶紧关闭，增加内存限制
```

![image-20210714193831166](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714193831166.png)

```shell
#赶紧关闭，增加内存限制,修改配置⽂件 -e 环境配置修改
[root@192 ~]# docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.6.2
```

![image-20210714201149142](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714201149142.png)

思考：使⽤kibana连接es？思考如何才能连接过去!

![image-20210714204228521](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714204228521.png)

#### 可视化

- portainer(先⽤这个)

```shell
docker run -d -p 8088:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

- Rancher(CI/CD再⽤)

**什么是portainer?**

Docker 图形化界⾯管理⼯具！提供⼀个后台⾯板供我们操作

```shell
docker run -d -p 8088:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

访问测试：外⽹：8088 http://192.168.80.1:8088/#/init/admin

通过它来访问

![image-20210714204944138](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714204944138.png)

选择本地的

![image-20210714205027240](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205027240.png)

进入之后的面板

![image-20210714205100201](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205100201.png)

![image-20210714205251288](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205251288.png)

可视化⾯板平时不会⽤，测试完即可

## Docker镜像讲解

#### 镜像是什么

镜像是⼀种轻量级可执⾏的软件包，⽤来打包软件的运⾏环境和基于环境开发的软件，包含运⾏某个软件所需要的所有内容，包括代码，运⾏时库，环境变量和配置⽂件

所有的应⽤直接打包docker镜像，就可以直接运⾏

如何得到镜像：

- 从远程仓库下载
- 朋友拷⻉
- 自己制作⼀个镜像 DockerFile

#### Docker镜像加速

> UnionFS(联合⽂件系统)

我们下载的时候看到的⼀层⼀层就是这个![image-20210714205512988](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205512988.png)

UnionFS(联合⽂件系统)：Union⽂件系统(UnionFS)是⼀种分层轻量级并且⾼性能的⽂件系统，他⽀持对⽂件系统的更改，作为⼀次提交来⼀层层的叠加，同时可以将不同的⽬录挂载到同⼀个虚拟⽂件系统下（unite several directories into a single virtual filesystem）。Union⽂件系统是Docker镜像的基础，镜像可以通过分层来继承，基于基础镜像（没有⽗镜像），可以制作各种具体的镜像。

特性：⼀次同时加载多个⽂件系统，但从外⾯来看，只能看到⼀个⽂件系统联合加载会把各层⽂件系统叠加起来，这样最终⽂件系统会包括所有底层的⽂件和⽬录

知乎解读：https://zhuanlan.zhihu.com/p/47025759?from_voters_page=true

---

> Docker镜像加载的原理

Docker镜像实际由⼀层层的⽂件系统组成，这种层级的⽂件系统UnionFS。



bootfs(coot dile system)主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs的⽂件系统，在docker镜像的最底层时是botfs。这⼀层与我们典型的Linux/Unix是⼀样的，包含boot加载器和内核，当boot加载完之后整个内核就在内存中了，此时的内存使⽤权已由bootfs转交给内核，此时系统也会卸载bootfs。

⿊屏---开机进⼊系统

rootfs(root file system)，在bootfs上，包含的就是典型的Linux系统中的/dev，/proc，/bin，/etc等标准⽬录⽂件，rootfs就是各种不同的操作系统的发⾏版，⽐如ubuntu，Centos等等；

![image-20210714205906257](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205906257.png)

平时我们安装的虚拟机的CentOS都是好⼏个G，为什么Docker这⾥才200M？

![image-20210714205923424](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714205923424.png)

对于⼀个精简的OS，rootfs可以⼩，只需要包含最基本的命令，⼯具和程序库就可以了，因为底层直接⽤host的kernel，⾃⼰只需要提供⼀个rootfs酷可以了，由此可⻅对于不同的linux发⾏版bootfs‘基本上是⼀致的，rootfs‘会有差别，因此不同的发⾏版可以公⽤bootfs。

**虚拟机是分钟级别的，容器是秒级的**

#### 分层理解

> 分层的镜像

我们可以下载⼀个镜像，注意观察下载的⽇志输出，可以看到是⼀层⼀层在下载！

![image-20210714210352763](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714210352763.png)

思考：为什么docker镜像要采⽤这种分层结构呢？

最⼤的好处就是资源共享，⽐如有多个镜像都从想通的base镜像构建⽽来，那么宿主机只需在磁盘上保留⼀份base镜像，同时内存中也只需要加载⼀份镜像，这样就可以为所有的容器服务了，⽽且镜像的每⼀层都可以共享。

查看镜像分层的⽅式可以通过`docker image inspect` 命令！

```shell
[root@192 ~]# docker pull redis
Using default tag: latest
latest: Pulling from library/redis
b4d181a07f80: Already exists 
86e428f79bcb: Pull complete 
ba0d0a025810: Pull complete 
ba9292c6f77e: Pull complete 
b96c0d1da602: Pull complete 
5e4b46455da3: Pull complete 
Digest: sha256:b6a9fc3535388a6fc04f3bdb83fb4d9d0b4ffd85e7609a6ff2f0f731427823e3
Status: Downloaded newer image for redis:latest
docker.io/library/redis:latest
[root@192 ~]# docker image inspect redis:latest
[
    {
        "Id": "sha256:08502081bff61084d64fc76f0f90ea39b89935cd071d9e12c5374ae191ff53c0",
        "RepoTags": [
            "redis:latest"
        ],
        "RepoDigests": [
            "redis@sha256:b6a9fc3535388a6fc04f3bdb83fb4d9d0b4ffd85e7609a6ff2f0f731427823e3"
        ],
        "Parent": "",
        "Comment": "",
        "Created": "2021-06-23T16:36:30.182210591Z",
        "Container": "ff24eb24b3cff07ced352081b984ecafb749404469993462cbd773258d1a56fe",
        "ContainerConfig": {
            "Hostname": "ff24eb24b3cf",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "6379/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.12",
                "REDIS_VERSION=6.2.4",
                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.2.4.tar.gz",
                "REDIS_DOWNLOAD_SHA=ba32c406a10fc2c09426e2be2787d74ff204eb3a2e496d87cff76a476b6ae16e"
            ],
            "Cmd": [
                "/bin/sh",
                "-c",
                "#(nop) ",
                "CMD [\"redis-server\"]"
            ],
            "Image": "sha256:e39f8a5eb6f06bc15438105f98a52afaa51dc6fb498e2e49ddc5e38916478394",
            "Volumes": {
                "/data": {}
            },
            "WorkingDir": "/data",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": {}
        },
        "DockerVersion": "19.03.12",
        "Author": "",
        "Config": {
            "Hostname": "",
            "Domainname": "",
            "User": "",
            "AttachStdin": false,
            "AttachStdout": false,
            "AttachStderr": false,
            "ExposedPorts": {
                "6379/tcp": {}
            },
            "Tty": false,
            "OpenStdin": false,
            "StdinOnce": false,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin",
                "GOSU_VERSION=1.12",
                "REDIS_VERSION=6.2.4",
                "REDIS_DOWNLOAD_URL=http://download.redis.io/releases/redis-6.2.4.tar.gz",
                "REDIS_DOWNLOAD_SHA=ba32c406a10fc2c09426e2be2787d74ff204eb3a2e496d87cff76a476b6ae16e"
            ],
            "Cmd": [
                "redis-server"
            ],
            "Image": "sha256:e39f8a5eb6f06bc15438105f98a52afaa51dc6fb498e2e49ddc5e38916478394",
            "Volumes": {
                "/data": {}
            },
            "WorkingDir": "/data",
            "Entrypoint": [
                "docker-entrypoint.sh"
            ],
            "OnBuild": null,
            "Labels": null
        },
        "Architecture": "amd64",
        "Os": "linux",
        "Size": 105394545,
        "VirtualSize": 105394545,
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/2d481fb67b4236c0de192288f3dc2b1052fc5326e24f15f208390b2f6424b948/diff:/var/lib/docker/overlay2/901e9c9ea320b633f37bc0a7268e8a46bc7083d7dd7a6453d1614455d5d1fbe5/diff:/var/lib/docker/overlay2/028089062f384a27789ab22779d1a9ae90e1f603efedd2abb27509a5b5811267/diff:/var/lib/docker/overlay2/f418e7b2f54a421ffd1583543fc8cc2fcdf94ad3805f096adcb7bf6e2e93e19b/diff:/var/lib/docker/overlay2/7544f583bcb8cb845806da98a5f92187843e0effb03497750b684052f410f46f/diff",
                "MergedDir": "/var/lib/docker/overlay2/186f7933146e3cac0b58373d7e10b6b667f99e4f3c17fb150feeccd741151733/merged",
                "UpperDir": "/var/lib/docker/overlay2/186f7933146e3cac0b58373d7e10b6b667f99e4f3c17fb150feeccd741151733/diff",
                "WorkDir": "/var/lib/docker/overlay2/186f7933146e3cac0b58373d7e10b6b667f99e4f3c17fb150feeccd741151733/work"
            },
            "Name": "overlay2"
        },
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:764055ebc9a7a290b64d17cf9ea550f1099c202d83795aa967428ebdf335c9f7",
                "sha256:245c9d23f65373415922e53424032cabe7b282c5cf8f9f8070a7d1830fca6871",
                "sha256:ebef6caacb966ed54c0c3facf2288fa5124452f2c0a17faa1941625eab0ceb54",
                "sha256:0b7b774038f08ec329e4dd2c0be440c487cfb003a05fce87cd5d1497b602f2c1",
                "sha256:a71d36a87572d637aa446110faf8abb4ea74f028d0e0737f2ff2b983ef23abf3",
                "sha256:9e1fddfb3a22146392a2d6491e1af2f087da5e6551849a6174fa23051ef8a38f"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]
```

理解：

所有的docker镜像都起源于⼀个基础镜像层，当进⾏修改或增加新的内容时，就会在当前的镜像层上，创建新的镜像层。

举⼀个简单的例⼦，假如基于Ubuntu linux 16.04创建⼀个新的镜像，这就是镜像的第⼀层；如果在该镜像中添加python包，就会在基础镜像上创建第⼆个镜像层；如果继续添加⼀个安全补丁，就会创建第三个镜像层。

改镜像当前已经包含3个镜像层如下图所示![image-20210714213543892](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714213543892.png)

在添加额外镜像层的同时，镜像始终保持着当前所有镜像的组合，理解着⼀点⾮常重要，下图举了⼀个⾮常简单的例⼦，每个镜像层包含3个⽂件，⽽镜像包含了来⾃两个镜像层的6个⽂件![image-20210714213606764](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714213606764.png)

上⾯的镜像层和之前的略有区别，主要⽬的是便于展示⽂件。

下图站是了⼀个稍微复杂的三层镜像，在外部看来整个镜像只有6个⽂件，这是因为最上层的⽂件7是⽂件5的更新版![image-20210714213722276](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714213722276.png)

这种情况下，上层镜像的⽂件覆盖了底层镜像的⽂件，这样就使得⽂件的更新版本作为⼀个镜像层添加

到镜像中。

Docker通过存储引擎（新版本采⽤快照机制）的⽅式来实现镜像层的堆栈，并保证多镜像层对外展示为统⼀的⽂件系统。

Linux上可⽤的存储引擎有AUFS，Overlay2，Decvice Mapper，Btrfs以及ZFS。顾名思义，每种存储引擎都基于LInux中对应的⽂件系统或者快设备技术，并且每种存储引擎都有独有的性能特点。

Docker在winows仅⽀持windowsfilter⼀种存储引擎，改引擎基于NTFS⽂件系统之上实现了分层和cow[1]。

下⾯展示了与系统显示相同的三层镜像，所有镜像层堆叠并合并，对外提供统⼀的视图。

![image-20210714214019181](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714214019181.png)

---

> 特点

Docker镜像都是只读的，当容器启动时，⼀个新的可写层被加载到镜像的顶部！

这⼀层就是我们通常说的容器层，容器层之下就是镜像层！

![image-20210714214155274](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714214155274.png)

如何提交⼀个⾃⼰的镜像？

#### commit镜像

```shell
docker commit 提交容器成为⼀个新的副本
#命令和git类似
docker commit -m="提交的描述信息" -a="作者" 容器id ⽬标镜像名:[TAG]
```

实战测试：

```shell
# 1.启动⼀个默认的tomacat

# 2.发现这个默认的tomcat是没有webapps的，镜像的原因，官⽅的镜像默认的webapps下⾯是没有⽂件的

# 3.我⾃⼰拷⻉进去了⼀个基本⽂件

# 4.将我们操作过的容器通过commit提交为1个镜像！我们以后就使⽤我们修改过的镜像即可，这就是我们⾃⼰的⼀个镜像
```

![image-20210714215356632](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714215356632.png)

学习⽅式说明：理解概念，但是⼀定要实践，最后实践和理论相结合，⼀次搞定

```
如果你想要保存当前的容器状态，就可以通过commit提交 ，获得⼀个镜像
就好⽐vm的快照
```

**到这⾥才算是⼊⻔！**

## 容器数据卷

#### 什么是容器数据卷

**docker的理念回顾**

将应⽤和环境打包成⼀个镜像！

数据？如果数据在容器中，容器⼀旦删除，数据就会丢失！==需求：数据可以持久化==

MySQL，容器删了，删库跑路！ ==需求：Mysql的数据可以存储在本地或者其他地⽅==

容器之间可以有数据共享的技术 ！Docker容器中产⽣的数据，同步到本地 ！

这就是卷技术！⽬录的挂载，将我们容器内的⽬录，挂载到linux！

![image-20210714220047548](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714220047548.png)

**总结：容器的持久化和同步操作！容器间也是可以数据共享的！**

#### 使用数据卷

> 方式一：直接使⽤命令来挂载 -v

```shell
docker run -it -v 主机⽬录:容器⽬录 -P 主机端⼝:容器端⼝
[root@192 home]# docker run -it -v /home/ceshi:/home centos /bin/bash

# 启动后可以通过docker inspect 容器id
```

![image-20210714221454858](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714221454858.png)

测试文件的同步

![image-20210714221746512](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714221746512.png)

再来测试！

1. 停⽌容器

2. 在宿主机上修改⽂件

3. 再次启动容器

4. 发现容器内的⽂件修改同步

![image-20210714222337859](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714222337859.png)

好处：我们以后修改只需在本地修改即可，容器内会⾃动同步

#### 实战：安装Mysql

思考:mysql数据持久化问题 data

```shell
# 获取镜像
[root@localhost ~]# docker pull mysql:5.7

# 运⾏容器，需要做数据挂载！启动mysql，需要配置密码的，要注意
# 官⽅测试： docker run --name some-mysql-e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag

# 启动我们的
-d 后台运⾏
-p 端⼝映射
-v 数据卷挂载
-e 环境配置
--name 容器名字

[root@192 home]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=80231hdd --name mysql01 mysql:5.7

# 启动成功之后在本地使⽤navicat链接测试
# 本地的mysql -h -u -p 连接到服务器的3310，3310和容器内的3306 映射
mysql -h 192.168.80.1 -P 3310 -uroot -p80231hdd
```

假设我们将容器删除

发现，我们挂载到本地的数据卷 依旧没有丢失，这就实现了容器数据持久化功能

#### 具名挂载和匿名挂载

```shell
# 匿名挂载
-v 容器内路径
docker run -d -p --name ngnix01 -v /etc/ngnix

#查看所有的volume的情况
[root@192 home]# docker volume ls
DRIVER    VOLUME NAME
local     af873ca78a40cf6e44f4ef6fecd54b1ff94e4d977fff958b460af233cf17aca9
local     c639c329a03829240cdbb640770fcef4942bafb5130936042edea1ba5681d68d
# 这⾥发现，这种就是匿名挂载，我们在-v 的时只写了容器内的路径，没有写容器外的路径

# 具名挂载
[root@192 home]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx
d1f2cd8cf72210f6336fff4c817ca871de1efde6551db98c99757d042c61c6da
[root@192 home]# docker volume ls
DRIVER    VOLUME NAME
local     af873ca78a40cf6e44f4ef6fecd54b1ff94e4d977fff958b460af233cf17aca9
local     c639c329a03829240cdbb640770fcef4942bafb5130936042edea1ba5681d68d
local     juming-nginx

# 通过 -v 卷名:容器内路径
# 查看⼀下这个卷
[root@192 home]# docker volume inspect juming-nginx
[
    {
        "CreatedAt": "2021-07-14T10:45:40-04:00",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/juming-nginx/_data",
        "Name": "juming-nginx",
        "Options": null,
        "Scope": "local"
    }
]
```

![image-20210714224731474](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714224731474.png)

所有docker容器内的卷，没有指定⽬录的情况下都是在 **/var/lib/docker/volumes/juming-nginx/_data**

我们通过具名挂载可以更⽅便的找到我们的卷，⼤多数情况使⽤**具名挂载**

```shell
# 如何确定是具名挂载还是匿名挂载
-v 容器内路径 				#匿名挂载
-v 卷名:容器内路径 			#具名挂载
-v /宿主机的路径:容器内路径 	#指定路径挂载
```

扩展：

```shell
# 通过-v 容器内路径:加上ro/rw改变读写权限
ro readonly		#只读
re readwrite	#可读可写

# ⼀旦设置了容器权限，容器对我们挂载出来的内容就有限定了
docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx:ro nginx
docker run -d -P --name nginx01 -v juming-nginx:/etc/nginx:rw nginx

#ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是⽆法操作的
```

#### 初识DockerFile

DockerFile就是⽤来构建docker镜像的构建⽂件！命令脚本！

通过这个脚本可以⽣成⼀个镜像，镜像是⼀层⼀层的，脚本⼀个个的命令，每个命令都是⼀层

```shell
# 创建⼀个dockerfile的⽂件，名字可以随机 建议Dockerfile
[root@192 docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1 -t yangyang/centos .

# ⽂件中的内容 指令 参数
FROM centos
VOLUME ["volume01","volume02"]
CMD echo"---end----"
CMD /bin/bash

# 每个命令都是镜像的⼀层
```

![image-20210714230259893](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714230259893.png)

```shell
启动一个自己写的容器
```

![image-20210714230855726](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714230855726.png)

这个卷和外部有⼀个同步的⽬录

![image-20210714230945536](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714230945536.png)

查看卷挂载的路径

![image-20210714231110390](C:/Users/29854/AppData/Roaming/Typora/typora-user-images/image-20210714231110390.png)

假设构建镜像时没有挂载卷，要⼿动挂载镜像		 -v 卷名:容器内路径！

#### 数据卷容器































## DockerFile

## Docker网络

